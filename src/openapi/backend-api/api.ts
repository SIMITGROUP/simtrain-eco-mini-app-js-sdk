/* tslint:disable */
/* eslint-disable */
/**
 * simtrain-eco backend api
 * Internal use only (generator: 2.0.0w-alpha)
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface AcademySession
 */
export interface AcademySession {
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AcademySession
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AcademySession
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AcademySession
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  academySessionCode?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  academySessionName?: string;
  /**
   *
   * @type {boolean}
   * @memberof AcademySession
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  endDate?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySession
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof AcademySession
   */
  more?: object;
}
/**
 *
 * @export
 * @interface AcademySessionAutoComplete
 */
export interface AcademySessionAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AcademySessionAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionAutoComplete
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionAutoComplete
   */
  endDate?: string;
}
/**
 *
 * @export
 * @interface AcademySessionClassGenerator
 */
export interface AcademySessionClassGenerator {
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AcademySessionClassGenerator
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AcademySessionClassGenerator
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AcademySessionClassGenerator
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  generateNo?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  fromAcademySessionId?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  toAcademySessionId?: string;
  /**
   *
   * @type {boolean}
   * @memberof AcademySessionClassGenerator
   */
  migrateEnrollment?: boolean;
  /**
   *
   * @type {number}
   * @memberof AcademySessionClassGenerator
   */
  classQuantity?: number;
  /**
   *
   * @type {number}
   * @memberof AcademySessionClassGenerator
   */
  enrollmentQuantity?: number;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGenerator
   */
  histories?: string;
  /**
   *
   * @type {Array<AcademySessionClassGeneratorDetails>}
   * @memberof AcademySessionClassGenerator
   */
  details?: Array<AcademySessionClassGeneratorDetails>;
}
/**
 *
 * @export
 * @interface AcademySessionClassGeneratorAutoComplete
 */
export interface AcademySessionClassGeneratorAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AcademySessionClassGeneratorDetails
 */
export interface AcademySessionClassGeneratorDetails {
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  fromTuitionClassId?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  asProductId?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  asTeacherId?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  asRoomId?: string;
  /**
   *
   * @type {boolean}
   * @memberof AcademySessionClassGeneratorDetails
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AcademySessionClassGeneratorDetails
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface AccountTransaction
 */
export interface AccountTransaction {
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  documentNo: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  documentName: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  date: string;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  amount: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  ledgerAmt?: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  salesAmt?: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  knockOffAmt: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  balance: number;
  /**
   *
   * @type {number}
   * @memberof AccountTransaction
   */
  refundAmount?: number;
  /**
   *
   * @type {string}
   * @memberof AccountTransaction
   */
  description?: string;
  /**
   *
   * @type {AccountTransactionStudent}
   * @memberof AccountTransaction
   */
  student: AccountTransactionStudent;
  /**
   *
   * @type {AccountTransactionAgent}
   * @memberof AccountTransaction
   */
  agent?: AccountTransactionAgent;
  /**
   *
   * @type {AccountTransactionDocument}
   * @memberof AccountTransaction
   */
  document: AccountTransactionDocument;
  /**
   *
   * @type {Array<AccountTransactionKnockOff>}
   * @memberof AccountTransaction
   */
  knockOff?: Array<AccountTransactionKnockOff>;
  /**
   *
   * @type {Array<AccountTransactionRefunds>}
   * @memberof AccountTransaction
   */
  refunds?: Array<AccountTransactionRefunds>;
}
/**
 *
 * @export
 * @interface AccountTransactionAgent
 */
export interface AccountTransactionAgent {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AccountTransactionAutoComplete
 */
export interface AccountTransactionAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AccountTransactionDocument
 */
export interface AccountTransactionDocument {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionDocument
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionDocument
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionDocument
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AccountTransactionKnockOff
 */
export interface AccountTransactionKnockOff {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  documentName?: string;
  /**
   *
   * @type {number}
   * @memberof AccountTransactionKnockOff
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOff
   */
  updatedBy?: string;
  /**
   *
   * @type {AccountTransactionKnockOffDocument}
   * @memberof AccountTransactionKnockOff
   */
  document?: AccountTransactionKnockOffDocument;
}
/**
 *
 * @export
 * @interface AccountTransactionKnockOffDocument
 */
export interface AccountTransactionKnockOffDocument {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOffDocument
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOffDocument
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionKnockOffDocument
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AccountTransactionRefunds
 */
export interface AccountTransactionRefunds {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefunds
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefunds
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefunds
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefunds
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefunds
   */
  updatedBy?: string;
  /**
   *
   * @type {AccountTransactionRefundsDocument}
   * @memberof AccountTransactionRefunds
   */
  document?: AccountTransactionRefundsDocument;
}
/**
 *
 * @export
 * @interface AccountTransactionRefundsDocument
 */
export interface AccountTransactionRefundsDocument {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefundsDocument
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefundsDocument
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefundsDocument
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof AccountTransactionRefundsDocument
   */
  refundTotal?: number;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionRefundsDocument
   */
  refundDate?: string;
}
/**
 *
 * @export
 * @interface AccountTransactionStudent
 */
export interface AccountTransactionStudent {
  /**
   *
   * @type {string}
   * @memberof AccountTransactionStudent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AccountTransactionStudent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ActionHistory
 */
export interface ActionHistory {
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof ActionHistory
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof ActionHistory
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof ActionHistory
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  actionType: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  startActionTime?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  endActionTime?: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistory
   */
  requestBody?: string;
  /**
   *
   * @type {object}
   * @memberof ActionHistory
   */
  data?: object;
}
/**
 *
 * @export
 * @interface ActionHistoryAutoComplete
 */
export interface ActionHistoryAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ActionHistoryAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistoryAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ActionHistoryAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Agent
 */
export interface Agent {
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Agent
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Agent
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Agent
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  agentCode: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  agentName: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  ic?: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  dob: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  mobileNo: string;
  /**
   *
   * @type {boolean}
   * @memberof Agent
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Agent
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Agent
   */
  more?: object;
}
/**
 *
 * @export
 * @interface AgentAutoComplete
 */
export interface AgentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AgentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AgentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AgentAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Announcement
 */
export interface Announcement {
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Announcement
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Announcement
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Announcement
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  announcementNo?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  targets?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  announcementDate: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  closeDate: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  internalNote?: string;
  /**
   *
   * @type {string}
   * @memberof Announcement
   */
  documentStatus?: string;
  /**
   *
   * @type {AnnouncementAnnouncementtype}
   * @memberof Announcement
   */
  announcementtype?: AnnouncementAnnouncementtype;
  /**
   *
   * @type {AnnouncementNotified}
   * @memberof Announcement
   */
  notified?: AnnouncementNotified;
  /**
   *
   * @type {Array<AnnouncementTargetsTeachers>}
   * @memberof Announcement
   */
  targetsTeachers?: Array<AnnouncementTargetsTeachers>;
  /**
   *
   * @type {Array<AnnouncementTargetsTeacherGroups>}
   * @memberof Announcement
   */
  targetsTeacherGroups?: Array<AnnouncementTargetsTeacherGroups>;
  /**
   *
   * @type {Array<AnnouncementTargetsLevels>}
   * @memberof Announcement
   */
  targetsLevels?: Array<AnnouncementTargetsLevels>;
  /**
   *
   * @type {Array<AnnouncementTargetsStudents>}
   * @memberof Announcement
   */
  targetsStudents?: Array<AnnouncementTargetsStudents>;
  /**
   *
   * @type {Array<AnnouncementTargetsClasses>}
   * @memberof Announcement
   */
  targetsClasses?: Array<AnnouncementTargetsClasses>;
  /**
   *
   * @type {AnnouncementPreparedBy}
   * @memberof Announcement
   */
  preparedBy?: AnnouncementPreparedBy;
  /**
   *
   * @type {AnnouncementDocNoFormat}
   * @memberof Announcement
   */
  docNoFormat?: AnnouncementDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Announcement
   */
  more?: object;
}
/**
 *
 * @export
 * @interface AnnouncementAnnouncementtype
 */
export interface AnnouncementAnnouncementtype {
  /**
   *
   * @type {string}
   * @memberof AnnouncementAnnouncementtype
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementAnnouncementtype
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementAnnouncementtype
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementAutoComplete
 */
export interface AnnouncementAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AnnouncementAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementAutoComplete
   */
  announcementDate?: string;
}
/**
 *
 * @export
 * @interface AnnouncementDocNoFormat
 */
export interface AnnouncementDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof AnnouncementDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementNotified
 */
export interface AnnouncementNotified {
  /**
   *
   * @type {boolean}
   * @memberof AnnouncementNotified
   */
  sent?: boolean;
  /**
   *
   * @type {string}
   * @memberof AnnouncementNotified
   */
  date?: string;
}
/**
 *
 * @export
 * @interface AnnouncementPreparedBy
 */
export interface AnnouncementPreparedBy {
  /**
   *
   * @type {string}
   * @memberof AnnouncementPreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementPreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementPreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface AnnouncementResponse
 */
export interface AnnouncementResponse {
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  announcementNo: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  body: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof AnnouncementResponse
   */
  preparedBy?: ForeignKey | null;
  /**
   *
   * @type {ForeignKey}
   * @memberof AnnouncementResponse
   */
  announcementtype?: ForeignKey | null;
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  announcementDate: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementResponse
   */
  closeDate: string;
  /**
   *
   * @type {boolean}
   * @memberof AnnouncementResponse
   */
  read?: boolean;
  /**
   *
   * @type {ForeignKey}
   * @memberof AnnouncementResponse
   */
  target?: ForeignKey | null;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsClasses
 */
export interface AnnouncementTargetsClasses {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClasses
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClasses
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClasses
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClasses
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClasses
   */
  _id?: string;
  /**
   *
   * @type {AnnouncementTargetsClassesPerson}
   * @memberof AnnouncementTargetsClasses
   */
  person?: AnnouncementTargetsClassesPerson;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsClassesPerson
 */
export interface AnnouncementTargetsClassesPerson {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClassesPerson
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClassesPerson
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsClassesPerson
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsLevels
 */
export interface AnnouncementTargetsLevels {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevels
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevels
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevels
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevels
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevels
   */
  _id?: string;
  /**
   *
   * @type {AnnouncementTargetsLevelsPerson}
   * @memberof AnnouncementTargetsLevels
   */
  person?: AnnouncementTargetsLevelsPerson;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsLevelsPerson
 */
export interface AnnouncementTargetsLevelsPerson {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevelsPerson
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevelsPerson
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsLevelsPerson
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsStudents
 */
export interface AnnouncementTargetsStudents {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudents
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudents
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudents
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudents
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudents
   */
  _id?: string;
  /**
   *
   * @type {AnnouncementTargetsStudentsPerson}
   * @memberof AnnouncementTargetsStudents
   */
  person?: AnnouncementTargetsStudentsPerson;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsStudentsPerson
 */
export interface AnnouncementTargetsStudentsPerson {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudentsPerson
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudentsPerson
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsStudentsPerson
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsTeacherGroups
 */
export interface AnnouncementTargetsTeacherGroups {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  _id?: string;
  /**
   *
   * @type {AnnouncementTargetsTeacherGroupsPerson}
   * @memberof AnnouncementTargetsTeacherGroups
   */
  person?: AnnouncementTargetsTeacherGroupsPerson;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsTeacherGroupsPerson
 */
export interface AnnouncementTargetsTeacherGroupsPerson {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroupsPerson
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroupsPerson
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeacherGroupsPerson
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsTeachers
 */
export interface AnnouncementTargetsTeachers {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachers
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachers
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachers
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachers
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachers
   */
  _id?: string;
  /**
   *
   * @type {AnnouncementTargetsTeachersPerson}
   * @memberof AnnouncementTargetsTeachers
   */
  person?: AnnouncementTargetsTeachersPerson;
}
/**
 *
 * @export
 * @interface AnnouncementTargetsTeachersPerson
 */
export interface AnnouncementTargetsTeachersPerson {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachersPerson
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachersPerson
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTargetsTeachersPerson
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AnnouncementType
 */
export interface AnnouncementType {
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AnnouncementType
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AnnouncementType
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AnnouncementType
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  announcementtypeCode?: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  announcementtypeName?: string;
  /**
   *
   * @type {boolean}
   * @memberof AnnouncementType
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof AnnouncementType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof AnnouncementType
   */
  more?: object;
}
/**
 *
 * @export
 * @interface AnnouncementTypeAutoComplete
 */
export interface AnnouncementTypeAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AnnouncementTypeAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTypeAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AnnouncementTypeAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AppIntegration
 */
export interface AppIntegration {
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AppIntegration
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AppIntegration
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AppIntegration
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  appId: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegration
   */
  appType: string;
  /**
   *
   * @type {boolean}
   * @memberof AppIntegration
   */
  active?: boolean;
  /**
   *
   * @type {AppIntegrationSettings}
   * @memberof AppIntegration
   */
  settings: AppIntegrationSettings;
}
/**
 *
 * @export
 * @interface AppIntegrationAutoComplete
 */
export interface AppIntegrationAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AppIntegrationLog
 */
export interface AppIntegrationLog {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AppIntegrationLog
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AppIntegrationLog
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AppIntegrationLog
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  appId?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  requestUrl: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  requestMethod: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  responseCode: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  responseMessage: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLog
   */
  dataTransfer: string;
}
/**
 *
 * @export
 * @interface AppIntegrationLogAutoComplete
 */
export interface AppIntegrationLogAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLogAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLogAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationLogAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AppIntegrationSettings
 */
export interface AppIntegrationSettings {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  systemLink?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  orgCode?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  appSystemBranch?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  defaultDebtorAccount?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  defaultSalesAccount?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  defaultRoundingAccount?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  defaultRefundAccount?: string;
  /**
   *
   * @type {boolean}
   * @memberof AppIntegrationSettings
   */
  isAutoSubmitEinvoice?: boolean;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettings
   */
  implementationDate?: string;
  /**
   *
   * @type {Array<AppIntegrationSettingsDebtorAccountConfig>}
   * @memberof AppIntegrationSettings
   */
  debtorAccountConfig?: Array<AppIntegrationSettingsDebtorAccountConfig>;
  /**
   *
   * @type {Array<AppIntegrationSettingsSalesAccountConfig>}
   * @memberof AppIntegrationSettings
   */
  salesAccountConfig?: Array<AppIntegrationSettingsSalesAccountConfig>;
  /**
   *
   * @type {Array<AppIntegrationSettingsBankAccountConfig>}
   * @memberof AppIntegrationSettings
   */
  bankAccountConfig?: Array<AppIntegrationSettingsBankAccountConfig>;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsBankAccountConfig
 */
export interface AppIntegrationSettingsBankAccountConfig {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  account?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  _id?: string;
  /**
   *
   * @type {AppIntegrationSettingsBankAccountConfigPaymentMethod}
   * @memberof AppIntegrationSettingsBankAccountConfig
   */
  paymentMethod?: AppIntegrationSettingsBankAccountConfigPaymentMethod;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsBankAccountConfigPaymentMethod
 */
export interface AppIntegrationSettingsBankAccountConfigPaymentMethod {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfigPaymentMethod
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfigPaymentMethod
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsBankAccountConfigPaymentMethod
   */
  code?: string;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsDebtorAccountConfig
 */
export interface AppIntegrationSettingsDebtorAccountConfig {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  account?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  _id?: string;
  /**
   *
   * @type {AppIntegrationSettingsDebtorAccountConfigLevel}
   * @memberof AppIntegrationSettingsDebtorAccountConfig
   */
  level?: AppIntegrationSettingsDebtorAccountConfigLevel;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsDebtorAccountConfigLevel
 */
export interface AppIntegrationSettingsDebtorAccountConfigLevel {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfigLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfigLevel
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsDebtorAccountConfigLevel
   */
  code?: string;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsSalesAccountConfig
 */
export interface AppIntegrationSettingsSalesAccountConfig {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  account?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  _id?: string;
  /**
   *
   * @type {AppIntegrationSettingsSalesAccountConfigProductCategory}
   * @memberof AppIntegrationSettingsSalesAccountConfig
   */
  productCategory?: AppIntegrationSettingsSalesAccountConfigProductCategory;
}
/**
 *
 * @export
 * @interface AppIntegrationSettingsSalesAccountConfigProductCategory
 */
export interface AppIntegrationSettingsSalesAccountConfigProductCategory {
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfigProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfigProductCategory
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfigProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AppIntegrationSettingsSalesAccountConfigProductCategory
   */
  categoryType?: string;
}
/**
 *
 * @export
 * @interface AppUserAnnouncementView
 */
export interface AppUserAnnouncementView {
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AppUserAnnouncementView
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AppUserAnnouncementView
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AppUserAnnouncementView
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementView
   */
  appUserId?: string;
  /**
   *
   * @type {boolean}
   * @memberof AppUserAnnouncementView
   */
  read?: boolean;
  /**
   *
   * @type {AppUserAnnouncementViewAnnouncement}
   * @memberof AppUserAnnouncementView
   */
  announcement?: AppUserAnnouncementViewAnnouncement;
}
/**
 *
 * @export
 * @interface AppUserAnnouncementViewAnnouncement
 */
export interface AppUserAnnouncementViewAnnouncement {
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAnnouncement
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAnnouncement
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAnnouncement
   */
  label?: string;
}
/**
 *
 * @export
 * @interface AppUserAnnouncementViewAutoComplete
 */
export interface AppUserAnnouncementViewAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AppUserAnnouncementViewAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Area
 */
export interface Area {
  /**
   *
   * @type {string}
   * @memberof Area
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Area
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Area
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Area
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  areaCode?: string;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  areaName?: string;
  /**
   *
   * @type {boolean}
   * @memberof Area
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Area
   */
  more?: object;
}
/**
 *
 * @export
 * @interface AreaAutoComplete
 */
export interface AreaAutoComplete {
  /**
   *
   * @type {string}
   * @memberof AreaAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AreaAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AreaAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface AssignSummary
 */
export interface AssignSummary {
  /**
   *
   * @type {string}
   * @memberof AssignSummary
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof AssignSummary
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof AssignSummary
   */
  teacherName: string;
  /**
   *
   * @type {number}
   * @memberof AssignSummary
   */
  numClass: number;
}
/**
 *
 * @export
 * @interface Attendance
 */
export interface Attendance {
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  _id: string;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  termNo: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  scheduleNo: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  tenantId: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  orgId: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  branchId: number;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  endTime: string;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  day: string;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  onlineClassUrl: string;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  duration: number;
  /**
   *
   * @type {ScheduleTeacher}
   * @memberof Attendance
   */
  teacher: ScheduleTeacher;
  /**
   *
   * @type {ScheduleRoom}
   * @memberof Attendance
   */
  room: ScheduleRoom;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  studentQty: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  presentQty: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  presentPercent: number;
  /**
   *
   * @type {number}
   * @memberof Attendance
   */
  maxStudents: number;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  lessonPlan: string;
  /**
   *
   * @type {boolean}
   * @memberof Attendance
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  attDescription: string;
  /**
   *
   * @type {string}
   * @memberof Attendance
   */
  description: string;
  /**
   *
   * @type {ScheduleTuitionClass}
   * @memberof Attendance
   */
  tuitionClass: ScheduleTuitionClass;
  /**
   *
   * @type {Array<AttendanceStudent>}
   * @memberof Attendance
   */
  students: Array<AttendanceStudent>;
}
/**
 *
 * @export
 * @interface AttendanceReport
 */
export interface AttendanceReport {
  /**
   *
   * @type {string}
   * @memberof AttendanceReport
   */
  datetime: string;
  /**
   *
   * @type {Array<DailyAttendance>}
   * @memberof AttendanceReport
   */
  data: Array<DailyAttendance>;
}
/**
 *
 * @export
 * @interface AttendanceStudent
 */
export interface AttendanceStudent {
  /**
   *
   * @type {string}
   * @memberof AttendanceStudent
   */
  enrollmentId: string;
  /**
   *
   * @type {boolean}
   * @memberof AttendanceStudent
   */
  attend: boolean;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudent
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudent
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudent
   */
  _id: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof AttendanceStudent
   */
  student: ForeignKey;
  /**
   *
   * @type {AttendanceStudentsReplacement}
   * @memberof AttendanceStudent
   */
  replacement: AttendanceStudentsReplacement;
}
/**
 *
 * @export
 * @interface AttendanceStudentsReplacement
 */
export interface AttendanceStudentsReplacement {
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  endTime: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  day: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  teacherName: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  roomNo: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceStudentsReplacement
   */
  description: string;
}
/**
 *
 * @export
 * @interface AttendanceSummaryByTable
 */
export interface AttendanceSummaryByTable {
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  datetime: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  classId: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  className: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  levelId: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  levelCode: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  levelName: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTable
   */
  teacherName: string;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTable
   */
  numStudent: number;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTable
   */
  numLessons: number;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTable
   */
  duration: number;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTable
   */
  numAttend: number;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTable
   */
  attendanceRate: number;
}
/**
 *
 * @export
 * @interface AttendanceSummaryByTeacher
 */
export interface AttendanceSummaryByTeacher {
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  datetime: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  classId: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  className: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof AttendanceSummaryByTeacher
   */
  teacherName: string;
  /**
   *
   * @type {number}
   * @memberof AttendanceSummaryByTeacher
   */
  attendanceRate: number;
}
/**
 *
 * @export
 * @interface AvailablePackageResponse
 */
export interface AvailablePackageResponse {
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof AvailablePackageResponse
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof AvailablePackageResponse
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof AvailablePackageResponse
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  packageCode: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  packageName: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  packageType: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  packageMethod?: string;
  /**
   *
   * @type {boolean}
   * @memberof AvailablePackageResponse
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof AvailablePackageResponse
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof AvailablePackageResponse
   */
  amount: number;
  /**
   *
   * @type {ProductPackageLevel}
   * @memberof AvailablePackageResponse
   */
  level: ProductPackageLevel;
  /**
   *
   * @type {ProductPackageSubjectQuantitySettings}
   * @memberof AvailablePackageResponse
   */
  subjectQuantitySettings?: ProductPackageSubjectQuantitySettings;
  /**
   *
   * @type {Array<ProductPackageProducts>}
   * @memberof AvailablePackageResponse
   */
  products?: Array<ProductPackageProducts>;
  /**
   *
   * @type {object}
   * @memberof AvailablePackageResponse
   */
  more?: object;
  /**
   * Ordered product IDs matching the package slot arrangement
   * @type {Array<string>}
   * @memberof AvailablePackageResponse
   */
  preferProduct: Array<string>;
}
/**
 *
 * @export
 * @interface BillDocumentType
 */
export interface BillDocumentType {
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  documentDate: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  documentNo: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  documentType: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  levelName: string;
  /**
   *
   * @type {number}
   * @memberof BillDocumentType
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  batchNo: string;
  /**
   *
   * @type {string}
   * @memberof BillDocumentType
   */
  status: string;
  /**
   *
   * @type {Array<SystemIntegrateProperties>}
   * @memberof BillDocumentType
   */
  integrateSystem: Array<SystemIntegrateProperties>;
}
/**
 *
 * @export
 * @interface BillSummaryByStudent
 */
export interface BillSummaryByStudent {
  /**
   *
   * @type {string}
   * @memberof BillSummaryByStudent
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof BillSummaryByStudent
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof BillSummaryByStudent
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof BillSummaryByStudent
   */
  alternateName: string;
  /**
   *
   * @type {Array<StudentBillingSchedules>}
   * @memberof BillSummaryByStudent
   */
  schedules: Array<StudentBillingSchedules>;
  /**
   *
   * @type {number}
   * @memberof BillSummaryByStudent
   */
  totalUnBill: number;
  /**
   *
   * @type {number}
   * @memberof BillSummaryByStudent
   */
  totalFee: number;
  /**
   *
   * @type {Array<BillingScheduleInvoice>}
   * @memberof BillSummaryByStudent
   */
  invoices: Array<BillingScheduleInvoice>;
}
/**
 *
 * @export
 * @interface BillingData
 */
export interface BillingData {
  /**
   *
   * @type {string}
   * @memberof BillingData
   */
  studentId?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BillingData
   */
  billingIds?: Array<string>;
}
/**
 *
 * @export
 * @interface BillingHistoryItem
 */
export interface BillingHistoryItem {
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  docType: string;
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  docNo: string;
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  docDate: string;
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof BillingHistoryItem
   */
  docTotal: number;
  /**
   *
   * @type {string}
   * @memberof BillingHistoryItem
   */
  docStatus: string;
  /**
   *
   * @type {boolean}
   * @memberof BillingHistoryItem
   */
  isOnlinePayment: boolean;
}
/**
 *
 * @export
 * @interface BillingSchedule
 */
export interface BillingSchedule {
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof BillingSchedule
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof BillingSchedule
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof BillingSchedule
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  enrollmentId: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  studentId: string;
  /**
   *
   * @type {number}
   * @memberof BillingSchedule
   */
  billingCount: number;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof BillingSchedule
   */
  endDate: string;
  /**
   *
   * @type {number}
   * @memberof BillingSchedule
   */
  fee: number;
  /**
   *
   * @type {BillingScheduleInvoice}
   * @memberof BillingSchedule
   */
  invoice?: BillingScheduleInvoice;
}
/**
 *
 * @export
 * @interface BillingScheduleAutoComplete
 */
export interface BillingScheduleAutoComplete {
  /**
   *
   * @type {string}
   * @memberof BillingScheduleAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof BillingScheduleAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof BillingScheduleAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface BillingScheduleInvoice
 */
export interface BillingScheduleInvoice {
  /**
   *
   * @type {string}
   * @memberof BillingScheduleInvoice
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof BillingScheduleInvoice
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof BillingScheduleInvoice
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof BillingScheduleInvoice
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface Branch
 */
export interface Branch {
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Branch
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Branch
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Branch
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  branchName: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  registrationNo: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  companyName: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  street1?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  street2?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  postcode?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  tel?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof Branch
   */
  active?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Branch
   */
  offdays?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  workStart: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  workEnd: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  invoiceRemark?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  refundRemark?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  paymentRemark?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  cnRemark?: string;
  /**
   *
   * @type {string}
   * @memberof Branch
   */
  imageUrl?: string;
  /**
   *
   * @type {BranchOrganization}
   * @memberof Branch
   */
  organization: BranchOrganization;
  /**
   *
   * @type {Array<BranchWorkingHours>}
   * @memberof Branch
   */
  workingHours?: Array<BranchWorkingHours>;
  /**
   *
   * @type {object}
   * @memberof Branch
   */
  more?: object;
}
/**
 *
 * @export
 * @interface BranchAutoComplete
 */
export interface BranchAutoComplete {
  /**
   *
   * @type {string}
   * @memberof BranchAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof BranchAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof BranchAutoComplete
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof BranchAutoComplete
   */
  branchId?: number;
}
/**
 *
 * @export
 * @interface BranchMinInfo
 */
export interface BranchMinInfo {
  /**
   *
   * @type {string}
   * @memberof BranchMinInfo
   */
  branchId: string;
  /**
   *
   * @type {string}
   * @memberof BranchMinInfo
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof BranchMinInfo
   */
  branchName: string;
}
/**
 *
 * @export
 * @interface BranchOrganization
 */
export interface BranchOrganization {
  /**
   *
   * @type {string}
   * @memberof BranchOrganization
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof BranchOrganization
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof BranchOrganization
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof BranchOrganization
   */
  orgId?: number;
}
/**
 *
 * @export
 * @interface BranchWorkingHours
 */
export interface BranchWorkingHours {
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  day?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  end?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof BranchWorkingHours
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface BulkGenerateInvoiceHistory
 */
export interface BulkGenerateInvoiceHistory {
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof BulkGenerateInvoiceHistory
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof BulkGenerateInvoiceHistory
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof BulkGenerateInvoiceHistory
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  actionType: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  startActionTime?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  endActionTime?: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistory
   */
  requestBody?: string;
  /**
   *
   * @type {object}
   * @memberof BulkGenerateInvoiceHistory
   */
  data?: object;
  /**
   *
   * @type {Array<BulkGenerateInvoiceHistoryDetail>}
   * @memberof BulkGenerateInvoiceHistory
   */
  invoices: Array<BulkGenerateInvoiceHistoryDetail>;
}
/**
 *
 * @export
 * @interface BulkGenerateInvoiceHistoryDetail
 */
export interface BulkGenerateInvoiceHistoryDetail {
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistoryDetail
   */
  invoiceId: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistoryDetail
   */
  invoiceNo: string;
  /**
   *
   * @type {string}
   * @memberof BulkGenerateInvoiceHistoryDetail
   */
  invoiceDate: string;
  /**
   *
   * @type {number}
   * @memberof BulkGenerateInvoiceHistoryDetail
   */
  invoiceTotal: number;
}
/**
 *
 * @export
 * @interface CategorizedMiniAppDetail
 */
export interface CategorizedMiniAppDetail {
  /**
   *
   * @type {Array<MiniAppDetail>}
   * @memberof CategorizedMiniAppDetail
   */
  upcomingMiniApps: Array<MiniAppDetail>;
  /**
   *
   * @type {Array<MiniAppDetail>}
   * @memberof CategorizedMiniAppDetail
   */
  availableMiniApps: Array<MiniAppDetail>;
}
/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {string}
   * @memberof Category
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Category
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Category
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Category
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  categoryCode?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  categoryName?: string;
  /**
   *
   * @type {boolean}
   * @memberof Category
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  categoryType?: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Category
   */
  more?: object;
}
/**
 *
 * @export
 * @interface CategoryAutoComplete
 */
export interface CategoryAutoComplete {
  /**
   *
   * @type {string}
   * @memberof CategoryAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CategoryAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CategoryAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof CategoryAutoComplete
   */
  categoryType?: string;
}
/**
 *
 * @export
 * @interface ChangePlan
 */
export interface ChangePlan {
  /**
   *
   * @type {string}
   * @memberof ChangePlan
   */
  action: string;
  /**
   *
   * @type {NewProductEnrollment}
   * @memberof ChangePlan
   */
  new?: NewProductEnrollment;
  /**
   *
   * @type {string}
   * @memberof ChangePlan
   */
  stop?: string;
  /**
   *
   * @type {string}
   * @memberof ChangePlan
   */
  alacart?: string;
  /**
   *
   * @type {NewProductEnrollment}
   * @memberof ChangePlan
   */
  remain?: NewProductEnrollment;
  /**
   *
   * @type {number}
   * @memberof ChangePlan
   */
  row?: number;
}
/**
 *
 * @export
 * @interface ClassDetails
 */
export interface ClassDetails {
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  teacherName: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  classId: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  className: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  productId: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  productCode: string;
  /**
   *
   * @type {string}
   * @memberof ClassDetails
   */
  productName: string;
  /**
   *
   * @type {number}
   * @memberof ClassDetails
   */
  numStudent: number;
}
/**
 *
 * @export
 * @interface ClassGenerateHistory
 */
export interface ClassGenerateHistory {
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  updated: string;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  fromAcademySessionId: string;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  fromAcademySessionName: string;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  toAcademySessionId: string;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  toAcademySessionName: string;
  /**
   *
   * @type {boolean}
   * @memberof ClassGenerateHistory
   */
  migrateEnrollment: boolean;
  /**
   *
   * @type {number}
   * @memberof ClassGenerateHistory
   */
  classQuantity: number;
  /**
   *
   * @type {number}
   * @memberof ClassGenerateHistory
   */
  enrollmentQuantity: number;
  /**
   *
   * @type {string}
   * @memberof ClassGenerateHistory
   */
  status: string;
}
/**
 *
 * @export
 * @interface ClassSubTotalSummaries
 */
export interface ClassSubTotalSummaries {
  /**
   *
   * @type {number}
   * @memberof ClassSubTotalSummaries
   */
  studentQty?: number;
  /**
   *
   * @type {number}
   * @memberof ClassSubTotalSummaries
   */
  totalHour?: number;
  /**
   *
   * @type {number}
   * @memberof ClassSubTotalSummaries
   */
  totalTeachHour?: number;
  /**
   *
   * @type {number}
   * @memberof ClassSubTotalSummaries
   */
  totalFee?: number;
  /**
   *
   * @type {number}
   * @memberof ClassSubTotalSummaries
   */
  commission?: number;
}
/**
 *
 * @export
 * @interface CloseTuitionClassesRegistration
 */
export interface CloseTuitionClassesRegistration {
  /**
   *
   * @type {Array<string>}
   * @memberof CloseTuitionClassesRegistration
   */
  tuitionClassIds: Array<string>;
}
/**
 *
 * @export
 * @interface CodeLabelValue
 */
export interface CodeLabelValue {
  /**
   *
   * @type {string}
   * @memberof CodeLabelValue
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CodeLabelValue
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CodeLabelValue
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof CodeLabelValue
   */
  value: number;
}
/**
 *
 * @export
 * @interface CommissionClassLevel
 */
export interface CommissionClassLevel {
  /**
   *
   * @type {string}
   * @memberof CommissionClassLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CommissionClassLevel
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CommissionClassLevel
   */
  code?: string;
}
/**
 *
 * @export
 * @interface CommissionLevel
 */
export interface CommissionLevel {
  /**
   *
   * @type {Array<CommissionClassLevel>}
   * @memberof CommissionLevel
   */
  levels?: Array<CommissionClassLevel>;
  /**
   *
   * @type {Array<CommissionRate>}
   * @memberof CommissionLevel
   */
  rates?: Array<CommissionRate>;
}
/**
 *
 * @export
 * @interface CommissionRate
 */
export interface CommissionRate {
  /**
   *
   * @type {number}
   * @memberof CommissionRate
   */
  minStudent?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionRate
   */
  maxStudent?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionRate
   */
  hourlyAmount?: number;
}
/**
 *
 * @export
 * @interface CommissionResponseData
 */
export interface CommissionResponseData {
  /**
   *
   * @type {Array<InChargeCommissions>}
   * @memberof CommissionResponseData
   */
  inChargeCommission?: Array<InChargeCommissions>;
  /**
   *
   * @type {ClassSubTotalSummaries}
   * @memberof CommissionResponseData
   */
  inChargeSummary?: ClassSubTotalSummaries;
  /**
   *
   * @type {Array<InChargeCommissions>}
   * @memberof CommissionResponseData
   */
  replacementCommission?: Array<InChargeCommissions>;
  /**
   *
   * @type {ClassSubTotalSummaries}
   * @memberof CommissionResponseData
   */
  replaceSummary?: ClassSubTotalSummaries;
  /**
   *
   * @type {CommissionSummaries}
   * @memberof CommissionResponseData
   */
  summary?: CommissionSummaries;
  /**
   *
   * @type {string}
   * @memberof CommissionResponseData
   */
  errorMessage?: string;
}
/**
 *
 * @export
 * @interface CommissionSummaries
 */
export interface CommissionSummaries {
  /**
   *
   * @type {string}
   * @memberof CommissionSummaries
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof CommissionSummaries
   */
  teacherName: string;
  /**
   *
   * @type {string}
   * @memberof CommissionSummaries
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof CommissionSummaries
   */
  salaryMode: string;
  /**
   *
   * @type {number}
   * @memberof CommissionSummaries
   */
  defaultRate?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionSummaries
   */
  defaultCommissionPercent?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionSummaries
   */
  totalCommissionPercent?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionSummaries
   */
  totalHourlyCommission?: number;
  /**
   *
   * @type {number}
   * @memberof CommissionSummaries
   */
  totalInFinal?: number;
}
/**
 *
 * @export
 * @interface CreditNote
 */
export interface CreditNote {
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof CreditNote
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof CreditNote
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof CreditNote
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  cnNo?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  cnDate: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  cnTitle?: string;
  /**
   *
   * @type {number}
   * @memberof CreditNote
   */
  cnTotal: number;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNote
   */
  documentStatus?: string;
  /**
   *
   * @type {CreditNoteStudent}
   * @memberof CreditNote
   */
  student: CreditNoteStudent;
  /**
   *
   * @type {CreditNotePreparedBy}
   * @memberof CreditNote
   */
  preparedBy?: CreditNotePreparedBy;
  /**
   *
   * @type {CreditNoteNotified}
   * @memberof CreditNote
   */
  notified?: CreditNoteNotified;
  /**
   *
   * @type {CreditNoteAgent}
   * @memberof CreditNote
   */
  agent?: CreditNoteAgent;
  /**
   *
   * @type {CreditNoteParent}
   * @memberof CreditNote
   */
  parent?: CreditNoteParent;
  /**
   *
   * @type {Array<CreditNoteInvoices>}
   * @memberof CreditNote
   */
  invoices: Array<CreditNoteInvoices>;
  /**
   *
   * @type {Array<CreditNoteIntegrateSystem>}
   * @memberof CreditNote
   */
  integrateSystem?: Array<CreditNoteIntegrateSystem>;
  /**
   *
   * @type {CreditNoteDocNoFormat}
   * @memberof CreditNote
   */
  docNoFormat?: CreditNoteDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof CreditNote
   */
  more?: object;
}
/**
 *
 * @export
 * @interface CreditNoteAgent
 */
export interface CreditNoteAgent {
  /**
   *
   * @type {string}
   * @memberof CreditNoteAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CreditNoteAutoComplete
 */
export interface CreditNoteAutoComplete {
  /**
   *
   * @type {string}
   * @memberof CreditNoteAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface CreditNoteDocNoFormat
 */
export interface CreditNoteDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof CreditNoteDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CreditNoteIntegrateSystem
 */
export interface CreditNoteIntegrateSystem {
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  appId?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  documentStatus?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteIntegrateSystem
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface CreditNoteInvoices
 */
export interface CreditNoteInvoices {
  /**
   *
   * @type {number}
   * @memberof CreditNoteInvoices
   */
  balance: number;
  /**
   *
   * @type {number}
   * @memberof CreditNoteInvoices
   */
  knockOffAmt: number;
  /**
   *
   * @type {number}
   * @memberof CreditNoteInvoices
   */
  newBalance: number;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoices
   */
  _id?: string;
  /**
   *
   * @type {CreditNoteInvoicesInvoice}
   * @memberof CreditNoteInvoices
   */
  invoice: CreditNoteInvoicesInvoice;
}
/**
 *
 * @export
 * @interface CreditNoteInvoicesInvoice
 */
export interface CreditNoteInvoicesInvoice {
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoicesInvoice
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoicesInvoice
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoicesInvoice
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteInvoicesInvoice
   */
  invoiceDate?: string;
}
/**
 *
 * @export
 * @interface CreditNoteNotified
 */
export interface CreditNoteNotified {
  /**
   *
   * @type {boolean}
   * @memberof CreditNoteNotified
   */
  sent?: boolean;
  /**
   *
   * @type {string}
   * @memberof CreditNoteNotified
   */
  date?: string;
}
/**
 *
 * @export
 * @interface CreditNoteParent
 */
export interface CreditNoteParent {
  /**
   *
   * @type {string}
   * @memberof CreditNoteParent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteParent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteParent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CreditNotePreparedBy
 */
export interface CreditNotePreparedBy {
  /**
   *
   * @type {string}
   * @memberof CreditNotePreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNotePreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNotePreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface CreditNoteStudent
 */
export interface CreditNoteStudent {
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudent
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudent
   */
  code?: string;
  /**
   *
   * @type {CreditNoteStudentAgent}
   * @memberof CreditNoteStudent
   */
  agent?: CreditNoteStudentAgent;
  /**
   *
   * @type {CreditNoteStudentLevel}
   * @memberof CreditNoteStudent
   */
  level?: CreditNoteStudentLevel;
  /**
   *
   * @type {CreditNoteStudentStudentGroup}
   * @memberof CreditNoteStudent
   */
  studentGroup?: CreditNoteStudentStudentGroup;
}
/**
 *
 * @export
 * @interface CreditNoteStudentAgent
 */
export interface CreditNoteStudentAgent {
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CreditNoteStudentLevel
 */
export interface CreditNoteStudentLevel {
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CreditNoteStudentStudentGroup
 */
export interface CreditNoteStudentStudentGroup {
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CreditNoteStudentStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface CustomField
 */
export interface CustomField {
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof CustomField
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof CustomField
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof CustomField
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof CustomField
   */
  collectionName?: string;
  /**
   *
   * @type {CustomFieldForm}
   * @memberof CustomField
   */
  form?: CustomFieldForm;
  /**
   *
   * @type {CustomFieldList}
   * @memberof CustomField
   */
  list?: CustomFieldList;
}
/**
 *
 * @export
 * @interface CustomFieldAutoComplete
 */
export interface CustomFieldAutoComplete {
  /**
   *
   * @type {string}
   * @memberof CustomFieldAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CustomFieldAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CustomFieldAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface CustomFieldForm
 */
export interface CustomFieldForm {
  /**
   *
   * @type {object}
   * @memberof CustomFieldForm
   */
  jsonSchema?: object;
}
/**
 *
 * @export
 * @interface CustomFieldList
 */
export interface CustomFieldList {
  /**
   *
   * @type {Array<string>}
   * @memberof CustomFieldList
   */
  fields?: Array<string>;
}
/**
 *
 * @export
 * @interface CustomizePrintFormat
 */
export interface CustomizePrintFormat {
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof CustomizePrintFormat
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof CustomizePrintFormat
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof CustomizePrintFormat
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  jrxml?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  formatId?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  formatTitle?: string;
  /**
   *
   * @type {boolean}
   * @memberof CustomizePrintFormat
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormat
   */
  description?: string;
}
/**
 *
 * @export
 * @interface CustomizePrintFormatAutoComplete
 */
export interface CustomizePrintFormatAutoComplete {
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormatAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormatAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof CustomizePrintFormatAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface DailyAttendance
 */
export interface DailyAttendance {
  /**
   *
   * @type {string}
   * @memberof DailyAttendance
   */
  day: string;
  /**
   *
   * @type {string}
   * @memberof DailyAttendance
   */
  previous: string;
  /**
   *
   * @type {string}
   * @memberof DailyAttendance
   */
  current: string;
  /**
   *
   * @type {number}
   * @memberof DailyAttendance
   */
  absent: number;
  /**
   *
   * @type {number}
   * @memberof DailyAttendance
   */
  attendanceRate: number;
  /**
   *
   * @type {number}
   * @memberof DailyAttendance
   */
  attendanceRatePrevious: number;
}
/**
 *
 * @export
 * @interface Data
 */
export interface Data {
  /**
   *
   * @type {string}
   * @memberof Data
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof Data
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof Data
   */
  documentDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Data
   */
  documentStatus?: Array<string>;
  /**
   *
   * @type {EInvoiceStatus}
   * @memberof Data
   */
  eInvoiceStatus?: EInvoiceStatus;
}
/**
 *
 * @export
 * @interface DateRangeFilter
 */
export interface DateRangeFilter {
  /**
   *
   * @type {string}
   * @memberof DateRangeFilter
   */
  dateFrom: string;
  /**
   *
   * @type {string}
   * @memberof DateRangeFilter
   */
  dateTo: string;
}
/**
 *
 * @export
 * @interface DeveloperPortalInstalledXOrgsResponse
 */
export interface DeveloperPortalInstalledXOrgsResponse {
  /**
   *
   * @type {string}
   * @memberof DeveloperPortalInstalledXOrgsResponse
   */
  demoXOrg: string;
  /**
   *
   * @type {Array<DeveloperPortalInstalledXOrgsResponseInstalledXOrg>}
   * @memberof DeveloperPortalInstalledXOrgsResponse
   */
  installedXOrgs: Array<DeveloperPortalInstalledXOrgsResponseInstalledXOrg>;
}
/**
 *
 * @export
 * @interface DeveloperPortalInstalledXOrgsResponseInstalledXOrg
 */
export interface DeveloperPortalInstalledXOrgsResponseInstalledXOrg {
  /**
   *
   * @type {string}
   * @memberof DeveloperPortalInstalledXOrgsResponseInstalledXOrg
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof DeveloperPortalInstalledXOrgsResponseInstalledXOrg
   */
  branchName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DeveloperPortalInstalledXOrgsResponseInstalledXOrg
   */
  xOrg: Array<string>;
}
/**
 *
 * @export
 * @interface DocumentEventListItem
 */
export interface DocumentEventListItem {
  /**
   *
   * @type {string}
   * @memberof DocumentEventListItem
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentEventListItem
   */
  eventType?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentEventListItem
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentEventListItem
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentEventListItem
   */
  fullName?: string;
  /**
   *
   * @type {object}
   * @memberof DocumentEventListItem
   */
  eventData?: object;
}
/**
 *
 * @export
 * @interface DocumentNoFormat
 */
export interface DocumentNoFormat {
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof DocumentNoFormat
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof DocumentNoFormat
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof DocumentNoFormat
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  docNoFormatNo?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  docNoFormatName?: string;
  /**
   *
   * @type {boolean}
   * @memberof DocumentNoFormat
   */
  active?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DocumentNoFormat
   */
  default?: boolean;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  docNoType?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormat
   */
  docNoPattern?: string;
  /**
   *
   * @type {number}
   * @memberof DocumentNoFormat
   */
  nextNumber?: number;
  /**
   *
   * @type {DocumentNoFormatBranch}
   * @memberof DocumentNoFormat
   */
  branch?: DocumentNoFormatBranch;
}
/**
 *
 * @export
 * @interface DocumentNoFormatAutoComplete
 */
export interface DocumentNoFormatAutoComplete {
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormatAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormatAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormatAutoComplete
   */
  label: string;
  /**
   *
   * @type {boolean}
   * @memberof DocumentNoFormatAutoComplete
   */
  default?: boolean;
}
/**
 *
 * @export
 * @interface DocumentNoFormatBranch
 */
export interface DocumentNoFormatBranch {
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormatBranch
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof DocumentNoFormatBranch
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof DocumentNoFormatBranch
   */
  branchId?: number;
}
/**
 *
 * @export
 * @interface EInvoiceStatus
 */
export interface EInvoiceStatus {
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  longId?: string;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  sessionId?: string;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  submissionType?: string;
  /**
   *
   * @type {Array<Error>}
   * @memberof EInvoiceStatus
   */
  error?: Array<Error>;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  issueTime?: string;
  /**
   *
   * @type {string}
   * @memberof EInvoiceStatus
   */
  excludeReason?: string;
}
/**
 *
 * @export
 * @interface EinvoiceCancelRequest
 */
export interface EinvoiceCancelRequest {
  /**
   *
   * @type {string}
   * @memberof EinvoiceCancelRequest
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceCancelRequest
   */
  documentType: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceCancelRequest
   */
  reason: string;
}
/**
 *
 * @export
 * @interface EinvoiceDashboardDataList
 */
export interface EinvoiceDashboardDataList {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EinvoiceDashboardDataList
   */
  documentType: { [key: string]: string };
}
/**
 *
 * @export
 * @interface EinvoiceDashboardDocList
 */
export interface EinvoiceDashboardDocList {
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  documentDate?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  businessPartnerId?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  businessPartnerName?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardDocList
   */
  totalAmount?: string;
}
/**
 *
 * @export
 * @interface EinvoiceDashboardSync
 */
export interface EinvoiceDashboardSync {
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardSync
   */
  document_type: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardSync
   */
  document_id: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceDashboardSync
   */
  document_date?: string;
}
/**
 *
 * @export
 * @interface EinvoiceRecordSummary
 */
export interface EinvoiceRecordSummary {
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordSummary
   */
  ts?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordSummary
   */
  elapsed?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordSummary
   */
  restStatus?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordSummary
   */
  status?: string;
  /**
   *
   * @type {number}
   * @memberof EinvoiceRecordSummary
   */
  totalRecords?: number;
  /**
   *
   * @type {Data}
   * @memberof EinvoiceRecordSummary
   */
  data?: Data;
}
/**
 *
 * @export
 * @interface EinvoiceRecordURLResponse
 */
export interface EinvoiceRecordURLResponse {
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  longId?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  issueTime?: string;
  /**
   *
   * @type {string}
   * @memberof EinvoiceRecordURLResponse
   */
  submissionType?: string;
}
/**
 *
 * @export
 * @interface Enrollment
 */
export interface Enrollment {
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Enrollment
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Enrollment
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Enrollment
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  enrollmentNo?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  enrollmentTitle?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  academySessionClassGeneratorId?: string;
  /**
   *
   * @type {number}
   * @memberof Enrollment
   */
  fee: number;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  billingMethod: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  categoryType: string;
  /**
   *
   * @type {number}
   * @memberof Enrollment
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  endDate?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  planReturnDate?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  restartDate?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  stopDescription?: string;
  /**
   *
   * @type {string}
   * @memberof Enrollment
   */
  description?: string;
  /**
   *
   * @type {EnrollmentProduct}
   * @memberof Enrollment
   */
  product: EnrollmentProduct;
  /**
   *
   * @type {EnrollmentPackage}
   * @memberof Enrollment
   */
  package?: EnrollmentPackage;
  /**
   *
   * @type {EnrollmentTuitionClass}
   * @memberof Enrollment
   */
  tuitionClass?: EnrollmentTuitionClass;
  /**
   *
   * @type {EnrollmentStudent}
   * @memberof Enrollment
   */
  student: EnrollmentStudent;
  /**
   *
   * @type {EnrollmentLevel}
   * @memberof Enrollment
   */
  level: EnrollmentLevel;
  /**
   *
   * @type {EnrollmentStopReason}
   * @memberof Enrollment
   */
  stopReason?: EnrollmentStopReason;
  /**
   *
   * @type {EnrollmentDocNoFormat}
   * @memberof Enrollment
   */
  docNoFormat?: EnrollmentDocNoFormat;
}
/**
 *
 * @export
 * @interface EnrollmentAutoComplete
 */
export interface EnrollmentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof EnrollmentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface EnrollmentDocNoFormat
 */
export interface EnrollmentDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof EnrollmentDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface EnrollmentItem
 */
export interface EnrollmentItem {
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  enrollmentBillingId?: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  product: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  tuitionClass: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  package: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  level: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  category: ForeignKey;
  /**
   *
   * @type {number}
   * @memberof EnrollmentItem
   */
  fee: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  categoryType: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  endDate: string;
  /**
   *
   * @type {Array<BillingSchedule>}
   * @memberof EnrollmentItem
   */
  billings: Array<BillingSchedule>;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  billingMethod: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentItem
   */
  lessonsPerTerm: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentItem
   */
  description: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentItem
   */
  teacher: ForeignKey;
  /**
   *
   * @type {boolean}
   * @memberof EnrollmentItem
   */
  selected: boolean;
}
/**
 *
 * @export
 * @interface EnrollmentLevel
 */
export interface EnrollmentLevel {
  /**
   *
   * @type {string}
   * @memberof EnrollmentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface EnrollmentPackage
 */
export interface EnrollmentPackage {
  /**
   *
   * @type {string}
   * @memberof EnrollmentPackage
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentPackage
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentPackage
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentPackage
   */
  amount?: number;
  /**
   *
   * @type {number}
   * @memberof EnrollmentPackage
   */
  itemRow?: number;
}
/**
 *
 * @export
 * @interface EnrollmentProduct
 */
export interface EnrollmentProduct {
  /**
   *
   * @type {string}
   * @memberof EnrollmentProduct
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentProduct
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {number}
   * @memberof EnrollmentProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentProduct
   */
  categoryType?: string;
}
/**
 *
 * @export
 * @interface EnrollmentSchedules
 */
export interface EnrollmentSchedules {
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedules
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedules
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedules
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  enrollmentNo?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  enrollmentTitle?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  academySessionClassGeneratorId?: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedules
   */
  fee: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  billingMethod: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  categoryType: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedules
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  endDate?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  planReturnDate?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  restartDate?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  stopDescription?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedules
   */
  description?: string;
  /**
   *
   * @type {EnrollmentProduct}
   * @memberof EnrollmentSchedules
   */
  product: EnrollmentProduct;
  /**
   *
   * @type {EnrollmentPackage}
   * @memberof EnrollmentSchedules
   */
  package?: EnrollmentPackage;
  /**
   *
   * @type {EnrollmentTuitionClass}
   * @memberof EnrollmentSchedules
   */
  tuitionClass?: EnrollmentTuitionClass;
  /**
   *
   * @type {EnrollmentStudent}
   * @memberof EnrollmentSchedules
   */
  student: EnrollmentStudent;
  /**
   *
   * @type {EnrollmentLevel}
   * @memberof EnrollmentSchedules
   */
  level: EnrollmentLevel;
  /**
   *
   * @type {EnrollmentStopReason}
   * @memberof EnrollmentSchedules
   */
  stopReason?: EnrollmentStopReason;
  /**
   *
   * @type {EnrollmentDocNoFormat}
   * @memberof EnrollmentSchedules
   */
  docNoFormat?: EnrollmentDocNoFormat;
  /**
   *
   * @type {Array<BillingSchedule>}
   * @memberof EnrollmentSchedules
   */
  billings: Array<BillingSchedule>;
  /**
   *
   * @type {Array<EnrollmentSchedulesAttendance>}
   * @memberof EnrollmentSchedules
   */
  schedules: Array<EnrollmentSchedulesAttendance>;
}
/**
 *
 * @export
 * @interface EnrollmentSchedulesAttendance
 */
export interface EnrollmentSchedulesAttendance {
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  scheduleId: string;
  /**
   *
   * @type {boolean}
   * @memberof EnrollmentSchedulesAttendance
   */
  attend: boolean;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  billingId: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  status: string;
  /**
   *
   * @type {ScheduleAttendanceReplacement}
   * @memberof EnrollmentSchedulesAttendance
   */
  replacement: ScheduleAttendanceReplacement;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  endTime: string;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedulesAttendance
   */
  termNo: number;
  /**
   *
   * @type {number}
   * @memberof EnrollmentSchedulesAttendance
   */
  scheduleNo: number;
  /**
   *
   * @type {boolean}
   * @memberof EnrollmentSchedulesAttendance
   */
  active: boolean;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentSchedulesAttendance
   */
  teacher: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof EnrollmentSchedulesAttendance
   */
  room: ForeignKey;
  /**
   *
   * @type {string}
   * @memberof EnrollmentSchedulesAttendance
   */
  description: string;
}
/**
 *
 * @export
 * @interface EnrollmentStopReason
 */
export interface EnrollmentStopReason {
  /**
   *
   * @type {string}
   * @memberof EnrollmentStopReason
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStopReason
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStopReason
   */
  label?: string;
}
/**
 *
 * @export
 * @interface EnrollmentStudent
 */
export interface EnrollmentStudent {
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudent
   */
  label?: string;
  /**
   *
   * @type {EnrollmentStudentLevel}
   * @memberof EnrollmentStudent
   */
  level?: EnrollmentStudentLevel;
}
/**
 *
 * @export
 * @interface EnrollmentStudentLevel
 */
export interface EnrollmentStudentLevel {
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface EnrollmentTuitionClass
 */
export interface EnrollmentTuitionClass {
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  productId?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof EnrollmentTuitionClass
   */
  endDate?: string;
}
/**
 *
 * @export
 * @interface FinalResponse
 */
export interface FinalResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof FinalResponse
   */
  success: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof FinalResponse
   */
  errors: Array<string>;
}
/**
 *
 * @export
 * @interface ForeignKey
 */
export interface ForeignKey {
  /**
   *
   * @type {string}
   * @memberof ForeignKey
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ForeignKey
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ForeignKey
   */
  label: string;
}
/**
 *
 * @export
 * @interface FrontendAsset
 */
export interface FrontendAsset {
  /**
   *
   * @type {Array<string>}
   * @memberof FrontendAsset
   */
  assets?: Array<string>;
}
/**
 *
 * @export
 * @interface GenerateBulkInvoice
 */
export interface GenerateBulkInvoice {
  /**
   *
   * @type {DateRangeFilter}
   * @memberof GenerateBulkInvoice
   */
  dateRange?: DateRangeFilter;
  /**
   *
   * @type {Array<BillingData>}
   * @memberof GenerateBulkInvoice
   */
  setting?: Array<BillingData>;
}
/**
 *
 * @export
 * @interface Holiday
 */
export interface Holiday {
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Holiday
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Holiday
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Holiday
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  holidayCode?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  holidayName?: string;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  holidayDate?: string;
  /**
   *
   * @type {boolean}
   * @memberof Holiday
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Holiday
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Holiday
   */
  more?: object;
}
/**
 *
 * @export
 * @interface HolidayAutoComplete
 */
export interface HolidayAutoComplete {
  /**
   *
   * @type {string}
   * @memberof HolidayAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof HolidayAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof HolidayAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface ImportErrorMessage
 */
export interface ImportErrorMessage {
  /**
   *
   * @type {string}
   * @memberof ImportErrorMessage
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ImportErrorMessage
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof ImportErrorMessage
   */
  message: string;
  /**
   *
   * @type {ImportErrorMessgeError}
   * @memberof ImportErrorMessage
   */
  error: ImportErrorMessgeError;
}
/**
 *
 * @export
 * @interface ImportErrorMessgeError
 */
export interface ImportErrorMessgeError {
  /**
   *
   * @type {string}
   * @memberof ImportErrorMessgeError
   */
  message: string;
}
/**
 *
 * @export
 * @interface ImportParent
 */
export interface ImportParent {
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  parentName: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  mobileNo: string;
  /**
   * support multiple, separate by \",\"
   * @type {string}
   * @memberof ImportParent
   */
  studentCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  occupation?: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  gender?: string;
  /**
   *
   * @type {number}
   * @memberof ImportParent
   */
  active?: number;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  identityNo?: string;
  /**
   *
   * @type {string}
   * @memberof ImportParent
   */
  tinNo?: string;
}
/**
 *
 * @export
 * @interface ImportProduct
 */
export interface ImportProduct {
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  productCode: string;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  productName: string;
  /**
   *
   * @type {number}
   * @memberof ImportProduct
   */
  defaultPrice: number;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  billingMethod: string;
  /**
   *
   * @type {number}
   * @memberof ImportProduct
   */
  defaultDuration?: number;
  /**
   *
   * @type {number}
   * @memberof ImportProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {number}
   * @memberof ImportProduct
   */
  active?: number;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  categoryCode: string;
  /**
   * if code not exist, will using code, label and type create new data
   * @type {string}
   * @memberof ImportProduct
   */
  categoryName?: string;
  /**
   * if code not exist, will using code, label and type create new data
   * @type {string}
   * @memberof ImportProduct
   */
  categoryType: ImportProductCategoryTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  levelCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportProduct
   */
  levelName?: string;
}

export const ImportProductCategoryTypeEnum = {
  RecurringFee: "recurringFee",
  Class: "class",
  Charge: "charge",
} as const;

export type ImportProductCategoryTypeEnum =
  (typeof ImportProductCategoryTypeEnum)[keyof typeof ImportProductCategoryTypeEnum];

/**
 *
 * @export
 * @interface ImportStudent
 */
export interface ImportStudent {
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  alternateName?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  gender: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  mobileNo?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  icNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  joinDate: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  dob: string;
  /**
   *
   * @type {number}
   * @memberof ImportStudent
   */
  active: number;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  barcode: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentGroupCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentGroupName?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentLevelCode: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentLevelName: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentRaceCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentRaceName?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentReligionCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentReligionName?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentSchoolCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentSchoolName?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressStreet1?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressStreet2?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressPostCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressCity?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressRegion?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressCountry?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressAreaCode?: string;
  /**
   *
   * @type {string}
   * @memberof ImportStudent
   */
  studentAddressAreaName?: string;
}
/**
 *
 * @export
 * @interface InChargeCommissions
 */
export interface InChargeCommissions {
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  classId?: string;
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  classCode?: string;
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  className?: string;
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  levelId?: string;
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  levelCode?: string;
  /**
   *
   * @type {string}
   * @memberof InChargeCommissions
   */
  levelLabel?: string;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  studentQty?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  duration?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  rate?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  totalHour?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  totalTeachHour?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  totalFee?: number;
  /**
   *
   * @type {number}
   * @memberof InChargeCommissions
   */
  commissionForClass?: number;
}
/**
 *
 * @export
 * @interface IndividualtoPackage
 */
export interface IndividualtoPackage {
  /**
   *
   * @type {string}
   * @memberof IndividualtoPackage
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof IndividualtoPackage
   */
  packageId: string;
  /**
   *
   * @type {string}
   * @memberof IndividualtoPackage
   */
  effectiveDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IndividualtoPackage
   */
  preferProduct: Array<string>;
}
/**
 *
 * @export
 * @interface InstalledMiniAppDetail
 */
export interface InstalledMiniAppDetail {
  /**
   *
   * @type {MiniAppDetailPermission}
   * @memberof InstalledMiniAppDetail
   */
  permissions: MiniAppDetailPermission;
  /**
   *
   * @type {Array<MiniAppDetail>}
   * @memberof InstalledMiniAppDetail
   */
  installedMiniApps: Array<MiniAppDetail>;
}
/**
 *
 * @export
 * @interface Invoice
 */
export interface Invoice {
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  generateId?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceNo?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceDate: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  invoiceTitle?: string;
  /**
   *
   * @type {number}
   * @memberof Invoice
   */
  invoiceTotal: number;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  summary?: string;
  /**
   *
   * @type {string}
   * @memberof Invoice
   */
  documentStatus?: string;
  /**
   *
   * @type {InvoicePreparedBy}
   * @memberof Invoice
   */
  preparedBy?: InvoicePreparedBy;
  /**
   *
   * @type {InvoiceStudent}
   * @memberof Invoice
   */
  student: InvoiceStudent;
  /**
   *
   * @type {InvoiceNotified}
   * @memberof Invoice
   */
  notified?: InvoiceNotified;
  /**
   *
   * @type {InvoiceAgent}
   * @memberof Invoice
   */
  agent?: InvoiceAgent;
  /**
   *
   * @type {InvoiceParent}
   * @memberof Invoice
   */
  parent?: InvoiceParent;
  /**
   *
   * @type {Array<InvoiceDetails>}
   * @memberof Invoice
   */
  details: Array<InvoiceDetails>;
  /**
   *
   * @type {Array<InvoiceIntegrateSystem>}
   * @memberof Invoice
   */
  integrateSystem?: Array<InvoiceIntegrateSystem>;
  /**
   *
   * @type {InvoiceDocNoFormat}
   * @memberof Invoice
   */
  docNoFormat?: InvoiceDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Invoice
   */
  more?: object;
}
/**
 *
 * @export
 * @interface InvoiceAgent
 */
export interface InvoiceAgent {
  /**
   *
   * @type {string}
   * @memberof InvoiceAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoiceAutoComplete
 */
export interface InvoiceAutoComplete {
  /**
   *
   * @type {string}
   * @memberof InvoiceAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceAutoComplete
   */
  invoiceDate?: string;
  /**
   *
   * @type {InvoiceStudent}
   * @memberof InvoiceAutoComplete
   */
  student?: InvoiceStudent;
  /**
   *
   * @type {InvoiceAgent}
   * @memberof InvoiceAutoComplete
   */
  agent?: InvoiceAgent;
  /**
   *
   * @type {number}
   * @memberof InvoiceAutoComplete
   */
  invoiceTotal?: number;
}
/**
 *
 * @export
 * @interface InvoiceDetails
 */
export interface InvoiceDetails {
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  enrollmentId?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  enrollmentBillingId?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetails
   */
  quantity: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetails
   */
  unitPrice: number;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetails
   */
  subTotal: number;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetails
   */
  _id?: string;
  /**
   *
   * @type {InvoiceDetailsProduct}
   * @memberof InvoiceDetails
   */
  product: InvoiceDetailsProduct;
  /**
   *
   * @type {InvoiceDetailsPackage}
   * @memberof InvoiceDetails
   */
  package?: InvoiceDetailsPackage;
}
/**
 *
 * @export
 * @interface InvoiceDetailsPackage
 */
export interface InvoiceDetailsPackage {
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsPackage
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsPackage
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsPackage
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailsPackage
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface InvoiceDetailsProduct
 */
export interface InvoiceDetailsProduct {
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProduct
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProduct
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof InvoiceDetailsProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {InvoiceDetailsProductCategory}
   * @memberof InvoiceDetailsProduct
   */
  category?: InvoiceDetailsProductCategory;
}
/**
 *
 * @export
 * @interface InvoiceDetailsProductCategory
 */
export interface InvoiceDetailsProductCategory {
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDetailsProductCategory
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoiceDocNoFormat
 */
export interface InvoiceDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof InvoiceDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoiceIntegrateSystem
 */
export interface InvoiceIntegrateSystem {
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  appId?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  documentStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceIntegrateSystem
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface InvoiceNotified
 */
export interface InvoiceNotified {
  /**
   *
   * @type {boolean}
   * @memberof InvoiceNotified
   */
  sent?: boolean;
  /**
   *
   * @type {string}
   * @memberof InvoiceNotified
   */
  date?: string;
}
/**
 *
 * @export
 * @interface InvoiceParent
 */
export interface InvoiceParent {
  /**
   *
   * @type {string}
   * @memberof InvoiceParent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceParent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceParent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoicePreparedBy
 */
export interface InvoicePreparedBy {
  /**
   *
   * @type {string}
   * @memberof InvoicePreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoicePreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof InvoicePreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface InvoiceStudent
 */
export interface InvoiceStudent {
  /**
   *
   * @type {string}
   * @memberof InvoiceStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudent
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudent
   */
  code?: string;
  /**
   *
   * @type {InvoiceStudentAgent}
   * @memberof InvoiceStudent
   */
  agent?: InvoiceStudentAgent;
  /**
   *
   * @type {InvoiceStudentLevel}
   * @memberof InvoiceStudent
   */
  level?: InvoiceStudentLevel;
  /**
   *
   * @type {InvoiceStudentStudentGroup}
   * @memberof InvoiceStudent
   */
  studentGroup?: InvoiceStudentStudentGroup;
}
/**
 *
 * @export
 * @interface InvoiceStudentAgent
 */
export interface InvoiceStudentAgent {
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoiceStudentLevel
 */
export interface InvoiceStudentLevel {
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface InvoiceStudentStudentGroup
 */
export interface InvoiceStudentStudentGroup {
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InvoiceStudentStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
  /**
   *
   * @type {string}
   * @memberof KeyValue
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof KeyValue
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof KeyValue
   */
  id?: string;
}
/**
 *
 * @export
 * @interface KeyValuePair
 */
export interface KeyValuePair {
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof KeyValuePair
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof KeyValuePair
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof KeyValuePair
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePair
   */
  value: string;
}
/**
 *
 * @export
 * @interface KeyValuePairAutoComplete
 */
export interface KeyValuePairAutoComplete {
  /**
   *
   * @type {string}
   * @memberof KeyValuePairAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePairAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof KeyValuePairAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Level
 */
export interface Level {
  /**
   *
   * @type {string}
   * @memberof Level
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Level
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  levelCode?: string;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  levelName?: string;
  /**
   *
   * @type {boolean}
   * @memberof Level
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Level
   */
  description?: string;
  /**
   *
   * @type {LevelNextLevel}
   * @memberof Level
   */
  nextLevel?: LevelNextLevel;
  /**
   *
   * @type {object}
   * @memberof Level
   */
  more?: object;
}
/**
 *
 * @export
 * @interface LevelAutoComplete
 */
export interface LevelAutoComplete {
  /**
   *
   * @type {string}
   * @memberof LevelAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof LevelAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof LevelAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface LevelNextLevel
 */
export interface LevelNextLevel {
  /**
   *
   * @type {string}
   * @memberof LevelNextLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof LevelNextLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof LevelNextLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface LevelWithRelation
 */
export interface LevelWithRelation {
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof LevelWithRelation
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof LevelWithRelation
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof LevelWithRelation
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  levelCode?: string;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  levelName?: string;
  /**
   *
   * @type {boolean}
   * @memberof LevelWithRelation
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof LevelWithRelation
   */
  description?: string;
  /**
   *
   * @type {LevelNextLevel}
   * @memberof LevelWithRelation
   */
  nextLevel?: LevelNextLevel;
  /**
   *
   * @type {object}
   * @memberof LevelWithRelation
   */
  more?: object;
  /**
   *
   * @type {Array<Product>}
   * @memberof LevelWithRelation
   */
  _product?: Array<Product> | null;
  /**
   *
   * @type {Array<Student>}
   * @memberof LevelWithRelation
   */
  _student?: Array<Student> | null;
}
/**
 *
 * @export
 * @interface MicroFrontendAssetsResponse
 */
export interface MicroFrontendAssetsResponse {
  /**
   *
   * @type {FrontendAsset}
   * @memberof MicroFrontendAssetsResponse
   */
  data?: FrontendAsset;
  /**
   *
   * @type {string}
   * @memberof MicroFrontendAssetsResponse
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof MicroFrontendAssetsResponse
   */
  implementationDate?: string;
}
/**
 *
 * @export
 * @interface MiniApp
 */
export interface MiniApp {
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof MiniApp
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniApp
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniApp
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  env: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  logo: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  website?: string;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof MiniApp
   */
  pricing: number;
  /**
   *
   * @type {string}
   * @memberof MiniApp
   */
  status: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniApp
   */
  tags?: Array<string>;
  /**
   *
   * @type {MiniAppAuthor}
   * @memberof MiniApp
   */
  author: MiniAppAuthor;
  /**
   *
   * @type {MiniAppAccess}
   * @memberof MiniApp
   */
  access: MiniAppAccess;
  /**
   *
   * @type {MiniAppDevelopment}
   * @memberof MiniApp
   */
  development?: MiniAppDevelopment;
  /**
   *
   * @type {MiniAppDeveloperPortal}
   * @memberof MiniApp
   */
  developerPortal: MiniAppDeveloperPortal;
  /**
   *
   * @type {MiniAppIntro}
   * @memberof MiniApp
   */
  intro: MiniAppIntro;
  /**
   *
   * @type {MiniAppIntegration}
   * @memberof MiniApp
   */
  integration: MiniAppIntegration;
}
/**
 *
 * @export
 * @interface MiniAppAccess
 */
export interface MiniAppAccess {
  /**
   *
   * @type {string}
   * @memberof MiniAppAccess
   */
  visibility: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppAccess
   */
  allowEmails?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppAccess
   */
  requiredPlans: Array<string>;
}
/**
 *
 * @export
 * @interface MiniAppAuthor
 */
export interface MiniAppAuthor {
  /**
   *
   * @type {string}
   * @memberof MiniAppAuthor
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppAuthor
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppAuthor
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppAuthor
   */
  team?: string;
}
/**
 *
 * @export
 * @interface MiniAppAutoComplete
 */
export interface MiniAppAutoComplete {
  /**
   *
   * @type {string}
   * @memberof MiniAppAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface MiniAppDetail
 */
export interface MiniAppDetail {
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof MiniAppDetail
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniAppDetail
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniAppDetail
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  env: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  logo: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  website?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof MiniAppDetail
   */
  pricing: number;
  /**
   *
   * @type {string}
   * @memberof MiniAppDetail
   */
  status: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppDetail
   */
  tags?: Array<string>;
  /**
   *
   * @type {MiniAppAuthor}
   * @memberof MiniAppDetail
   */
  author: MiniAppAuthor;
  /**
   *
   * @type {MiniAppAccess}
   * @memberof MiniAppDetail
   */
  access: MiniAppAccess;
  /**
   *
   * @type {MiniAppDevelopment}
   * @memberof MiniAppDetail
   */
  development?: MiniAppDevelopment;
  /**
   *
   * @type {MiniAppDeveloperPortal}
   * @memberof MiniAppDetail
   */
  developerPortal: MiniAppDeveloperPortal;
  /**
   *
   * @type {MiniAppIntro}
   * @memberof MiniAppDetail
   */
  intro: MiniAppIntro;
  /**
   *
   * @type {MiniAppIntegration}
   * @memberof MiniAppDetail
   */
  integration: MiniAppIntegration;
  /**
   *
   * @type {MiniAppInstallation}
   * @memberof MiniAppDetail
   */
  miniAppInstallation?: MiniAppInstallation;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppDetail
   */
  hasRequiredPlan: boolean;
}
/**
 *
 * @export
 * @interface MiniAppDetailPermission
 */
export interface MiniAppDetailPermission {
  /**
   *
   * @type {boolean}
   * @memberof MiniAppDetailPermission
   */
  hasMiniAppFeature: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppDetailPermission
   */
  canInstall: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppDetailPermission
   */
  canUninstall: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppDetailPermission
   */
  canUpdateSetting: boolean;
}
/**
 *
 * @export
 * @interface MiniAppDeveloperPortal
 */
export interface MiniAppDeveloperPortal {
  /**
   *
   * @type {string}
   * @memberof MiniAppDeveloperPortal
   */
  appId: string;
}
/**
 *
 * @export
 * @interface MiniAppDevelopment
 */
export interface MiniAppDevelopment {
  /**
   *
   * @type {string}
   * @memberof MiniAppDevelopment
   */
  demoXOrg?: string;
}
/**
 *
 * @export
 * @interface MiniAppInstallation
 */
export interface MiniAppInstallation {
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof MiniAppInstallation
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniAppInstallation
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof MiniAppInstallation
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallation
   */
  apiKey: string;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppInstallation
   */
  isActive: boolean;
  /**
   *
   * @type {number}
   * @memberof MiniAppInstallation
   */
  seqNo?: number;
  /**
   *
   * @type {MiniAppInstallationMiniApp}
   * @memberof MiniAppInstallation
   */
  miniApp: MiniAppInstallationMiniApp;
  /**
   *
   * @type {MiniAppInstallationMiniApiUser}
   * @memberof MiniAppInstallation
   */
  miniApiUser?: MiniAppInstallationMiniApiUser;
  /**
   *
   * @type {object}
   * @memberof MiniAppInstallation
   */
  settings: object;
}
/**
 *
 * @export
 * @interface MiniAppInstallationAutoComplete
 */
export interface MiniAppInstallationAutoComplete {
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface MiniAppInstallationMiniApiUser
 */
export interface MiniAppInstallationMiniApiUser {
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApiUser
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApiUser
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApiUser
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApiUser
   */
  email?: string;
}
/**
 *
 * @export
 * @interface MiniAppInstallationMiniApp
 */
export interface MiniAppInstallationMiniApp {
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApp
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApp
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApp
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApp
   */
  env?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppInstallationMiniApp
   */
  developerPortalAppId?: string;
}
/**
 *
 * @export
 * @interface MiniAppIntegration
 */
export interface MiniAppIntegration {
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppIntegration
   */
  scopes?: Array<string>;
  /**
   *
   * @type {MiniAppIntegrationEnabled}
   * @memberof MiniAppIntegration
   */
  enabled: MiniAppIntegrationEnabled;
  /**
   *
   * @type {MiniAppIntegrationCustomField}
   * @memberof MiniAppIntegration
   */
  customField?: MiniAppIntegrationCustomField;
  /**
   *
   * @type {MiniAppIntegrationCustomPage}
   * @memberof MiniAppIntegration
   */
  customPage?: MiniAppIntegrationCustomPage;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomField
 */
export interface MiniAppIntegrationCustomField {
  /**
   *
   * @type {Array<MiniAppIntegrationCustomFieldFields>}
   * @memberof MiniAppIntegrationCustomField
   */
  fields: Array<MiniAppIntegrationCustomFieldFields>;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomFieldFields
 */
export interface MiniAppIntegrationCustomFieldFields {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  _id?: string;
  /**
   *
   * @type {object}
   * @memberof MiniAppIntegrationCustomFieldFields
   */
  jsonSchema: object;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomPage
 */
export interface MiniAppIntegrationCustomPage {
  /**
   *
   * @type {Array<MiniAppIntegrationCustomPagePages>}
   * @memberof MiniAppIntegrationCustomPage
   */
  pages: Array<MiniAppIntegrationCustomPagePages>;
  /**
   *
   * @type {MiniAppIntegrationCustomPageSetting}
   * @memberof MiniAppIntegrationCustomPage
   */
  setting?: MiniAppIntegrationCustomPageSetting;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomPagePages
 */
export interface MiniAppIntegrationCustomPagePages {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  iconType: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  icon?: string;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  isHideOnMenu?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  requiredPermissions: Array<string>;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  _id?: string;
  /**
   *
   * @type {MiniAppIntegrationCustomPagePagesSources}
   * @memberof MiniAppIntegrationCustomPagePages
   */
  sources: MiniAppIntegrationCustomPagePagesSources;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomPagePagesSources
 */
export interface MiniAppIntegrationCustomPagePagesSources {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePagesSources
   */
  development: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPagePagesSources
   */
  production: string;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationCustomPageSetting
 */
export interface MiniAppIntegrationCustomPageSetting {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntegrationCustomPageSetting
   */
  note?: string;
  /**
   *
   * @type {object}
   * @memberof MiniAppIntegrationCustomPageSetting
   */
  jsonSchema: object;
}
/**
 *
 * @export
 * @interface MiniAppIntegrationEnabled
 */
export interface MiniAppIntegrationEnabled {
  /**
   *
   * @type {boolean}
   * @memberof MiniAppIntegrationEnabled
   */
  miniApi: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppIntegrationEnabled
   */
  customField: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MiniAppIntegrationEnabled
   */
  customPage: boolean;
}
/**
 *
 * @export
 * @interface MiniAppIntro
 */
export interface MiniAppIntro {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntro
   */
  description: string;
  /**
   *
   * @type {Array<string>}
   * @memberof MiniAppIntro
   */
  previewImages: Array<string>;
  /**
   *
   * @type {Array<MiniAppIntroFeatures>}
   * @memberof MiniAppIntro
   */
  features: Array<MiniAppIntroFeatures>;
}
/**
 *
 * @export
 * @interface MiniAppIntroFeatures
 */
export interface MiniAppIntroFeatures {
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof MiniAppIntroFeatures
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface MobileAppMessage
 */
export interface MobileAppMessage {
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof MobileAppMessage
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof MobileAppMessage
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof MobileAppMessage
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  messageType?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  messageTitle?: string;
  /**
   *
   * @type {boolean}
   * @memberof MobileAppMessage
   */
  read?: boolean;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessage
   */
  body?: string;
  /**
   *
   * @type {MobileAppMessageStudent}
   * @memberof MobileAppMessage
   */
  student?: MobileAppMessageStudent;
}
/**
 *
 * @export
 * @interface MobileAppMessageAutoComplete
 */
export interface MobileAppMessageAutoComplete {
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface MobileAppMessageStudent
 */
export interface MobileAppMessageStudent {
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageStudent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppMessageStudent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface MobileAppUser
 */
export interface MobileAppUser {
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUser
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof MobileAppUser
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof MobileAppUser
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof MobileAppUser
   */
  branchId?: number;
  /**
   *
   * @type {Array<MobileAppUserTokens>}
   * @memberof MobileAppUser
   */
  tokens?: Array<MobileAppUserTokens>;
}
/**
 *
 * @export
 * @interface MobileAppUserAutoComplete
 */
export interface MobileAppUserAutoComplete {
  /**
   *
   * @type {string}
   * @memberof MobileAppUserAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface MobileAppUserTokens
 */
export interface MobileAppUserTokens {
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  messagingToken?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof MobileAppUserTokens
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  target?: string;
}
/**
 *
 * @export
 * @interface Modification
 */
export interface Modification {
  /**
   *
   * @type {string}
   * @memberof Modification
   */
  action: string;
  /**
   *
   * @type {NewProductEnrollment}
   * @memberof Modification
   */
  new?: NewProductEnrollment;
  /**
   *
   * @type {string}
   * @memberof Modification
   */
  deleteEnrolId?: string;
}
/**
 *
 * @export
 * @interface NewProductEnrollment
 */
export interface NewProductEnrollment {
  /**
   *
   * @type {EnrollmentProduct}
   * @memberof NewProductEnrollment
   */
  product: EnrollmentProduct;
  /**
   *
   * @type {ForeignKey}
   * @memberof NewProductEnrollment
   */
  package?: ForeignKey;
  /**
   *
   * @type {EnrollmentTuitionClass}
   * @memberof NewProductEnrollment
   */
  tuitionClass?: EnrollmentTuitionClass;
  /**
   *
   * @type {number}
   * @memberof NewProductEnrollment
   */
  fee: number;
  /**
   *
   * @type {number}
   * @memberof NewProductEnrollment
   */
  lessonsPerTerm: number;
  /**
   *
   * @type {string}
   * @memberof NewProductEnrollment
   */
  categoryType: string;
  /**
   *
   * @type {string}
   * @memberof NewProductEnrollment
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof NewProductEnrollment
   */
  endDate: string;
  /**
   *
   * @type {string}
   * @memberof NewProductEnrollment
   */
  description: string;
}
/**
 *
 * @export
 * @interface OnlineMonitoringData
 */
export interface OnlineMonitoringData {
  /**
   * Online Payment id
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  paymentGatewayName: string;
  /**
   * Online Payment No. (Auto generate if empty.)
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  onlinePaymentNo: string;
  /**
   * Gateway date
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  paymentGatewayDate?: string;
  /**
   * Gateway response date
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  paymentGatewayResponseDate?: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  paymentGatewayTransNo: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  status: OnlineMonitoringDataStatusEnum;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  receiptNo: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  receiptDate: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  receiptStatus: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  studentName: string;
  /**
   * online payment amount
   * @type {number}
   * @memberof OnlineMonitoringData
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof OnlineMonitoringData
   */
  studentId: string;
  /**
   *
   * @type {RequestOnlinePaymentParent}
   * @memberof OnlineMonitoringData
   */
  parent: RequestOnlinePaymentParent;
  /**
   *
   * @type {Array<RequestOnlinePaymentInvoice>}
   * @memberof OnlineMonitoringData
   */
  invoices: Array<RequestOnlinePaymentInvoice>;
}

export const OnlineMonitoringDataStatusEnum = {
  New: "new",
  PaymentPending: "payment_pending",
  PaymentSuccess: "payment_success",
  PaymentFailed: "payment_failed",
  ReceiptFailed: "receipt_failed",
  Complete: "complete",
} as const;

export type OnlineMonitoringDataStatusEnum =
  (typeof OnlineMonitoringDataStatusEnum)[keyof typeof OnlineMonitoringDataStatusEnum];

/**
 *
 * @export
 * @interface OnlinePaymentData
 */
export interface OnlinePaymentData {
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  _id: string;
  /**
   * Online Payment No.
   * @type {string}
   * @memberof OnlinePaymentData
   */
  onlinePaymentNo: string;
  /**
   * Online Payment Date Time
   * @type {string}
   * @memberof OnlinePaymentData
   */
  datetime: string;
  /**
   * Payer\'s email
   * @type {string}
   * @memberof OnlinePaymentData
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  amount: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  redirectURL?: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  status: OnlinePaymentDataStatusEnum;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentData
   */
  failReason?: string | null;
  /**
   *
   * @type {OnlinePaymentPaymentGateway}
   * @memberof OnlinePaymentData
   */
  paymentGateway: OnlinePaymentPaymentGateway;
}

export const OnlinePaymentDataStatusEnum = {
  New: "new",
  PaymentPending: "payment_pending",
  PaymentSuccess: "payment_success",
  PaymentFailed: "payment_failed",
  ReceiptFailed: "receipt_failed",
  Complete: "complete",
} as const;

export type OnlinePaymentDataStatusEnum =
  (typeof OnlinePaymentDataStatusEnum)[keyof typeof OnlinePaymentDataStatusEnum];

/**
 *
 * @export
 * @interface OnlinePaymentFilter
 */
export interface OnlinePaymentFilter {
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentFilter
   */
  dateFrom: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentFilter
   */
  dateTo: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentFilter
   */
  status?: string;
  /**
   * Array of student IDs
   * @type {Array<string>}
   * @memberof OnlinePaymentFilter
   */
  studentIdArr?: Array<string>;
}
/**
 *
 * @export
 * @interface OnlinePaymentPaymentGateway
 */
export interface OnlinePaymentPaymentGateway {
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentPaymentGateway
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentPaymentGateway
   */
  html: string;
  /**
   *
   * @type {object}
   * @memberof OnlinePaymentPaymentGateway
   */
  data?: object;
}
/**
 *
 * @export
 * @interface OnlinePaymentValidateData
 */
export interface OnlinePaymentValidateData {
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  _id: string;
  /**
   * Online Payment No. (Auto generate if empty.)
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  onlinePaymentNo: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  status: OnlinePaymentValidateDataStatusEnum;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  failReason?: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  receiptId?: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  receiptNo?: string;
  /**
   *
   * @type {string}
   * @memberof OnlinePaymentValidateData
   */
  receiptDate?: string;
}

export const OnlinePaymentValidateDataStatusEnum = {
  New: "new",
  PaymentPending: "payment_pending",
  PaymentSuccess: "payment_success",
  PaymentFailed: "payment_failed",
  ReceiptFailed: "receipt_failed",
  Complete: "complete",
} as const;

export type OnlinePaymentValidateDataStatusEnum =
  (typeof OnlinePaymentValidateDataStatusEnum)[keyof typeof OnlinePaymentValidateDataStatusEnum];

/**
 *
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Organization
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Organization
   */
  orgId: number;
  /**
   *
   * @type {number}
   * @memberof Organization
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  orgCode: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  orgName: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  registrationNo?: string;
  /**
   *
   * @type {boolean}
   * @memberof Organization
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  timeZone?: string;
  /**
   *
   * @type {number}
   * @memberof Organization
   */
  offsetMinute?: number;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Organization
   */
  imageUrl?: string;
  /**
   *
   * @type {object}
   * @memberof Organization
   */
  more?: object;
}
/**
 *
 * @export
 * @interface OrganizationAutoComplete
 */
export interface OrganizationAutoComplete {
  /**
   *
   * @type {string}
   * @memberof OrganizationAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof OrganizationAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof OrganizationAutoComplete
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof OrganizationAutoComplete
   */
  orgId?: number;
}
/**
 *
 * @export
 * @interface OutstandingByStudent
 */
export interface OutstandingByStudent {
  /**
   *
   * @type {string}
   * @memberof OutstandingByStudent
   */
  _id: string;
  /**
   *
   * @type {InvoiceStudent}
   * @memberof OutstandingByStudent
   */
  student: InvoiceStudent;
  /**
   *
   * @type {ForeignKey}
   * @memberof OutstandingByStudent
   */
  level: ForeignKey;
  /**
   *
   * @type {number}
   * @memberof OutstandingByStudent
   */
  totalAmt: number;
  /**
   *
   * @type {Array<OutstandingByStudentInvoice>}
   * @memberof OutstandingByStudent
   */
  invoices: Array<OutstandingByStudentInvoice>;
}
/**
 *
 * @export
 * @interface OutstandingByStudentInvoice
 */
export interface OutstandingByStudentInvoice {
  /**
   *
   * @type {string}
   * @memberof OutstandingByStudentInvoice
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingByStudentInvoice
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingByStudentInvoice
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingByStudentInvoice
   */
  date: string;
  /**
   *
   * @type {number}
   * @memberof OutstandingByStudentInvoice
   */
  amount: number;
}
/**
 *
 * @export
 * @interface OutstandingInvoice
 */
export interface OutstandingInvoice {
  /**
   *
   * @type {string}
   * @memberof OutstandingInvoice
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingInvoice
   */
  invoiceNo: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingInvoice
   */
  invoiceDate: string;
  /**
   *
   * @type {number}
   * @memberof OutstandingInvoice
   */
  invoiceTotal: number;
  /**
   *
   * @type {string}
   * @memberof OutstandingInvoice
   */
  invoiceTitle: string;
  /**
   *
   * @type {string}
   * @memberof OutstandingInvoice
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof OutstandingInvoice
   */
  balance: number;
  /**
   *
   * @type {boolean}
   * @memberof OutstandingInvoice
   */
  selected: boolean;
  /**
   *
   * @type {number}
   * @memberof OutstandingInvoice
   */
  knockOffAmt: number;
  /**
   *
   * @type {number}
   * @memberof OutstandingInvoice
   */
  newBalance: number;
}
/**
 *
 * @export
 * @interface OutstandingSetting
 */
export interface OutstandingSetting {
  /**
   *
   * @type {boolean}
   * @memberof OutstandingSetting
   */
  enable: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof OutstandingSetting
   */
  cron: Array<string>;
}
/**
 *
 * @export
 * @interface OutstandingSettingResponse
 */
export interface OutstandingSettingResponse {
  /**
   *
   * @type {boolean}
   * @memberof OutstandingSettingResponse
   */
  enable: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof OutstandingSettingResponse
   */
  cron: Array<string>;
}
/**
 *
 * @export
 * @interface PackageChanged
 */
export interface PackageChanged {
  /**
   *
   * @type {string}
   * @memberof PackageChanged
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof PackageChanged
   */
  previouspackageId: string;
  /**
   *
   * @type {string}
   * @memberof PackageChanged
   */
  newpackageId: string;
  /**
   *
   * @type {Array<ChangePlan>}
   * @memberof PackageChanged
   */
  changePlan: Array<ChangePlan>;
  /**
   *
   * @type {ForeignKey}
   * @memberof PackageChanged
   */
  stopReason?: ForeignKey;
  /**
   *
   * @type {string}
   * @memberof PackageChanged
   */
  effectiveDate?: string;
}
/**
 *
 * @export
 * @interface PackageEnrollToIndividual
 */
export interface PackageEnrollToIndividual {
  /**
   *
   * @type {string}
   * @memberof PackageEnrollToIndividual
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof PackageEnrollToIndividual
   */
  packageId: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof PackageEnrollToIndividual
   */
  stopReason: ForeignKey;
  /**
   *
   * @type {string}
   * @memberof PackageEnrollToIndividual
   */
  effectiveDate: string;
}
/**
 *
 * @export
 * @interface PackageModified
 */
export interface PackageModified {
  /**
   *
   * @type {string}
   * @memberof PackageModified
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof PackageModified
   */
  packageId: string;
  /**
   *
   * @type {Array<Modification>}
   * @memberof PackageModified
   */
  modificaction: Array<Modification>;
  /**
   *
   * @type {ForeignKey}
   * @memberof PackageModified
   */
  stopReason?: ForeignKey;
  /**
   *
   * @type {string}
   * @memberof PackageModified
   */
  effectiveDate?: string;
}
/**
 *
 * @export
 * @interface Parent
 */
export interface Parent {
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Parent
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Parent
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Parent
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  occupation?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  parentName: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  mobileNo: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  identityNo?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  tinNo?: string;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  gender?: string;
  /**
   *
   * @type {boolean}
   * @memberof Parent
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Parent
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Parent
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ParentAutoComplete
 */
export interface ParentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ParentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ParentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ParentAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof ParentAutoComplete
   */
  gender?: string;
  /**
   *
   * @type {string}
   * @memberof ParentAutoComplete
   */
  mobileNo?: string;
}
/**
 *
 * @export
 * @interface ParentBranch
 */
export interface ParentBranch {
  /**
   *
   * @type {number}
   * @memberof ParentBranch
   */
  branchId: number;
  /**
   *
   * @type {number}
   * @memberof ParentBranch
   */
  orgId: number;
  /**
   *
   * @type {number}
   * @memberof ParentBranch
   */
  tenantId: number;
  /**
   *
   * @type {boolean}
   * @memberof ParentBranch
   */
  onlinePayment: boolean;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  branchName: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  orgRecordId: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  orgName: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  street1: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  street2: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  postcode: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  tel: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  parentId: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  parentName: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  xOrg: string;
  /**
   *
   * @type {number}
   * @memberof ParentBranch
   */
  totalChild: number;
  /**
   *
   * @type {number}
   * @memberof ParentBranch
   */
  totalAmount: number;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  region: string;
  /**
   * Array of offdays
   * @type {Array<string>}
   * @memberof ParentBranch
   */
  offdays: Array<ParentBranchOffdaysEnum>;
  /**
   * Array of working hours
   * @type {Array<WorkingHour>}
   * @memberof ParentBranch
   */
  workingHours?: Array<WorkingHour>;
  /**
   * The start time of work
   * @type {string}
   * @memberof ParentBranch
   */
  workStart: string;
  /**
   * The end time of work
   * @type {string}
   * @memberof ParentBranch
   */
  workEnd: string;
  /**
   *
   * @type {string}
   * @memberof ParentBranch
   */
  package: string;
  /**
   * List of students involved in the branch
   * @type {Array<ParentChild>}
   * @memberof ParentBranch
   */
  students?: Array<ParentChild>;
}

export const ParentBranchOffdaysEnum = {
  Mon: "mon",
  Tue: "tue",
  Wed: "wed",
  Thu: "thu",
  Fri: "fri",
  Sat: "sat",
  Sun: "sun",
  Empty: "",
} as const;

export type ParentBranchOffdaysEnum =
  (typeof ParentBranchOffdaysEnum)[keyof typeof ParentBranchOffdaysEnum];

/**
 *
 * @export
 * @interface ParentChild
 */
export interface ParentChild {
  /**
   * ID of the student
   * @type {string}
   * @memberof ParentChild
   */
  studentId: string;
  /**
   * Full name of the student
   * @type {string}
   * @memberof ParentChild
   */
  studentName: string;
  /**
   * Student profile image in base64 format
   * @type {string}
   * @memberof ParentChild
   */
  studentImage: string;
  /**
   *
   * @type {number}
   * @memberof ParentChild
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ParentChild
   */
  levelId?: string;
  /**
   *
   * @type {string}
   * @memberof ParentChild
   */
  levelCode?: string;
  /**
   *
   * @type {string}
   * @memberof ParentChild
   */
  levelName?: string;
}
/**
 *
 * @export
 * @interface ParentInAttendance
 */
export interface ParentInAttendance {
  /**
   *
   * @type {string}
   * @memberof ParentInAttendance
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ParentInAttendance
   */
  parentName: string;
  /**
   *
   * @type {string}
   * @memberof ParentInAttendance
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ParentInAttendance
   */
  mobileNo: string;
}
/**
 *
 * @export
 * @interface PatchManyRequest
 */
export interface PatchManyRequest {
  /**
   *
   * @type {object}
   * @memberof PatchManyRequest
   */
  data: object;
  /**
   *
   * @type {object}
   * @memberof PatchManyRequest
   */
  filter?: object;
}
/**
 *
 * @export
 * @interface Payment
 */
export interface Payment {
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  paymentNo?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  paymentDate: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  paymentDuedate?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  paymentTitle?: string;
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  paymentTotal: number;
  /**
   *
   * @type {number}
   * @memberof Payment
   */
  invoiceTotal?: number;
  /**
   *
   * @type {boolean}
   * @memberof Payment
   */
  onlinePayment?: boolean;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Payment
   */
  documentStatus?: string;
  /**
   *
   * @type {PaymentStudent}
   * @memberof Payment
   */
  student: PaymentStudent;
  /**
   *
   * @type {PaymentPreparedBy}
   * @memberof Payment
   */
  preparedBy?: PaymentPreparedBy;
  /**
   *
   * @type {PaymentNotified}
   * @memberof Payment
   */
  notified?: PaymentNotified;
  /**
   *
   * @type {PaymentAgent}
   * @memberof Payment
   */
  agent?: PaymentAgent;
  /**
   *
   * @type {PaymentParent}
   * @memberof Payment
   */
  parent?: PaymentParent;
  /**
   *
   * @type {Array<PaymentInvoices>}
   * @memberof Payment
   */
  invoices: Array<PaymentInvoices>;
  /**
   *
   * @type {Array<PaymentPaymentMethods>}
   * @memberof Payment
   */
  paymentMethods: Array<PaymentPaymentMethods>;
  /**
   *
   * @type {Array<PaymentIntegrateSystem>}
   * @memberof Payment
   */
  integrateSystem?: Array<PaymentIntegrateSystem>;
  /**
   *
   * @type {PaymentDocNoFormat}
   * @memberof Payment
   */
  docNoFormat?: PaymentDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Payment
   */
  more?: object;
}
/**
 *
 * @export
 * @interface PaymentAgent
 */
export interface PaymentAgent {
  /**
   *
   * @type {string}
   * @memberof PaymentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentAutoComplete
 */
export interface PaymentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof PaymentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof PaymentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof PaymentAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof PaymentAutoComplete
   */
  paymentDate?: string;
  /**
   *
   * @type {PaymentStudent}
   * @memberof PaymentAutoComplete
   */
  student?: PaymentStudent;
  /**
   *
   * @type {PaymentAgent}
   * @memberof PaymentAutoComplete
   */
  agent?: PaymentAgent;
  /**
   *
   * @type {number}
   * @memberof PaymentAutoComplete
   */
  paymentTotal?: number;
}
/**
 *
 * @export
 * @interface PaymentDocNoFormat
 */
export interface PaymentDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof PaymentDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentIntegrateSystem
 */
export interface PaymentIntegrateSystem {
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  appId?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  documentStatus?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentIntegrateSystem
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface PaymentInvoices
 */
export interface PaymentInvoices {
  /**
   *
   * @type {number}
   * @memberof PaymentInvoices
   */
  balance: number;
  /**
   *
   * @type {number}
   * @memberof PaymentInvoices
   */
  knockOffAmt: number;
  /**
   *
   * @type {number}
   * @memberof PaymentInvoices
   */
  newBalance: number;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoices
   */
  _id?: string;
  /**
   *
   * @type {PaymentInvoicesInvoice}
   * @memberof PaymentInvoices
   */
  invoice: PaymentInvoicesInvoice;
}
/**
 *
 * @export
 * @interface PaymentInvoicesInvoice
 */
export interface PaymentInvoicesInvoice {
  /**
   *
   * @type {string}
   * @memberof PaymentInvoicesInvoice
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoicesInvoice
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoicesInvoice
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInvoicesInvoice
   */
  invoiceDate?: string;
}
/**
 *
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof PaymentMethod
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof PaymentMethod
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof PaymentMethod
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  paymentMethodCode: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  paymentMethodName: string;
  /**
   *
   * @type {boolean}
   * @memberof PaymentMethod
   */
  onlinePayment?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PaymentMethod
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof PaymentMethod
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof PaymentMethod
   */
  more?: object;
}
/**
 *
 * @export
 * @interface PaymentMethodAutoComplete
 */
export interface PaymentMethodAutoComplete {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface PaymentNotified
 */
export interface PaymentNotified {
  /**
   *
   * @type {boolean}
   * @memberof PaymentNotified
   */
  sent?: boolean;
  /**
   *
   * @type {string}
   * @memberof PaymentNotified
   */
  date?: string;
}
/**
 *
 * @export
 * @interface PaymentParent
 */
export interface PaymentParent {
  /**
   *
   * @type {string}
   * @memberof PaymentParent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentParent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentParent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentPaymentMethods
 */
export interface PaymentPaymentMethods {
  /**
   *
   * @type {number}
   * @memberof PaymentPaymentMethods
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  transNo?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethods
   */
  _id?: string;
  /**
   *
   * @type {PaymentPaymentMethodsPaymentMethod}
   * @memberof PaymentPaymentMethods
   */
  paymentMethod: PaymentPaymentMethodsPaymentMethod;
}
/**
 *
 * @export
 * @interface PaymentPaymentMethodsPaymentMethod
 */
export interface PaymentPaymentMethodsPaymentMethod {
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethodsPaymentMethod
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethodsPaymentMethod
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPaymentMethodsPaymentMethod
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentPreparedBy
 */
export interface PaymentPreparedBy {
  /**
   *
   * @type {string}
   * @memberof PaymentPreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentPreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface PaymentStudent
 */
export interface PaymentStudent {
  /**
   *
   * @type {string}
   * @memberof PaymentStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudent
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudent
   */
  code?: string;
  /**
   *
   * @type {PaymentStudentAgent}
   * @memberof PaymentStudent
   */
  agent?: PaymentStudentAgent;
  /**
   *
   * @type {PaymentStudentLevel}
   * @memberof PaymentStudent
   */
  level?: PaymentStudentLevel;
  /**
   *
   * @type {PaymentStudentStudentGroup}
   * @memberof PaymentStudent
   */
  studentGroup?: PaymentStudentStudentGroup;
}
/**
 *
 * @export
 * @interface PaymentStudentAgent
 */
export interface PaymentStudentAgent {
  /**
   *
   * @type {string}
   * @memberof PaymentStudentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentStudentLevel
 */
export interface PaymentStudentLevel {
  /**
   *
   * @type {string}
   * @memberof PaymentStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface PaymentStudentStudentGroup
 */
export interface PaymentStudentStudentGroup {
  /**
   *
   * @type {string}
   * @memberof PaymentStudentStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentStudentStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Permission
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Permission
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Permission
   */
  branchId?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Permission
   */
  groups?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface PermissionAutoComplete
 */
export interface PermissionAutoComplete {
  /**
   *
   * @type {string}
   * @memberof PermissionAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof PermissionAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof PermissionAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface PrintAttendanceFilter
 */
export interface PrintAttendanceFilter {
  /**
   *
   * @type {Array<string>}
   * @memberof PrintAttendanceFilter
   */
  tuitionClassIds: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PrintAttendanceFilter
   */
  dateFrom: string;
  /**
   *
   * @type {string}
   * @memberof PrintAttendanceFilter
   */
  dateTo: string;
  /**
   *
   * @type {number}
   * @memberof PrintAttendanceFilter
   */
  columns: number;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
  /**
   *
   * @type {string}
   * @memberof Product
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  productCode: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  productName: string;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  categoryType?: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  defaultPrice: number;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  billingMethod: string;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  defaultDuration?: number;
  /**
   *
   * @type {number}
   * @memberof Product
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {boolean}
   * @memberof Product
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Product
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Product
   */
  tags?: Array<string>;
  /**
   *
   * @type {ProductCategory}
   * @memberof Product
   */
  category: ProductCategory;
  /**
   *
   * @type {ProductLevel}
   * @memberof Product
   */
  level?: ProductLevel;
  /**
   *
   * @type {object}
   * @memberof Product
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ProductAutoComplete
 */
export interface ProductAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ProductAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ProductAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ProductAutoComplete
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof ProductAutoComplete
   */
  defaultPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductAutoComplete
   */
  categoryType?: string;
  /**
   *
   * @type {ProductLevel}
   * @memberof ProductAutoComplete
   */
  level?: ProductLevel;
  /**
   *
   * @type {number}
   * @memberof ProductAutoComplete
   */
  defaultDuration?: number;
  /**
   *
   * @type {number}
   * @memberof ProductAutoComplete
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof ProductAutoComplete
   */
  billingMethod?: string;
  /**
   *
   * @type {ProductCategory}
   * @memberof ProductAutoComplete
   */
  category?: ProductCategory;
}
/**
 *
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ProductCategory
   */
  categoryType?: string;
}
/**
 *
 * @export
 * @interface ProductLevel
 */
export interface ProductLevel {
  /**
   *
   * @type {string}
   * @memberof ProductLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackage
 */
export interface ProductPackage {
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackage
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackage
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackage
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  packageCode: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  packageName: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  packageType: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  packageMethod?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProductPackage
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProductPackage
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackage
   */
  amount: number;
  /**
   *
   * @type {ProductPackageLevel}
   * @memberof ProductPackage
   */
  level: ProductPackageLevel;
  /**
   *
   * @type {ProductPackageSubjectQuantitySettings}
   * @memberof ProductPackage
   */
  subjectQuantitySettings?: ProductPackageSubjectQuantitySettings;
  /**
   *
   * @type {Array<ProductPackageProducts>}
   * @memberof ProductPackage
   */
  products?: Array<ProductPackageProducts>;
  /**
   *
   * @type {object}
   * @memberof ProductPackage
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ProductPackageAutoComplete
 */
export interface ProductPackageAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ProductPackageAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageAutoComplete
   */
  packageType?: string;
  /**
   *
   * @type {ProductPackageLevel}
   * @memberof ProductPackageAutoComplete
   */
  level?: ProductPackageLevel;
  /**
   *
   * @type {number}
   * @memberof ProductPackageAutoComplete
   */
  amount?: number;
  /**
   *
   * @type {Array<ProductPackageProducts>}
   * @memberof ProductPackageAutoComplete
   */
  products?: Array<ProductPackageProducts>;
}
/**
 *
 * @export
 * @interface ProductPackageLevel
 */
export interface ProductPackageLevel {
  /**
   *
   * @type {string}
   * @memberof ProductPackageLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageProducts
 */
export interface ProductPackageProducts {
  /**
   *
   * @type {number}
   * @memberof ProductPackageProducts
   */
  quantity?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProducts
   */
  unitPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProducts
   */
  subTotal?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProducts
   */
  _id?: string;
  /**
   *
   * @type {ProductPackageProductsProduct}
   * @memberof ProductPackageProducts
   */
  product?: ProductPackageProductsProduct;
  /**
   *
   * @type {Array<ProductPackageProductsAvailableItems>}
   * @memberof ProductPackageProducts
   */
  availableItems?: Array<ProductPackageProductsAvailableItems>;
}
/**
 *
 * @export
 * @interface ProductPackageProductsAvailableItems
 */
export interface ProductPackageProductsAvailableItems {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItems
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItems
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItems
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItems
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItems
   */
  _id?: string;
  /**
   *
   * @type {ProductPackageProductsAvailableItemsProduct}
   * @memberof ProductPackageProductsAvailableItems
   */
  product?: ProductPackageProductsAvailableItemsProduct;
}
/**
 *
 * @export
 * @interface ProductPackageProductsAvailableItemsProduct
 */
export interface ProductPackageProductsAvailableItemsProduct {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  categoryType?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  defaultDuration?: number;
  /**
   *
   * @type {ProductPackageProductsAvailableItemsProductCategory}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  category?: ProductPackageProductsAvailableItemsProductCategory;
  /**
   *
   * @type {ProductPackageProductsAvailableItemsProductLevel}
   * @memberof ProductPackageProductsAvailableItemsProduct
   */
  level?: ProductPackageProductsAvailableItemsProductLevel;
}
/**
 *
 * @export
 * @interface ProductPackageProductsAvailableItemsProductCategory
 */
export interface ProductPackageProductsAvailableItemsProductCategory {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductCategory
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageProductsAvailableItemsProductLevel
 */
export interface ProductPackageProductsAvailableItemsProductLevel {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsAvailableItemsProductLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageProductsProduct
 */
export interface ProductPackageProductsProduct {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProduct
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProduct
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProduct
   */
  categoryType?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackageProductsProduct
   */
  defaultDuration?: number;
  /**
   *
   * @type {ProductPackageProductsProductCategory}
   * @memberof ProductPackageProductsProduct
   */
  category?: ProductPackageProductsProductCategory;
  /**
   *
   * @type {ProductPackageProductsProductLevel}
   * @memberof ProductPackageProductsProduct
   */
  level?: ProductPackageProductsProductLevel;
}
/**
 *
 * @export
 * @interface ProductPackageProductsProductCategory
 */
export interface ProductPackageProductsProductCategory {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductCategory
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageProductsProductLevel
 */
export interface ProductPackageProductsProductLevel {
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageProductsProductLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettings
 */
export interface ProductPackageSubjectQuantitySettings {
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettings
   */
  totalAvailableItems?: number;
  /**
   *
   * @type {Array<ProductPackageSubjectQuantitySettingsAvailableItems>}
   * @memberof ProductPackageSubjectQuantitySettings
   */
  availableItems?: Array<ProductPackageSubjectQuantitySettingsAvailableItems>;
  /**
   *
   * @type {Array<ProductPackageSubjectQuantitySettingsPriceTier>}
   * @memberof ProductPackageSubjectQuantitySettings
   */
  priceTier?: Array<ProductPackageSubjectQuantitySettingsPriceTier>;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettingsAvailableItems
 */
export interface ProductPackageSubjectQuantitySettingsAvailableItems {
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  _id?: string;
  /**
   *
   * @type {ProductPackageSubjectQuantitySettingsAvailableItemsProduct}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItems
   */
  product?: ProductPackageSubjectQuantitySettingsAvailableItemsProduct;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettingsAvailableItemsProduct
 */
export interface ProductPackageSubjectQuantitySettingsAvailableItemsProduct {
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  categoryType?: string;
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  defaultDuration?: number;
  /**
   *
   * @type {ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  category?: ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory;
  /**
   *
   * @type {ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProduct
   */
  level?: ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory
 */
export interface ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory {
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductCategory
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel
 */
export interface ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel {
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsAvailableItemsProductLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ProductPackageSubjectQuantitySettingsPriceTier
 */
export interface ProductPackageSubjectQuantitySettingsPriceTier {
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  subjectCount?: number;
  /**
   *
   * @type {number}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  totalPrice?: number;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ProductPackageSubjectQuantitySettingsPriceTier
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface ProfileUserBranch
 */
export interface ProfileUserBranch {
  /**
   *
   * @type {string}
   * @memberof ProfileUserBranch
   */
  permissionId: string;
  /**
   *
   * @type {number}
   * @memberof ProfileUserBranch
   */
  tenantId: number;
  /**
   *
   * @type {number}
   * @memberof ProfileUserBranch
   */
  orgId: number;
  /**
   *
   * @type {number}
   * @memberof ProfileUserBranch
   */
  branchId: number;
  /**
   * List of user\'s group
   * @type {Array<string>}
   * @memberof ProfileUserBranch
   */
  groups: Array<string>;
  /**
   *
   * @type {BranchMinInfo}
   * @memberof ProfileUserBranch
   */
  branch: BranchMinInfo;
  /**
   *
   * @type {string}
   * @memberof ProfileUserBranch
   */
  orgRecordId: string;
  /**
   *
   * @type {string}
   * @memberof ProfileUserBranch
   */
  xOrg: string;
}
/**
 *
 * @export
 * @interface ProfileUserInvites
 */
export interface ProfileUserInvites {
  /**
   *
   * @type {string}
   * @memberof ProfileUserInvites
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ProfileUserInvites
   */
  created: string;
  /**
   *
   * @type {number}
   * @memberof ProfileUserInvites
   */
  tenantId: number;
  /**
   *
   * @type {string}
   * @memberof ProfileUserInvites
   */
  tenantName: string;
}
/**
 *
 * @export
 * @interface PunchCard
 */
export interface PunchCard {
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof PunchCard
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof PunchCard
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof PunchCard
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof PunchCard
   */
  datetime?: string;
  /**
   *
   * @type {object}
   * @memberof PunchCard
   */
  more?: object;
  /**
   *
   * @type {PunchCardTeacher}
   * @memberof PunchCard
   */
  teacher: PunchCardTeacher;
}
/**
 *
 * @export
 * @interface PunchCardAutoComplete
 */
export interface PunchCardAutoComplete {
  /**
   *
   * @type {string}
   * @memberof PunchCardAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof PunchCardAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof PunchCardAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface PunchCardTeacher
 */
export interface PunchCardTeacher {
  /**
   *
   * @type {string}
   * @memberof PunchCardTeacher
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCardTeacher
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof PunchCardTeacher
   */
  label?: string;
}
/**
 *
 * @export
 * @interface QueueJob
 */
export interface QueueJob {
  /**
   *
   * @type {string}
   * @memberof QueueJob
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof QueueJob
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof QueueJob
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof QueueJob
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof QueueJob
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof QueueJob
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof QueueJob
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof QueueJob
   */
  branchId?: number;
  /**
   *
   * @type {QueueJobJob}
   * @memberof QueueJob
   */
  job: QueueJobJob;
  /**
   *
   * @type {object}
   * @memberof QueueJob
   */
  payload?: object;
  /**
   *
   * @type {object}
   * @memberof QueueJob
   */
  result?: object;
  /**
   *
   * @type {QueueJobError}
   * @memberof QueueJob
   */
  error?: QueueJobError;
}
/**
 *
 * @export
 * @interface QueueJobAutoComplete
 */
export interface QueueJobAutoComplete {
  /**
   *
   * @type {string}
   * @memberof QueueJobAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface QueueJobError
 */
export interface QueueJobError {
  /**
   *
   * @type {number}
   * @memberof QueueJobError
   */
  status?: number;
  /**
   *
   * @type {string}
   * @memberof QueueJobError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobError
   */
  message?: string;
}
/**
 *
 * @export
 * @interface QueueJobJob
 */
export interface QueueJobJob {
  /**
   *
   * @type {string}
   * @memberof QueueJobJob
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobJob
   */
  processor: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobJob
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobJob
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobJob
   */
  title?: string;
}
/**
 *
 * @export
 * @interface QueueJobProducerResponse
 */
export interface QueueJobProducerResponse {
  /**
   *
   * @type {string}
   * @memberof QueueJobProducerResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobProducerResponse
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof QueueJobProducerResponse
   */
  processor: string;
}
/**
 *
 * @export
 * @interface Race
 */
export interface Race {
  /**
   *
   * @type {string}
   * @memberof Race
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Race
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Race
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Race
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  raceCode?: string;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  raceName?: string;
  /**
   *
   * @type {boolean}
   * @memberof Race
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Race
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Race
   */
  more?: object;
}
/**
 *
 * @export
 * @interface RaceAutoComplete
 */
export interface RaceAutoComplete {
  /**
   *
   * @type {string}
   * @memberof RaceAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RaceAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RaceAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Refund
 */
export interface Refund {
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Refund
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Refund
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Refund
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  refundNo?: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  refundDate: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  refundTitle?: string;
  /**
   *
   * @type {number}
   * @memberof Refund
   */
  refundTotal: number;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Refund
   */
  documentStatus?: string;
  /**
   *
   * @type {RefundStudent}
   * @memberof Refund
   */
  student: RefundStudent;
  /**
   *
   * @type {RefundRefundType}
   * @memberof Refund
   */
  refundType: RefundRefundType;
  /**
   *
   * @type {RefundPreparedBy}
   * @memberof Refund
   */
  preparedBy: RefundPreparedBy;
  /**
   *
   * @type {RefundNotified}
   * @memberof Refund
   */
  notified?: RefundNotified;
  /**
   *
   * @type {RefundAgent}
   * @memberof Refund
   */
  agent?: RefundAgent;
  /**
   *
   * @type {RefundParent}
   * @memberof Refund
   */
  parent?: RefundParent;
  /**
   *
   * @type {RefundPayment}
   * @memberof Refund
   */
  payment: RefundPayment;
  /**
   *
   * @type {Array<RefundIntegrateSystem>}
   * @memberof Refund
   */
  integrateSystem?: Array<RefundIntegrateSystem>;
  /**
   *
   * @type {RefundDocNoFormat}
   * @memberof Refund
   */
  docNoFormat?: RefundDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Refund
   */
  more?: object;
}
/**
 *
 * @export
 * @interface RefundAgent
 */
export interface RefundAgent {
  /**
   *
   * @type {string}
   * @memberof RefundAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundAutoComplete
 */
export interface RefundAutoComplete {
  /**
   *
   * @type {string}
   * @memberof RefundAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RefundAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RefundAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof RefundAutoComplete
   */
  refundDate?: string;
  /**
   *
   * @type {RefundStudent}
   * @memberof RefundAutoComplete
   */
  student?: RefundStudent;
  /**
   *
   * @type {RefundAgent}
   * @memberof RefundAutoComplete
   */
  agent?: RefundAgent;
  /**
   *
   * @type {number}
   * @memberof RefundAutoComplete
   */
  refundTotal?: number;
}
/**
 *
 * @export
 * @interface RefundDocNoFormat
 */
export interface RefundDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof RefundDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundIntegrateSystem
 */
export interface RefundIntegrateSystem {
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  appId?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  documentNo?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  documentType?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  documentStatus?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof RefundIntegrateSystem
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface RefundNotified
 */
export interface RefundNotified {
  /**
   *
   * @type {boolean}
   * @memberof RefundNotified
   */
  sent?: boolean;
  /**
   *
   * @type {string}
   * @memberof RefundNotified
   */
  date?: string;
}
/**
 *
 * @export
 * @interface RefundParent
 */
export interface RefundParent {
  /**
   *
   * @type {string}
   * @memberof RefundParent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundParent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundParent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundPayment
 */
export interface RefundPayment {
  /**
   *
   * @type {string}
   * @memberof RefundPayment
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundPayment
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundPayment
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof RefundPayment
   */
  paymentAmount?: number;
}
/**
 *
 * @export
 * @interface RefundPreparedBy
 */
export interface RefundPreparedBy {
  /**
   *
   * @type {string}
   * @memberof RefundPreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundPreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof RefundPreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface RefundRefundType
 */
export interface RefundRefundType {
  /**
   *
   * @type {string}
   * @memberof RefundRefundType
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundRefundType
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundRefundType
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundStudent
 */
export interface RefundStudent {
  /**
   *
   * @type {string}
   * @memberof RefundStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudent
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudent
   */
  code?: string;
  /**
   *
   * @type {RefundStudentAgent}
   * @memberof RefundStudent
   */
  agent?: RefundStudentAgent;
  /**
   *
   * @type {RefundStudentLevel}
   * @memberof RefundStudent
   */
  level?: RefundStudentLevel;
  /**
   *
   * @type {RefundStudentStudentGroup}
   * @memberof RefundStudent
   */
  studentGroup?: RefundStudentStudentGroup;
}
/**
 *
 * @export
 * @interface RefundStudentAgent
 */
export interface RefundStudentAgent {
  /**
   *
   * @type {string}
   * @memberof RefundStudentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundStudentLevel
 */
export interface RefundStudentLevel {
  /**
   *
   * @type {string}
   * @memberof RefundStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundStudentStudentGroup
 */
export interface RefundStudentStudentGroup {
  /**
   *
   * @type {string}
   * @memberof RefundStudentStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RefundStudentStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RefundType
 */
export interface RefundType {
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof RefundType
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof RefundType
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof RefundType
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  typeCode: string;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  typeName: string;
  /**
   *
   * @type {boolean}
   * @memberof RefundType
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof RefundType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof RefundType
   */
  more?: object;
}
/**
 *
 * @export
 * @interface RefundTypeAutoComplete
 */
export interface RefundTypeAutoComplete {
  /**
   *
   * @type {string}
   * @memberof RefundTypeAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RefundTypeAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RefundTypeAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface RegTenant
 */
export interface RegTenant {
  /**
   *
   * @type {string}
   * @memberof RegTenant
   */
  tenantName: string;
  /**
   *
   * @type {string}
   * @memberof RegTenant
   */
  timeZone: string;
  /**
   *
   * @type {number}
   * @memberof RegTenant
   */
  utcOffset: number;
}
/**
 *
 * @export
 * @interface RegenerateTuitionClassSchedule
 */
export interface RegenerateTuitionClassSchedule {
  /**
   *
   * @type {TuitionClass}
   * @memberof RegenerateTuitionClassSchedule
   */
  data: TuitionClass;
  /**
   *
   * @type {string}
   * @memberof RegenerateTuitionClassSchedule
   */
  startDate: string;
}
/**
 *
 * @export
 * @interface Religion
 */
export interface Religion {
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Religion
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Religion
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Religion
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  religionCode?: string;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  religionName?: string;
  /**
   *
   * @type {boolean}
   * @memberof Religion
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Religion
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof Religion
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ReligionAutoComplete
 */
export interface ReligionAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ReligionAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ReligionAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ReligionAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface RequestOnlinePaymentBody
 */
export interface RequestOnlinePaymentBody {
  /**
   * Online Payment Date Time (Default now)
   * @type {string}
   * @memberof RequestOnlinePaymentBody
   */
  datetime?: string;
  /**
   * Payer\'s email
   * @type {string}
   * @memberof RequestOnlinePaymentBody
   */
  email: string;
  /**
   * Total amount to be paid
   * @type {number}
   * @memberof RequestOnlinePaymentBody
   */
  amount: number;
  /**
   * Frontend\'s redirectURL
   * @type {string}
   * @memberof RequestOnlinePaymentBody
   */
  redirectURL?: string;
  /**
   *
   * @type {RequestOnlinePaymentParent}
   * @memberof RequestOnlinePaymentBody
   */
  parent: RequestOnlinePaymentParent;
  /**
   *
   * @type {RequestOnlinePaymentStudent}
   * @memberof RequestOnlinePaymentBody
   */
  student: RequestOnlinePaymentStudent;
  /**
   *
   * @type {Array<RequestOnlinePaymentInvoice>}
   * @memberof RequestOnlinePaymentBody
   */
  invoices: Array<RequestOnlinePaymentInvoice>;
  /**
   * From which system
   * @type {string}
   * @memberof RequestOnlinePaymentBody
   */
  source?: string | null;
}
/**
 *
 * @export
 * @interface RequestOnlinePaymentInvoice
 */
export interface RequestOnlinePaymentInvoice {
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentInvoice
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentInvoice
   */
  invoiceNo: string;
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentInvoice
   */
  invoiceDate: string;
  /**
   * Invoice\'s original amount
   * @type {number}
   * @memberof RequestOnlinePaymentInvoice
   */
  amount: number;
  /**
   * Invoice\'s amount to be paid
   * @type {number}
   * @memberof RequestOnlinePaymentInvoice
   */
  knockOffAmt: number;
}
/**
 *
 * @export
 * @interface RequestOnlinePaymentParent
 */
export interface RequestOnlinePaymentParent {
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentParent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentParent
   */
  name: string;
}
/**
 *
 * @export
 * @interface RequestOnlinePaymentResponse
 */
export interface RequestOnlinePaymentResponse {
  /**
   *
   * @type {OnlinePaymentData}
   * @memberof RequestOnlinePaymentResponse
   */
  onlinePayment: OnlinePaymentData;
  /**
   *
   * @type {RequestOnlinePaymentStudent}
   * @memberof RequestOnlinePaymentResponse
   */
  student: RequestOnlinePaymentStudent;
  /**
   *
   * @type {Array<RequestOnlinePaymentInvoice>}
   * @memberof RequestOnlinePaymentResponse
   */
  invoices: Array<RequestOnlinePaymentInvoice>;
}
/**
 *
 * @export
 * @interface RequestOnlinePaymentStudent
 */
export interface RequestOnlinePaymentStudent {
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentStudent
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RequestOnlinePaymentStudent
   */
  name: string;
}
/**
 *
 * @export
 * @interface Room
 */
export interface Room {
  /**
   *
   * @type {string}
   * @memberof Room
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Room
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Room
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Room
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  roomNo: string;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  roomName: string;
  /**
   *
   * @type {number}
   * @memberof Room
   */
  capacity?: number;
  /**
   *
   * @type {boolean}
   * @memberof Room
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Room
   */
  description?: string;
  /**
   *
   * @type {RoomRoomType}
   * @memberof Room
   */
  roomType: RoomRoomType;
  /**
   *
   * @type {object}
   * @memberof Room
   */
  more?: object;
}
/**
 *
 * @export
 * @interface RoomAutoComplete
 */
export interface RoomAutoComplete {
  /**
   *
   * @type {string}
   * @memberof RoomAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RoomAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RoomAutoComplete
   */
  label: string;
  /**
   *
   * @type {number}
   * @memberof RoomAutoComplete
   */
  capacity?: number;
}
/**
 *
 * @export
 * @interface RoomRoomType
 */
export interface RoomRoomType {
  /**
   *
   * @type {string}
   * @memberof RoomRoomType
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RoomRoomType
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RoomRoomType
   */
  label?: string;
}
/**
 *
 * @export
 * @interface RoomType
 */
export interface RoomType {
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof RoomType
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof RoomType
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof RoomType
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  roomTypeNo?: string;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  roomTypeName?: string;
  /**
   *
   * @type {boolean}
   * @memberof RoomType
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof RoomType
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof RoomType
   */
  more?: object;
}
/**
 *
 * @export
 * @interface RoomTypeAutoComplete
 */
export interface RoomTypeAutoComplete {
  /**
   *
   * @type {string}
   * @memberof RoomTypeAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof RoomTypeAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof RoomTypeAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface RunGetStudentEnrollBySearchRequest
 */
export interface RunGetStudentEnrollBySearchRequest {
  /**
   *
   * @type {string}
   * @memberof RunGetStudentEnrollBySearchRequest
   */
  data?: string;
}
/**
 *
 * @export
 * @interface Schedule
 */
export interface Schedule {
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  branchId?: number;
  /**
   *
   * @type {boolean}
   * @memberof Schedule
   */
  active?: boolean;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  scheduleNo?: number;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  termNo?: number;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  lessonPlan?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  onlineClassUrl?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  endTime?: string;
  /**
   *
   * @type {number}
   * @memberof Schedule
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof Schedule
   */
  day?: string;
  /**
   *
   * @type {ScheduleTuitionClass}
   * @memberof Schedule
   */
  tuitionClass?: ScheduleTuitionClass;
  /**
   *
   * @type {ScheduleRoom}
   * @memberof Schedule
   */
  room?: ScheduleRoom;
  /**
   *
   * @type {ScheduleTeacher}
   * @memberof Schedule
   */
  teacher?: ScheduleTeacher;
  /**
   *
   * @type {object}
   * @memberof Schedule
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ScheduleAttendance
 */
export interface ScheduleAttendance {
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleAttendance
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleAttendance
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleAttendance
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  scheduleId: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  billingId: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  enrollmentId: string;
  /**
   *
   * @type {boolean}
   * @memberof ScheduleAttendance
   */
  attend?: boolean;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendance
   */
  description?: string;
  /**
   *
   * @type {ScheduleAttendanceStudent}
   * @memberof ScheduleAttendance
   */
  student: ScheduleAttendanceStudent;
  /**
   *
   * @type {ScheduleAttendanceReplacement}
   * @memberof ScheduleAttendance
   */
  replacement?: ScheduleAttendanceReplacement;
  /**
   *
   * @type {object}
   * @memberof ScheduleAttendance
   */
  more?: object;
}
/**
 *
 * @export
 * @interface ScheduleAttendanceAutoComplete
 */
export interface ScheduleAttendanceAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface ScheduleAttendanceReplacement
 */
export interface ScheduleAttendanceReplacement {
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  endTime?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  day?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  teacherName?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  roomNo?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceReplacement
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ScheduleAttendanceStudent
 */
export interface ScheduleAttendanceStudent {
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudent
   */
  label?: string;
  /**
   *
   * @type {ScheduleAttendanceStudentLevel}
   * @memberof ScheduleAttendanceStudent
   */
  level?: ScheduleAttendanceStudentLevel;
}
/**
 *
 * @export
 * @interface ScheduleAttendanceStudentLevel
 */
export interface ScheduleAttendanceStudentLevel {
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAttendanceStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ScheduleAutoComplete
 */
export interface ScheduleAutoComplete {
  /**
   *
   * @type {string}
   * @memberof ScheduleAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface ScheduleChanges
 */
export interface ScheduleChanges {
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  branchId?: number;
  /**
   *
   * @type {boolean}
   * @memberof ScheduleChanges
   */
  active?: boolean;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  scheduleNo?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  termNo?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  lessonPlan?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  onlineClassUrl?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  endTime?: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  day?: string;
  /**
   *
   * @type {ScheduleTuitionClass}
   * @memberof ScheduleChanges
   */
  tuitionClass?: ScheduleTuitionClass;
  /**
   *
   * @type {ScheduleRoom}
   * @memberof ScheduleChanges
   */
  room?: ScheduleRoom;
  /**
   *
   * @type {ScheduleTeacher}
   * @memberof ScheduleChanges
   */
  teacher?: ScheduleTeacher;
  /**
   *
   * @type {object}
   * @memberof ScheduleChanges
   */
  more?: object;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  attendQty: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleChanges
   */
  studentQty: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleChanges
   */
  pendingChangeStatus: string;
}
/**
 *
 * @export
 * @interface ScheduleListItem
 */
export interface ScheduleListItem {
  /**
   *
   * @type {string}
   * @memberof ScheduleListItem
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleListItem
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleListItem
   */
  endTime: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleListItem
   */
  day: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleListItem
   */
  duration: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleListItem
   */
  studentQuantity: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleListItem
   */
  maxStudents: number;
  /**
   *
   * @type {ForeignKey}
   * @memberof ScheduleListItem
   */
  tuitionClass: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof ScheduleListItem
   */
  teacher: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof ScheduleListItem
   */
  room: ForeignKey;
  /**
   *
   * @type {boolean}
   * @memberof ScheduleListItem
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof ScheduleListItem
   */
  description: string;
}
/**
 *
 * @export
 * @interface ScheduleRoom
 */
export interface ScheduleRoom {
  /**
   *
   * @type {string}
   * @memberof ScheduleRoom
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleRoom
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleRoom
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ScheduleTeacher
 */
export interface ScheduleTeacher {
  /**
   *
   * @type {string}
   * @memberof ScheduleTeacher
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleTeacher
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleTeacher
   */
  label?: string;
}
/**
 *
 * @export
 * @interface ScheduleTuitionClass
 */
export interface ScheduleTuitionClass {
  /**
   *
   * @type {string}
   * @memberof ScheduleTuitionClass
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleTuitionClass
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleTuitionClass
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleTuitionClass
   */
  productId?: string;
}
/**
 *
 * @export
 * @interface ScheduleWithRelation
 */
export interface ScheduleWithRelation {
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  branchId?: number;
  /**
   *
   * @type {boolean}
   * @memberof ScheduleWithRelation
   */
  active?: boolean;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  scheduleNo?: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  termNo?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  lessonPlan?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  onlineClassUrl?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  endTime?: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithRelation
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithRelation
   */
  day?: string;
  /**
   *
   * @type {ScheduleTuitionClass}
   * @memberof ScheduleWithRelation
   */
  tuitionClass?: ScheduleTuitionClass;
  /**
   *
   * @type {ScheduleRoom}
   * @memberof ScheduleWithRelation
   */
  room?: ScheduleRoom;
  /**
   *
   * @type {ScheduleTeacher}
   * @memberof ScheduleWithRelation
   */
  teacher?: ScheduleTeacher;
  /**
   *
   * @type {object}
   * @memberof ScheduleWithRelation
   */
  more?: object;
  /**
   *
   * @type {Array<TuitionClass>}
   * @memberof ScheduleWithRelation
   */
  _tuitionClass?: Array<TuitionClass> | null;
}
/**
 *
 * @export
 * @interface ScheduleWithStatistic
 */
export interface ScheduleWithStatistic {
  /**
   *
   * @type {string}
   * @memberof ScheduleWithStatistic
   */
  _id: string;
  /**
   *
   * @type {boolean}
   * @memberof ScheduleWithStatistic
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithStatistic
   */
  day: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof ScheduleWithStatistic
   */
  teacher: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof ScheduleWithStatistic
   */
  room: ForeignKey;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  termNo: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  scheduleNo: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithStatistic
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithStatistic
   */
  endTime: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  lessonPlan: number;
  /**
   *
   * @type {ScheduleTuitionClass}
   * @memberof ScheduleWithStatistic
   */
  tuitionClass: ScheduleTuitionClass;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  duration: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleWithStatistic
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  attendQty: number;
  /**
   *
   * @type {number}
   * @memberof ScheduleWithStatistic
   */
  studentQty: number;
}
/**
 *
 * @export
 * @interface School
 */
export interface School {
  /**
   *
   * @type {string}
   * @memberof School
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof School
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof School
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof School
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof School
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof School
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof School
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof School
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof School
   */
  schoolCode?: string;
  /**
   *
   * @type {string}
   * @memberof School
   */
  schoolName?: string;
  /**
   *
   * @type {boolean}
   * @memberof School
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof School
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof School
   */
  more?: object;
}
/**
 *
 * @export
 * @interface SchoolAutoComplete
 */
export interface SchoolAutoComplete {
  /**
   *
   * @type {string}
   * @memberof SchoolAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof SchoolAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof SchoolAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface SearchLevelWithRelation
 */
export interface SearchLevelWithRelation {
  /**
   *
   * @type {SearchWithRelationRelation}
   * @memberof SearchLevelWithRelation
   */
  product?: SearchWithRelationRelation;
  /**
   *
   * @type {SearchWithRelationRelation}
   * @memberof SearchLevelWithRelation
   */
  student?: SearchWithRelationRelation;
}
/**
 *
 * @export
 * @interface SearchLevelWithRelations
 */
export interface SearchLevelWithRelations {
  /**
   *
   * @type {SearchWithRelationRoot}
   * @memberof SearchLevelWithRelations
   */
  root: SearchWithRelationRoot;
  /**
   *
   * @type {SearchLevelWithRelation}
   * @memberof SearchLevelWithRelations
   */
  relations?: SearchLevelWithRelation;
}
/**
 *
 * @export
 * @interface SearchScheduleWithRelation
 */
export interface SearchScheduleWithRelation {
  /**
   *
   * @type {SearchWithRelationRelation}
   * @memberof SearchScheduleWithRelation
   */
  tuitionClass?: SearchWithRelationRelation;
}
/**
 *
 * @export
 * @interface SearchScheduleWithRelations
 */
export interface SearchScheduleWithRelations {
  /**
   *
   * @type {SearchWithRelationRoot}
   * @memberof SearchScheduleWithRelations
   */
  root: SearchWithRelationRoot;
  /**
   *
   * @type {SearchScheduleWithRelation}
   * @memberof SearchScheduleWithRelations
   */
  relations?: SearchScheduleWithRelation;
}
/**
 *
 * @export
 * @interface SearchStudent
 */
export interface SearchStudent {
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  studentImage: string;
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  studentOutstanding: string;
  /**
   *
   * @type {string}
   * @memberof SearchStudent
   */
  scanTime: string;
  /**
   *
   * @type {Array<TodayClass>}
   * @memberof SearchStudent
   */
  todayClass: Array<TodayClass>;
}
/**
 *
 * @export
 * @interface SearchWithRelationRelation
 */
export interface SearchWithRelationRelation {
  /**
   * Mongo filter for relation
   * @type {object}
   * @memberof SearchWithRelationRelation
   */
  filter?: object | null;
  /**
   * Mongo projection for relation
   * @type {object}
   * @memberof SearchWithRelationRelation
   */
  projection?: object | null;
  /**
   * Mongo sort for relation
   * @type {object}
   * @memberof SearchWithRelationRelation
   */
  sort?: object | null;
}
/**
 *
 * @export
 * @interface SearchWithRelationRoot
 */
export interface SearchWithRelationRoot {
  /**
   * Mongo filter object
   * @type {object}
   * @memberof SearchWithRelationRoot
   */
  filter?: object | null;
  /**
   * Mongo projection object
   * @type {object}
   * @memberof SearchWithRelationRoot
   */
  projection?: object | null;
  /**
   * Mongo sort object
   * @type {object}
   * @memberof SearchWithRelationRoot
   */
  sort?: object | null;
}
/**
 *
 * @export
 * @interface StopEnrollment
 */
export interface StopEnrollment {
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StopEnrollment
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StopEnrollment
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StopEnrollment
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  personIncharge: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  enrollmentId: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  date: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  planReturnDate?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollment
   */
  description?: string;
  /**
   *
   * @type {StopEnrollmentStudent}
   * @memberof StopEnrollment
   */
  student: StopEnrollmentStudent;
  /**
   *
   * @type {StopEnrollmentStopReason}
   * @memberof StopEnrollment
   */
  stopReason?: StopEnrollmentStopReason;
}
/**
 *
 * @export
 * @interface StopEnrollmentAutoComplete
 */
export interface StopEnrollmentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface StopEnrollmentStopReason
 */
export interface StopEnrollmentStopReason {
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStopReason
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStopReason
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStopReason
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StopEnrollmentStudent
 */
export interface StopEnrollmentStudent {
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudent
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudent
   */
  label?: string;
  /**
   *
   * @type {StopEnrollmentStudentLevel}
   * @memberof StopEnrollmentStudent
   */
  level?: StopEnrollmentStudentLevel;
}
/**
 *
 * @export
 * @interface StopEnrollmentStudentLevel
 */
export interface StopEnrollmentStudentLevel {
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StopEnrollmentStudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StopReason
 */
export interface StopReason {
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StopReason
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StopReason
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StopReason
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  reasonCode?: string;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  reasonName?: string;
  /**
   *
   * @type {boolean}
   * @memberof StopReason
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof StopReason
   */
  description?: string;
}
/**
 *
 * @export
 * @interface StopReasonAutoComplete
 */
export interface StopReasonAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StopReasonAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StopReasonAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StopReasonAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Student
 */
export interface Student {
  /**
   *
   * @type {string}
   * @memberof Student
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Student
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  studentCode?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  alternateName?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  gender: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  mobileNo?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  icNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  barcode?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  dob: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  joinDate?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  leaveDate?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  stopDescription?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  planReturnDate?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  recurringFeeEndDate?: string;
  /**
   *
   * @type {string}
   * @memberof Student
   */
  imageUrl?: string;
  /**
   *
   * @type {StudentStudentGroup}
   * @memberof Student
   */
  studentGroup?: StudentStudentGroup;
  /**
   *
   * @type {StudentLevel}
   * @memberof Student
   */
  level: StudentLevel;
  /**
   *
   * @type {StudentRace}
   * @memberof Student
   */
  race?: StudentRace;
  /**
   *
   * @type {StudentReligion}
   * @memberof Student
   */
  religion?: StudentReligion;
  /**
   *
   * @type {StudentSchool}
   * @memberof Student
   */
  school?: StudentSchool;
  /**
   *
   * @type {StudentAgent}
   * @memberof Student
   */
  agent?: StudentAgent;
  /**
   *
   * @type {StudentStudentSource}
   * @memberof Student
   */
  studentSource?: StudentStudentSource;
  /**
   *
   * @type {StudentAddress}
   * @memberof Student
   */
  address?: StudentAddress;
  /**
   *
   * @type {StudentArea}
   * @memberof Student
   */
  area?: StudentArea;
  /**
   *
   * @type {Array<StudentParents>}
   * @memberof Student
   */
  parents?: Array<StudentParents>;
  /**
   *
   * @type {StudentStopReason}
   * @memberof Student
   */
  stopReason?: StudentStopReason;
  /**
   *
   * @type {StudentDocNoFormat}
   * @memberof Student
   */
  docNoFormat?: StudentDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Student
   */
  more?: object;
}
/**
 *
 * @export
 * @interface StudentAddress
 */
export interface StudentAddress {
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  street1?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  street2?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  postCode?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAddress
   */
  country?: string;
}
/**
 *
 * @export
 * @interface StudentAgent
 */
export interface StudentAgent {
  /**
   *
   * @type {string}
   * @memberof StudentAgent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAgent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentAgent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentApiSchedule
 */
export interface StudentApiSchedule {
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  endTime: string;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  day?: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  tuitionClassId: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  tuitionClassCode: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  tuitionClassName: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  teacherId: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  teacherName: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  teacherGroup: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  roomId: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  roomNo: string;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  roomName: string;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  termNo: number;
  /**
   *
   * @type {string}
   * @memberof StudentApiSchedule
   */
  scheduleId: string;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  scheduleNo: number;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  scheduleCount: number;
  /**
   *
   * @type {boolean}
   * @memberof StudentApiSchedule
   */
  attend: boolean;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  totalStudent: number;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  totalAttend: number;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  totalJoin: number;
  /**
   *
   * @type {number}
   * @memberof StudentApiSchedule
   */
  totalJoinAttend: number;
}
/**
 *
 * @export
 * @interface StudentArea
 */
export interface StudentArea {
  /**
   *
   * @type {string}
   * @memberof StudentArea
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentArea
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentArea
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentAutoComplete
 */
export interface StudentAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StudentAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StudentAutoComplete
   */
  label: string;
  /**
   *
   * @type {StudentStudentGroup}
   * @memberof StudentAutoComplete
   */
  studentGroup?: StudentStudentGroup;
  /**
   *
   * @type {StudentLevel}
   * @memberof StudentAutoComplete
   */
  level?: StudentLevel;
  /**
   *
   * @type {StudentAgent}
   * @memberof StudentAutoComplete
   */
  agent?: StudentAgent;
}
/**
 *
 * @export
 * @interface StudentBillingSchedules
 */
export interface StudentBillingSchedules {
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  billingMethod: string;
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  billingId: string;
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  endDate: string;
  /**
   *
   * @type {string}
   * @memberof StudentBillingSchedules
   */
  enrollmentId: string;
  /**
   *
   * @type {number}
   * @memberof StudentBillingSchedules
   */
  fee: number;
  /**
   *
   * @type {BillingScheduleInvoice}
   * @memberof StudentBillingSchedules
   */
  invoice: BillingScheduleInvoice;
  /**
   *
   * @type {EnrollmentProduct}
   * @memberof StudentBillingSchedules
   */
  product: EnrollmentProduct;
}
/**
 *
 * @export
 * @interface StudentDescription
 */
export interface StudentDescription {
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StudentDescription
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentDescription
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentDescription
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StudentDescription
   */
  body?: string;
  /**
   *
   * @type {StudentDescriptionStudent}
   * @memberof StudentDescription
   */
  student?: StudentDescriptionStudent;
  /**
   *
   * @type {StudentDescriptionPreparedBy}
   * @memberof StudentDescription
   */
  preparedBy?: StudentDescriptionPreparedBy;
}
/**
 *
 * @export
 * @interface StudentDescriptionAutoComplete
 */
export interface StudentDescriptionAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface StudentDescriptionPreparedBy
 */
export interface StudentDescriptionPreparedBy {
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionPreparedBy
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionPreparedBy
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionPreparedBy
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface StudentDescriptionStudent
 */
export interface StudentDescriptionStudent {
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionStudent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionStudent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDescriptionStudent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentDocNoFormat
 */
export interface StudentDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof StudentDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentGroup
 */
export interface StudentGroup {
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StudentGroup
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentGroup
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentGroup
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  studentGroupCode?: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  studentGroupName?: string;
  /**
   *
   * @type {boolean}
   * @memberof StudentGroup
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof StudentGroup
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof StudentGroup
   */
  more?: object;
}
/**
 *
 * @export
 * @interface StudentGroupAutoComplete
 */
export interface StudentGroupAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StudentGroupAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroupAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StudentGroupAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface StudentLevel
 */
export interface StudentLevel {
  /**
   *
   * @type {string}
   * @memberof StudentLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentListItemWithSummary
 */
export interface StudentListItemWithSummary {
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  alternateName: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  imageUrl: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  status: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof StudentListItemWithSummary
   */
  level: ForeignKey;
  /**
   *
   * @type {ForeignKey}
   * @memberof StudentListItemWithSummary
   */
  studentGroup: ForeignKey;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof StudentListItemWithSummary
   */
  gender: string;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  documentQty: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  ledgerAmt: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  outstandingAmount?: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  totalInvoiceAmount?: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  totalInvoiceQuantity?: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  totalEnrollment?: number;
  /**
   *
   * @type {number}
   * @memberof StudentListItemWithSummary
   */
  totalActiveEnrollment?: number;
}
/**
 *
 * @export
 * @interface StudentParents
 */
export interface StudentParents {
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  parentType: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  relationship?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  description?: string;
  /**
   *
   * @type {boolean}
   * @memberof StudentParents
   */
  isDefault?: boolean;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParents
   */
  _id?: string;
  /**
   *
   * @type {StudentParentsParent}
   * @memberof StudentParents
   */
  parent: StudentParentsParent;
}
/**
 *
 * @export
 * @interface StudentParentsParent
 */
export interface StudentParentsParent {
  /**
   *
   * @type {string}
   * @memberof StudentParentsParent
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParentsParent
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentParentsParent
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentRace
 */
export interface StudentRace {
  /**
   *
   * @type {string}
   * @memberof StudentRace
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentRace
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentRace
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentReligion
 */
export interface StudentReligion {
  /**
   *
   * @type {string}
   * @memberof StudentReligion
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentReligion
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentReligion
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentSchool
 */
export interface StudentSchool {
  /**
   *
   * @type {string}
   * @memberof StudentSchool
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSchool
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSchool
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentSource
 */
export interface StudentSource {
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StudentSource
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSource
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSource
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  studentSourceCode?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  studentSourceName?: string;
  /**
   *
   * @type {boolean}
   * @memberof StudentSource
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof StudentSource
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof StudentSource
   */
  more?: object;
}
/**
 *
 * @export
 * @interface StudentSourceAutoComplete
 */
export interface StudentSourceAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StudentSourceAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentSourceAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StudentSourceAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface StudentStopReason
 */
export interface StudentStopReason {
  /**
   *
   * @type {string}
   * @memberof StudentStopReason
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStopReason
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStopReason
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentStudentGroup
 */
export interface StudentStudentGroup {
  /**
   *
   * @type {string}
   * @memberof StudentStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentStudentSource
 */
export interface StudentStudentSource {
  /**
   *
   * @type {string}
   * @memberof StudentStudentSource
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStudentSource
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof StudentStudentSource
   */
  label?: string;
}
/**
 *
 * @export
 * @interface StudentSummary
 */
export interface StudentSummary {
  /**
   *
   * @type {string}
   * @memberof StudentSummary
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummary
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummary
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummary
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummary
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  branchId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  ledgerAmt?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  salesAmt?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  documentQty?: number;
  /**
   *
   * @type {number}
   * @memberof StudentSummary
   */
  enrollmentQty?: number;
  /**
   *
   * @type {Array<StudentSummaryActiveEnrollments>}
   * @memberof StudentSummary
   */
  activeEnrollments?: Array<StudentSummaryActiveEnrollments>;
}
/**
 *
 * @export
 * @interface StudentSummaryActiveEnrollments
 */
export interface StudentSummaryActiveEnrollments {
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  enrollmentId?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  endDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryActiveEnrollments
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface StudentSummaryAutoComplete
 */
export interface StudentSummaryAutoComplete {
  /**
   *
   * @type {string}
   * @memberof StudentSummaryAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof StudentSummaryAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface StudentWithSummary
 */
export interface StudentWithSummary {
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  studentCode?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  alternateName?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  gender: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  mobileNo?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  icNumber?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  barcode?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  dob: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  joinDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  leaveDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  stopDescription?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  planReturnDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  recurringFeeEndDate?: string;
  /**
   *
   * @type {string}
   * @memberof StudentWithSummary
   */
  imageUrl?: string;
  /**
   *
   * @type {StudentStudentGroup}
   * @memberof StudentWithSummary
   */
  studentGroup?: StudentStudentGroup;
  /**
   *
   * @type {StudentLevel}
   * @memberof StudentWithSummary
   */
  level: StudentLevel;
  /**
   *
   * @type {StudentRace}
   * @memberof StudentWithSummary
   */
  race?: StudentRace;
  /**
   *
   * @type {StudentReligion}
   * @memberof StudentWithSummary
   */
  religion?: StudentReligion;
  /**
   *
   * @type {StudentSchool}
   * @memberof StudentWithSummary
   */
  school?: StudentSchool;
  /**
   *
   * @type {StudentAgent}
   * @memberof StudentWithSummary
   */
  agent?: StudentAgent;
  /**
   *
   * @type {StudentStudentSource}
   * @memberof StudentWithSummary
   */
  studentSource?: StudentStudentSource;
  /**
   *
   * @type {StudentAddress}
   * @memberof StudentWithSummary
   */
  address?: StudentAddress;
  /**
   *
   * @type {StudentArea}
   * @memberof StudentWithSummary
   */
  area?: StudentArea;
  /**
   *
   * @type {Array<StudentParents>}
   * @memberof StudentWithSummary
   */
  parents?: Array<StudentParents>;
  /**
   *
   * @type {StudentStopReason}
   * @memberof StudentWithSummary
   */
  stopReason?: StudentStopReason;
  /**
   *
   * @type {StudentDocNoFormat}
   * @memberof StudentWithSummary
   */
  docNoFormat?: StudentDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof StudentWithSummary
   */
  more?: object;
  /**
   *
   * @type {Array<Parent>}
   * @memberof StudentWithSummary
   */
  parentsInfo: Array<Parent>;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  ledgerAmt: number;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  documentQty: number;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  salesAmt: number;
  /**
   *
   * @type {number}
   * @memberof StudentWithSummary
   */
  enrollmentQty: number;
  /**
   *
   * @type {Array<StudentSummaryActiveEnrollments>}
   * @memberof StudentWithSummary
   */
  activeEnrollments: Array<StudentSummaryActiveEnrollments>;
}
/**
 *
 * @export
 * @interface SystemInboxResponse
 */
export interface SystemInboxResponse {
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  announcementNo: string;
  /**
   *
   * @type {ForeignKey}
   * @memberof SystemInboxResponse
   */
  preparedBy?: ForeignKey | null;
  /**
   *
   * @type {ForeignKey}
   * @memberof SystemInboxResponse
   */
  announcementtype?: ForeignKey | null;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  announcementDate: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  closeDate: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof SystemInboxResponse
   */
  createdBy: string;
  /**
   *
   * @type {boolean}
   * @memberof SystemInboxResponse
   */
  read?: boolean;
}
/**
 *
 * @export
 * @interface SystemIntegrateProperties
 */
export interface SystemIntegrateProperties {
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  documentNo: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  documentType: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  documentId: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  updated: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  createdBy: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  updatedBy: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  appId: string;
  /**
   *
   * @type {string}
   * @memberof SystemIntegrateProperties
   */
  documentStatus: string;
}
/**
 *
 * @export
 * @interface SystemMessage
 */
export interface SystemMessage {
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof SystemMessage
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof SystemMessage
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof SystemMessage
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  messageType?: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  messageTitle?: string;
  /**
   *
   * @type {boolean}
   * @memberof SystemMessage
   */
  read?: boolean;
  /**
   *
   * @type {string}
   * @memberof SystemMessage
   */
  body?: string;
}
/**
 *
 * @export
 * @interface SystemMessageAutoComplete
 */
export interface SystemMessageAutoComplete {
  /**
   *
   * @type {string}
   * @memberof SystemMessageAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessageAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof SystemMessageAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface Teacher
 */
export interface Teacher {
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Teacher
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Teacher
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Teacher
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  teacherCode: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  teacherName: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  alternateName?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  mobileNo: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  email: string;
  /**
   *
   * @type {boolean}
   * @memberof Teacher
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Teacher
   */
  imageUrl?: string;
  /**
   *
   * @type {TeacherTeacherGroup}
   * @memberof Teacher
   */
  teacherGroup: TeacherTeacherGroup;
  /**
   *
   * @type {Array<TeacherBranches>}
   * @memberof Teacher
   */
  branches: Array<TeacherBranches>;
  /**
   *
   * @type {TeacherCommissionSetting}
   * @memberof Teacher
   */
  commissionSetting?: TeacherCommissionSetting;
  /**
   *
   * @type {TeacherDocNoFormat}
   * @memberof Teacher
   */
  docNoFormat?: TeacherDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof Teacher
   */
  more?: object;
}
/**
 *
 * @export
 * @interface TeacherAutoComplete
 */
export interface TeacherAutoComplete {
  /**
   *
   * @type {string}
   * @memberof TeacherAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TeacherAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof TeacherAutoComplete
   */
  label: string;
  /**
   *
   * @type {Array<TeacherBranches>}
   * @memberof TeacherAutoComplete
   */
  branches?: Array<TeacherBranches>;
  /**
   *
   * @type {string}
   * @memberof TeacherAutoComplete
   */
  alternateName?: string;
}
/**
 *
 * @export
 * @interface TeacherBranches
 */
export interface TeacherBranches {
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof TeacherBranches
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherBranches
   */
  updatedBy?: string;
}
/**
 *
 * @export
 * @interface TeacherByLvl
 */
export interface TeacherByLvl {
  /**
   *
   * @type {string}
   * @memberof TeacherByLvl
   */
  datetime: string;
  /**
   *
   * @type {string}
   * @memberof TeacherByLvl
   */
  levelId: string;
  /**
   *
   * @type {string}
   * @memberof TeacherByLvl
   */
  levelCode: string;
  /**
   *
   * @type {string}
   * @memberof TeacherByLvl
   */
  levelName: string;
  /**
   *
   * @type {number}
   * @memberof TeacherByLvl
   */
  numTeacher: number;
}
/**
 *
 * @export
 * @interface TeacherCommissionSetting
 */
export interface TeacherCommissionSetting {
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSetting
   */
  defaultHourlyAmount?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSetting
   */
  commissionPercentage?: number;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSetting
   */
  salaryMode?: string;
  /**
   *
   * @type {Array<TeacherCommissionSettingSalaryByLevel>}
   * @memberof TeacherCommissionSetting
   */
  salaryByLevel?: Array<TeacherCommissionSettingSalaryByLevel>;
}
/**
 *
 * @export
 * @interface TeacherCommissionSettingRequest
 */
export interface TeacherCommissionSettingRequest {
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingRequest
   */
  salaryMode?: string;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSettingRequest
   */
  defaultRate?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSettingRequest
   */
  commissionPercent?: number;
  /**
   *
   * @type {Array<CommissionLevel>}
   * @memberof TeacherCommissionSettingRequest
   */
  commissionLevel?: Array<CommissionLevel>;
}
/**
 *
 * @export
 * @interface TeacherCommissionSettingSalaryByLevel
 */
export interface TeacherCommissionSettingSalaryByLevel {
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  _id?: string;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  minStudent?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  maxStudent?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  hourlyAmount?: number;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  updatedBy?: string;
  /**
   *
   * @type {TeacherCommissionSettingSalaryByLevelLevel}
   * @memberof TeacherCommissionSettingSalaryByLevel
   */
  level?: TeacherCommissionSettingSalaryByLevelLevel;
}
/**
 *
 * @export
 * @interface TeacherCommissionSettingSalaryByLevelLevel
 */
export interface TeacherCommissionSettingSalaryByLevelLevel {
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevelLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevelLevel
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherCommissionSettingSalaryByLevelLevel
   */
  code?: string;
}
/**
 *
 * @export
 * @interface TeacherDocNoFormat
 */
export interface TeacherDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof TeacherDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TeacherGroup
 */
export interface TeacherGroup {
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof TeacherGroup
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherGroup
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof TeacherGroup
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  teacherGroupCode?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  teacherGroupName?: string;
  /**
   *
   * @type {boolean}
   * @memberof TeacherGroup
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof TeacherGroup
   */
  description?: string;
  /**
   *
   * @type {object}
   * @memberof TeacherGroup
   */
  more?: object;
}
/**
 *
 * @export
 * @interface TeacherGroupAnalyse
 */
export interface TeacherGroupAnalyse {
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAnalyse
   */
  datetime: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAnalyse
   */
  teacherGroupId: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAnalyse
   */
  teacherGroupCode: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAnalyse
   */
  teacherGroupName: string;
  /**
   *
   * @type {number}
   * @memberof TeacherGroupAnalyse
   */
  num: number;
}
/**
 *
 * @export
 * @interface TeacherGroupAutoComplete
 */
export interface TeacherGroupAutoComplete {
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof TeacherGroupAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface TeacherPerformance
 */
export interface TeacherPerformance {
  /**
   *
   * @type {string}
   * @memberof TeacherPerformance
   */
  datetime: string;
  /**
   *
   * @type {number}
   * @memberof TeacherPerformance
   */
  totalTeacher: number;
  /**
   *
   * @type {number}
   * @memberof TeacherPerformance
   */
  totalTeacherGroup: number;
  /**
   *
   * @type {number}
   * @memberof TeacherPerformance
   */
  totalLessons: number;
  /**
   *
   * @type {number}
   * @memberof TeacherPerformance
   */
  totalDuration: number;
  /**
   *
   * @type {number}
   * @memberof TeacherPerformance
   */
  totalStudentsByClass: number;
  /**
   *
   * @type {Array<AssignSummary>}
   * @memberof TeacherPerformance
   */
  lessons: Array<AssignSummary>;
  /**
   *
   * @type {Array<AssignSummary>}
   * @memberof TeacherPerformance
   */
  assign: Array<AssignSummary>;
  /**
   *
   * @type {Array<ClassDetails>}
   * @memberof TeacherPerformance
   */
  classDetails: Array<ClassDetails>;
}
/**
 *
 * @export
 * @interface TeacherTeacherGroup
 */
export interface TeacherTeacherGroup {
  /**
   *
   * @type {string}
   * @memberof TeacherTeacherGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherTeacherGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TeacherTeacherGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface Tenant
 */
export interface Tenant {
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Tenant
   */
  tenantId: number;
  /**
   *
   * @type {number}
   * @memberof Tenant
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Tenant
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  tenantName: string;
  /**
   *
   * @type {boolean}
   * @memberof Tenant
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  businessType?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  license?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  planStartDate?: string;
  /**
   *
   * @type {string}
   * @memberof Tenant
   */
  planDueDate?: string;
  /**
   *
   * @type {TenantClientSetting}
   * @memberof Tenant
   */
  clientSetting?: TenantClientSetting;
  /**
   *
   * @type {TenantOwner}
   * @memberof Tenant
   */
  owner: TenantOwner;
  /**
   *
   * @type {TenantOutstandingReminder}
   * @memberof Tenant
   */
  outstandingReminder?: TenantOutstandingReminder;
}
/**
 *
 * @export
 * @interface TenantAutoComplete
 */
export interface TenantAutoComplete {
  /**
   *
   * @type {string}
   * @memberof TenantAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TenantAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof TenantAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface TenantClientSetting
 */
export interface TenantClientSetting {
  /**
   *
   * @type {boolean}
   * @memberof TenantClientSetting
   */
  auditTrail?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TenantClientSetting
   */
  webhook?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TenantClientSetting
   */
  support?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof TenantClientSetting
   */
  disableClassReminder?: boolean;
}
/**
 *
 * @export
 * @interface TenantOutstandingReminder
 */
export interface TenantOutstandingReminder {
  /**
   *
   * @type {boolean}
   * @memberof TenantOutstandingReminder
   */
  enable?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof TenantOutstandingReminder
   */
  cron?: Array<string>;
}
/**
 *
 * @export
 * @interface TenantOwner
 */
export interface TenantOwner {
  /**
   *
   * @type {string}
   * @memberof TenantOwner
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TenantOwner
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof TenantOwner
   */
  uid: string;
}
/**
 *
 * @export
 * @interface TodayClass
 */
export interface TodayClass {
  /**
   *
   * @type {string}
   * @memberof TodayClass
   */
  tuitionClassId: string;
  /**
   *
   * @type {string}
   * @memberof TodayClass
   */
  tuitionClassCode: string;
  /**
   *
   * @type {string}
   * @memberof TodayClass
   */
  tuitionClassLabel: string;
  /**
   *
   * @type {string}
   * @memberof TodayClass
   */
  enrollmentId: string;
  /**
   *
   * @type {Array<object>}
   * @memberof TodayClass
   */
  enrollmenttransaction: Array<object>;
}
/**
 *
 * @export
 * @interface TokenCredential
 */
export interface TokenCredential {
  /**
   *
   * @type {string}
   * @memberof TokenCredential
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof TokenCredential
   */
  messagingToken: string;
}
/**
 *
 * @export
 * @interface TuitionClass
 */
export interface TuitionClass {
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  className?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  classType: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  endDate: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  maxLessons?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  originalTuitionClassId?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  totalSchedule?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  lessonPlanCount?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  academySessionClassGeneratorId?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  defaultDuration: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  defaultStart: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  defaultEnd: string;
  /**
   *
   * @type {boolean}
   * @memberof TuitionClass
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof TuitionClass
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClass
   */
  maxStudents?: number;
  /**
   *
   * @type {TuitionClassAcademySession}
   * @memberof TuitionClass
   */
  academySession: TuitionClassAcademySession;
  /**
   *
   * @type {TuitionClassProduct}
   * @memberof TuitionClass
   */
  product: TuitionClassProduct;
  /**
   *
   * @type {TuitionClassLevel}
   * @memberof TuitionClass
   */
  level?: TuitionClassLevel;
  /**
   *
   * @type {TuitionClassStudentGroup}
   * @memberof TuitionClass
   */
  studentGroup?: TuitionClassStudentGroup;
  /**
   *
   * @type {TuitionClassDefaultTeacher}
   * @memberof TuitionClass
   */
  defaultTeacher: TuitionClassDefaultTeacher;
  /**
   *
   * @type {TuitionClassDefaultRoom}
   * @memberof TuitionClass
   */
  defaultRoom: TuitionClassDefaultRoom;
  /**
   *
   * @type {Array<TuitionClassScheduleSetting>}
   * @memberof TuitionClass
   */
  scheduleSetting?: Array<TuitionClassScheduleSetting>;
  /**
   *
   * @type {TuitionClassDocNoFormat}
   * @memberof TuitionClass
   */
  docNoFormat?: TuitionClassDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof TuitionClass
   */
  more?: object;
}
/**
 *
 * @export
 * @interface TuitionClassAcademySession
 */
export interface TuitionClassAcademySession {
  /**
   *
   * @type {string}
   * @memberof TuitionClassAcademySession
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAcademySession
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAcademySession
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAcademySession
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAcademySession
   */
  endDate?: string;
}
/**
 *
 * @export
 * @interface TuitionClassAutoComplete
 */
export interface TuitionClassAutoComplete {
  /**
   *
   * @type {string}
   * @memberof TuitionClassAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAutoComplete
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassAutoComplete
   */
  endDate?: string;
  /**
   *
   * @type {TuitionClassLevel}
   * @memberof TuitionClassAutoComplete
   */
  level?: TuitionClassLevel;
  /**
   *
   * @type {TuitionClassDefaultTeacher}
   * @memberof TuitionClassAutoComplete
   */
  defaultTeacher?: TuitionClassDefaultTeacher;
  /**
   *
   * @type {TuitionClassStudentGroup}
   * @memberof TuitionClassAutoComplete
   */
  studentGroup?: TuitionClassStudentGroup;
}
/**
 *
 * @export
 * @interface TuitionClassDefaultRoom
 */
export interface TuitionClassDefaultRoom {
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultRoom
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultRoom
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultRoom
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassDefaultRoom
   */
  capacity?: number;
}
/**
 *
 * @export
 * @interface TuitionClassDefaultTeacher
 */
export interface TuitionClassDefaultTeacher {
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultTeacher
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultTeacher
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassDefaultTeacher
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassDocNoFormat
 */
export interface TuitionClassDocNoFormat {
  /**
   *
   * @type {string}
   * @memberof TuitionClassDocNoFormat
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassDocNoFormat
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassLevel
 */
export interface TuitionClassLevel {
  /**
   *
   * @type {string}
   * @memberof TuitionClassLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassNearbySchedule
 */
export interface TuitionClassNearbySchedule {
  /**
   *
   * @type {string}
   * @memberof TuitionClassNearbySchedule
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassNearbySchedule
   */
  day: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassNearbySchedule
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassNearbySchedule
   */
  endTime: string;
}
/**
 *
 * @export
 * @interface TuitionClassNearbyScheduleEntityQuerySpec
 */
export interface TuitionClassNearbyScheduleEntityQuerySpec {
  /**
   *
   * @type {object}
   * @memberof TuitionClassNearbyScheduleEntityQuerySpec
   */
  tuitionClass?: object | null;
  /**
   *
   * @type {object}
   * @memberof TuitionClassNearbyScheduleEntityQuerySpec
   */
  schedule?: object | null;
}
/**
 *
 * @export
 * @interface TuitionClassProduct
 */
export interface TuitionClassProduct {
  /**
   *
   * @type {string}
   * @memberof TuitionClassProduct
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassProduct
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassProduct
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassProduct
   */
  defaultDuration?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClassProduct
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassProduct
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassProduct
   */
  defaultPrice?: number;
  /**
   *
   * @type {TuitionClassProductLevel}
   * @memberof TuitionClassProduct
   */
  level?: TuitionClassProductLevel;
}
/**
 *
 * @export
 * @interface TuitionClassProductLevel
 */
export interface TuitionClassProductLevel {
  /**
   *
   * @type {string}
   * @memberof TuitionClassProductLevel
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassProductLevel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassProductLevel
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassScheduleSetting
 */
export interface TuitionClassScheduleSetting {
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  day: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  start: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  end: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSetting
   */
  _id?: string;
  /**
   *
   * @type {TuitionClassScheduleSettingRoom}
   * @memberof TuitionClassScheduleSetting
   */
  room?: TuitionClassScheduleSettingRoom;
  /**
   *
   * @type {TuitionClassScheduleSettingTeacher}
   * @memberof TuitionClassScheduleSetting
   */
  teacher?: TuitionClassScheduleSettingTeacher;
}
/**
 *
 * @export
 * @interface TuitionClassScheduleSettingRoom
 */
export interface TuitionClassScheduleSettingRoom {
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingRoom
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingRoom
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingRoom
   */
  label?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassScheduleSettingRoom
   */
  maxStudents?: number;
}
/**
 *
 * @export
 * @interface TuitionClassScheduleSettingTeacher
 */
export interface TuitionClassScheduleSettingTeacher {
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingTeacher
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingTeacher
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassScheduleSettingTeacher
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassStudentGroup
 */
export interface TuitionClassStudentGroup {
  /**
   *
   * @type {string}
   * @memberof TuitionClassStudentGroup
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassStudentGroup
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassStudentGroup
   */
  label?: string;
}
/**
 *
 * @export
 * @interface TuitionClassWithLastSchedule
 */
export interface TuitionClassWithLastSchedule {
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithLastSchedule
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithLastSchedule
   */
  tutorId: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithLastSchedule
   */
  productId: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithLastSchedule
   */
  studentGroupId: string;
  /**
   * Last schedule before cutoffDate, or null if none found
   * @type {string}
   * @memberof TuitionClassWithLastSchedule
   */
  lastSchedule?: string | null;
}
/**
 *
 * @export
 * @interface TuitionClassWithLastScheduleParam
 */
export interface TuitionClassWithLastScheduleParam {
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithLastScheduleParam
   */
  cutoffDate: string;
  /**
   * MongoDB-style filter for tuition class
   * @type {object}
   * @memberof TuitionClassWithLastScheduleParam
   */
  filter?: object | null;
}
/**
 *
 * @export
 * @interface TuitionClassWithNearbySchedule
 */
export interface TuitionClassWithNearbySchedule {
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithNearbySchedule
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithNearbySchedule
   */
  tutorId: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithNearbySchedule
   */
  productId: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithNearbySchedule
   */
  studentGroupId: string;
  /**
   *
   * @type {Array<TuitionClassNearbySchedule>}
   * @memberof TuitionClassWithNearbySchedule
   */
  nearbySchedules: Array<TuitionClassNearbySchedule>;
}
/**
 *
 * @export
 * @interface TuitionClassWithNearbyScheduleParam
 */
export interface TuitionClassWithNearbyScheduleParam {
  /**
   * Reference date (ISO 8601). The query will search for schedules within ±day from this date.
   * @type {string}
   * @memberof TuitionClassWithNearbyScheduleParam
   */
  referenceDate: string;
  /**
   * Number of days before and after the reference date to include (±N days).
   * @type {number}
   * @memberof TuitionClassWithNearbyScheduleParam
   */
  rangeInDays: number;
  /**
   * Optional MongoDB filter
   * @type {TuitionClassNearbyScheduleEntityQuerySpec}
   * @memberof TuitionClassWithNearbyScheduleParam
   */
  filters?: TuitionClassNearbyScheduleEntityQuerySpec | null;
  /**
   * Optional MongoDB projection
   * @type {TuitionClassNearbyScheduleEntityQuerySpec}
   * @memberof TuitionClassWithNearbyScheduleParam
   */
  fields?: TuitionClassNearbyScheduleEntityQuerySpec | null;
}
/**
 *
 * @export
 * @interface TuitionClassWithSchedules
 */
export interface TuitionClassWithSchedules {
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  className?: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  classType: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  endDate: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  maxLessons?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  originalTuitionClassId?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  totalSchedule?: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  lessonPlanCount?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  academySessionClassGeneratorId?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  defaultDuration: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  billingMethod?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  lessonsPerTerm?: number;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  defaultStart: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  defaultEnd: string;
  /**
   *
   * @type {boolean}
   * @memberof TuitionClassWithSchedules
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSchedules
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSchedules
   */
  maxStudents?: number;
  /**
   *
   * @type {TuitionClassAcademySession}
   * @memberof TuitionClassWithSchedules
   */
  academySession: TuitionClassAcademySession;
  /**
   *
   * @type {TuitionClassProduct}
   * @memberof TuitionClassWithSchedules
   */
  product: TuitionClassProduct;
  /**
   *
   * @type {TuitionClassLevel}
   * @memberof TuitionClassWithSchedules
   */
  level?: TuitionClassLevel;
  /**
   *
   * @type {TuitionClassStudentGroup}
   * @memberof TuitionClassWithSchedules
   */
  studentGroup?: TuitionClassStudentGroup;
  /**
   *
   * @type {TuitionClassDefaultTeacher}
   * @memberof TuitionClassWithSchedules
   */
  defaultTeacher: TuitionClassDefaultTeacher;
  /**
   *
   * @type {TuitionClassDefaultRoom}
   * @memberof TuitionClassWithSchedules
   */
  defaultRoom: TuitionClassDefaultRoom;
  /**
   *
   * @type {Array<TuitionClassScheduleSetting>}
   * @memberof TuitionClassWithSchedules
   */
  scheduleSetting?: Array<TuitionClassScheduleSetting>;
  /**
   *
   * @type {TuitionClassDocNoFormat}
   * @memberof TuitionClassWithSchedules
   */
  docNoFormat?: TuitionClassDocNoFormat;
  /**
   *
   * @type {object}
   * @memberof TuitionClassWithSchedules
   */
  more?: object;
  /**
   *
   * @type {Array<ScheduleWithStatistic>}
   * @memberof TuitionClassWithSchedules
   */
  schedules: Array<ScheduleWithStatistic>;
}
/**
 *
 * @export
 * @interface TuitionClassWithSummary
 */
export interface TuitionClassWithSummary {
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  classCode: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  className: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  classType: string;
  /**
   *
   * @type {TuitionClassProduct}
   * @memberof TuitionClassWithSummary
   */
  product: TuitionClassProduct;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  startDate: string;
  /**
   *
   * @type {string}
   * @memberof TuitionClassWithSummary
   */
  endDate: string;
  /**
   *
   * @type {TuitionClassLevel}
   * @memberof TuitionClassWithSummary
   */
  level: TuitionClassLevel;
  /**
   *
   * @type {TuitionClassStudentGroup}
   * @memberof TuitionClassWithSummary
   */
  studentGroup: TuitionClassStudentGroup;
  /**
   *
   * @type {TuitionClassDefaultTeacher}
   * @memberof TuitionClassWithSummary
   */
  defaultTeacher: TuitionClassDefaultTeacher;
  /**
   *
   * @type {TuitionClassDefaultRoom}
   * @memberof TuitionClassWithSummary
   */
  defaultRoom: TuitionClassDefaultRoom;
  /**
   *
   * @type {Array<TuitionClassScheduleSetting>}
   * @memberof TuitionClassWithSummary
   */
  scheduleSetting: Array<TuitionClassScheduleSetting>;
  /**
   *
   * @type {boolean}
   * @memberof TuitionClassWithSummary
   */
  active: boolean;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSummary
   */
  totalStudents: number;
  /**
   *
   * @type {number}
   * @memberof TuitionClassWithSummary
   */
  totalSchedules: number;
}
/**
 *
 * @export
 * @interface TutorAttendanceRemarkUpdate
 */
export interface TutorAttendanceRemarkUpdate {
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceRemarkUpdate
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceRemarkUpdate
   */
  enrolmentId: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceRemarkUpdate
   */
  remark: string;
}
/**
 *
 * @export
 * @interface TutorAttendanceSearch
 */
export interface TutorAttendanceSearch {
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  studentCode: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  studentName: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  tuitionClassId: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  tuitionClassCode: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  tuitionClassLabel: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceSearch
   */
  enrollmentId: string;
  /**
   *
   * @type {Array<object>}
   * @memberof TutorAttendanceSearch
   */
  enrollmenttransaction: Array<object>;
}
/**
 *
 * @export
 * @interface TutorAttendanceUpdate
 */
export interface TutorAttendanceUpdate {
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceUpdate
   */
  studentId: string;
  /**
   *
   * @type {string}
   * @memberof TutorAttendanceUpdate
   */
  enrolmentId: string;
  /**
   *
   * @type {boolean}
   * @memberof TutorAttendanceUpdate
   */
  attend: boolean;
}
/**
 *
 * @export
 * @interface TutorScheduleAttendance
 */
export interface TutorScheduleAttendance {
  /**
   *
   * @type {Array<TutorScheduleLessonPlanUpdate>}
   * @memberof TutorScheduleAttendance
   */
  schedule: Array<TutorScheduleLessonPlanUpdate>;
  /**
   *
   * @type {Array<ParentInAttendance>}
   * @memberof TutorScheduleAttendance
   */
  parent: Array<ParentInAttendance>;
}
/**
 *
 * @export
 * @interface TutorScheduleLessonPlanUpdate
 */
export interface TutorScheduleLessonPlanUpdate {
  /**
   *
   * @type {string}
   * @memberof TutorScheduleLessonPlanUpdate
   */
  lessonPlan: string;
  /**
   *
   * @type {string}
   * @memberof TutorScheduleLessonPlanUpdate
   */
  description: string;
}
/**
 *
 * @export
 * @interface UpdateManyResponse
 */
export interface UpdateManyResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateManyResponse
   */
  acknowledged: boolean;
  /**
   *
   * @type {number}
   * @memberof UpdateManyResponse
   */
  matchedCount: number;
  /**
   *
   * @type {number}
   * @memberof UpdateManyResponse
   */
  modifiedCount: number;
  /**
   *
   * @type {number}
   * @memberof UpdateManyResponse
   */
  upsertedCount: number;
  /**
   *
   * @type {string}
   * @memberof UpdateManyResponse
   */
  upsertedId: string | null;
}
/**
 *
 * @export
 * @interface UpgradeScript
 */
export interface UpgradeScript {
  /**
   *
   * @type {string}
   * @memberof UpgradeScript
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UpgradeScript
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof UpgradeScript
   */
  description: string;
}
/**
 *
 * @export
 * @interface UpgradeStudentLevelRequestBody
 */
export interface UpgradeStudentLevelRequestBody {
  /**
   *
   * @type {Array<string>}
   * @memberof UpgradeStudentLevelRequestBody
   */
  levelIds?: Array<string>;
}
/**
 *
 * @export
 * @interface UploadPhoto
 */
export interface UploadPhoto {
  /**
   *
   * @type {string}
   * @memberof UploadPhoto
   */
  filename?: string | null;
  /**
   *
   * @type {string}
   * @memberof UploadPhoto
   */
  base64Image: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof User
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof User
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  fullName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof User
   */
  completedTours?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastActivity?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  mobileNo?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  interestedInSales?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  imageUrl?: string;
}
/**
 *
 * @export
 * @interface UserAutoComplete
 */
export interface UserAutoComplete {
  /**
   *
   * @type {string}
   * @memberof UserAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof UserAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof UserAutoComplete
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof UserAutoComplete
   */
  uid?: string;
}
/**
 *
 * @export
 * @interface UserBranch
 */
export interface UserBranch {
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  fullName: string;
  /**
   *
   * @type {number}
   * @memberof UserBranch
   */
  orgId: number;
  /**
   *
   * @type {number}
   * @memberof UserBranch
   */
  tenantId: number;
  /**
   *
   * @type {number}
   * @memberof UserBranch
   */
  branchId: number;
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  branchName: string;
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  orgName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserBranch
   */
  permission: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UserBranch
   */
  xOrg: string;
}
/**
 *
 * @export
 * @interface UserContextInfo
 */
export interface UserContextInfo {
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  sessionId: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  xOrg: string;
  /**
   *
   * @type {number}
   * @memberof UserContextInfo
   */
  tenantId: number;
  /**
   *
   * @type {number}
   * @memberof UserContextInfo
   */
  orgId: number;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  orgRecordId: string;
  /**
   *
   * @type {number}
   * @memberof UserContextInfo
   */
  branchId: number;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  branchRecordId: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  branchCode: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  branchName: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  orgCode: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  orgName: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  timeZone: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  currency: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  country: string;
  /**
   *
   * @type {number}
   * @memberof UserContextInfo
   */
  offsetMinute: number;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  uName: string;
  /**
   *
   * @type {string}
   * @memberof UserContextInfo
   */
  fullName: string;
  /**
   * List of user\'s group in product
   * @type {Array<string>}
   * @memberof UserContextInfo
   */
  groups: Array<string>;
  /**
   * List of task, or authority of the user can do
   * @type {Array<string>}
   * @memberof UserContextInfo
   */
  roles: Array<string>;
  /**
   * Provide invitation id to user, to authorize join the tenant
   * @type {Array<ProfileUserInvites>}
   * @memberof UserContextInfo
   */
  invites: Array<ProfileUserInvites>;
  /**
   * List of branch the user can access in current tenant
   * @type {Array<ProfileUserBranch>}
   * @memberof UserContextInfo
   */
  branches: Array<ProfileUserBranch>;
  /**
   * List of task, or authority of the user can do
   * @type {Tenant}
   * @memberof UserContextInfo
   */
  tenantInfo: Tenant;
  /**
   * List of task, or authority of the user can do
   * @type {Organization}
   * @memberof UserContextInfo
   */
  orgInfo: Organization;
  /**
   * List of task, or authority of the user can do
   * @type {Branch}
   * @memberof UserContextInfo
   */
  branchInfo: Branch;
  /**
   * Store all the rest of useful fields regarding user or branch
   * @type {object}
   * @memberof UserContextInfo
   */
  moreProps: object;
}
/**
 *
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof UserPermission
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof UserPermission
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof UserPermission
   */
  branchId?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof UserPermission
   */
  groups?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  uid?: string;
  /**
   *
   * @type {string}
   * @memberof UserPermission
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface ValidateOnlinePaymentResponse
 */
export interface ValidateOnlinePaymentResponse {
  /**
   *
   * @type {OnlinePaymentValidateData}
   * @memberof ValidateOnlinePaymentResponse
   */
  onlinePayment: OnlinePaymentValidateData;
}
/**
 *
 * @export
 * @interface Webhook
 */
export interface Webhook {
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof Webhook
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof Webhook
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof Webhook
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  requestMethod?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  authentication?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  body?: string;
  /**
   *
   * @type {boolean}
   * @memberof Webhook
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  resourceName?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  eventType?: string;
  /**
   *
   * @type {string}
   * @memberof Webhook
   */
  jobType?: string;
  /**
   *
   * @type {number}
   * @memberof Webhook
   */
  retryAttemps?: number;
  /**
   *
   * @type {WebhookBasicAuth}
   * @memberof Webhook
   */
  basicAuth?: WebhookBasicAuth;
  /**
   *
   * @type {Array<WebhookHeaders>}
   * @memberof Webhook
   */
  headers?: Array<WebhookHeaders>;
}
/**
 *
 * @export
 * @interface WebhookAutoComplete
 */
export interface WebhookAutoComplete {
  /**
   *
   * @type {string}
   * @memberof WebhookAutoComplete
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof WebhookAutoComplete
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof WebhookAutoComplete
   */
  label: string;
}
/**
 *
 * @export
 * @interface WebhookBasicAuth
 */
export interface WebhookBasicAuth {
  /**
   *
   * @type {string}
   * @memberof WebhookBasicAuth
   */
  user?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookBasicAuth
   */
  password?: string;
}
/**
 *
 * @export
 * @interface WebhookHeaders
 */
export interface WebhookHeaders {
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  updatedBy?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookHeaders
   */
  _id?: string;
}
/**
 *
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  _id?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  webHookId: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  dataId: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  updatedBy?: string;
  /**
   *
   * @type {number}
   * @memberof WebhookLog
   */
  tenantId?: number;
  /**
   *
   * @type {number}
   * @memberof WebhookLog
   */
  orgId?: number;
  /**
   *
   * @type {number}
   * @memberof WebhookLog
   */
  branchId?: number;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  resource?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  actionName?: string;
  /**
   *
   * @type {number}
   * @memberof WebhookLog
   */
  statusCode?: number;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof WebhookLog
   */
  msg: string;
}
/**
 *
 * @export
 * @interface WorkingHour
 */
export interface WorkingHour {
  /**
   * Day of the week
   * @type {string}
   * @memberof WorkingHour
   */
  day: WorkingHourDayEnum;
  /**
   * Start time in HH:mm:ss format
   * @type {string}
   * @memberof WorkingHour
   */
  start: string;
  /**
   * End time in HH:mm:ss format
   * @type {string}
   * @memberof WorkingHour
   */
  end: string;
}

export const WorkingHourDayEnum = {
  Empty: "",
  Mon: "mon",
  Tue: "tue",
  Wed: "wed",
  Thu: "thu",
  Fri: "fri",
  Sat: "sat",
  Sun: "sun",
} as const;

export type WorkingHourDayEnum =
  (typeof WorkingHourDayEnum)[keyof typeof WorkingHourDayEnum];

/**
 * ACADEMYSESSIONApi - axios parameter creator
 * @export
 */
export const ACADEMYSESSIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/academysession/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      academySession: AcademySession,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'academySession' is not null or undefined
      assertParamExists("runCreate", "academySession", academySession);
      const localVarPath = `/academysession`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySession,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/academysession`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/academysession/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/academysession/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateClasses: async (
      academySessionClassGenerator: AcademySessionClassGenerator,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'academySessionClassGenerator' is not null or undefined
      assertParamExists(
        "runGenerateClasses",
        "academySessionClassGenerator",
        academySessionClassGenerator
      );
      const localVarPath = `/academysession-api/generate-classes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySessionClassGenerator,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHistories: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/academysession-api/history`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassList: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetTuitionClassList", "id", id);
      const localVarPath =
        `/academysession-api/{id}/get-tuition-classes`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      academySession: AcademySession,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'academySession' is not null or undefined
      assertParamExists("runPatch", "academySession", academySession);
      const localVarPath = `/academysession/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySession,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/academysession/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrepareClassGenerator: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/academysession-api/prepare-generate-classes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} generateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReverseClasses: async (
      generateId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'generateId' is not null or undefined
      assertParamExists("runReverseClasses", "generateId", generateId);
      const localVarPath =
        `/academysession-api/delete-generated-class/{generateId}`.replace(
          `{${"generateId"}}`,
          encodeURIComponent(String(generateId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/academysession/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      academySession: AcademySession,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'academySession' is not null or undefined
      assertParamExists("runUpdate", "academySession", academySession);
      const localVarPath = `/academysession/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySession,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateClassGenerator: async (
      academySessionClassGenerator: AcademySessionClassGenerator,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'academySessionClassGenerator' is not null or undefined
      assertParamExists(
        "runUpdateClassGenerator",
        "academySessionClassGenerator",
        academySessionClassGenerator
      );
      const localVarPath = `/academysession-api/update-class-generator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySessionClassGenerator,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ACADEMYSESSIONApi - functional programming interface
 * @export
 */
export const ACADEMYSESSIONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ACADEMYSESSIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AcademySessionAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcademySession>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        academySession,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcademySession>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcademySession>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGenerateClasses(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueueJobProducerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGenerateClasses(
          academySessionClassGenerator,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runGenerateClasses"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetHistories(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ClassGenerateHistory>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetHistories(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runGetHistories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTuitionClassList(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClassWithSummary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTuitionClassList(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runGetTuitionClassList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        academySession,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrepareClassGenerator(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AcademySessionClassGenerator>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runPrepareClassGenerator(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runPrepareClassGenerator"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} generateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReverseClasses(
      generateId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runReverseClasses(generateId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runReverseClasses"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AcademySession>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        academySession,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateClassGenerator(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AcademySessionClassGenerator>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateClassGenerator(
          academySessionClassGenerator,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONApi.runUpdateClassGenerator"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ACADEMYSESSIONApi - factory interface
 * @export
 */
export const ACADEMYSESSIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ACADEMYSESSIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AcademySessionAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySession> {
      return localVarFp
        .runCreate(academySession, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySession> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySession> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateClasses(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJobProducerResponse> {
      return localVarFp
        .runGenerateClasses(academySessionClassGenerator, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHistories(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ClassGenerateHistory>> {
      return localVarFp
        .runGetHistories(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassList(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClassWithSummary>> {
      return localVarFp
        .runGetTuitionClassList(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, academySession, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrepareClassGenerator(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySessionClassGenerator> {
      return localVarFp
        .runPrepareClassGenerator(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} generateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReverseClasses(
      generateId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runReverseClasses(generateId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AcademySession>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySession} academySession Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      academySession: AcademySession,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, academySession, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateClassGenerator(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySessionClassGenerator> {
      return localVarFp
        .runUpdateClassGenerator(academySessionClassGenerator, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ACADEMYSESSIONApi - object-oriented interface
 * @export
 * @class ACADEMYSESSIONApi
 * @extends {BaseAPI}
 */
export class ACADEMYSESSIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AcademySession} academySession Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runCreate(
    academySession: AcademySession,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runCreate(academySession, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runGenerateClasses(
    academySessionClassGenerator: AcademySessionClassGenerator,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runGenerateClasses(academySessionClassGenerator, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runGetHistories(options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runGetHistories(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runGetTuitionClassList(id: string, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runGetTuitionClassList(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AcademySession} academySession Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runPatch(
    id: string,
    academySession: AcademySession,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runPatch(id, academySession, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runPrepareClassGenerator(options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runPrepareClassGenerator(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} generateId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runReverseClasses(
    generateId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runReverseClasses(generateId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AcademySession} academySession Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runUpdate(
    id: string,
    academySession: AcademySession,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runUpdate(id, academySession, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AcademySessionClassGenerator} academySessionClassGenerator Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONApi
   */
  public runUpdateClassGenerator(
    academySessionClassGenerator: AcademySessionClassGenerator,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONApiFp(this.configuration)
      .runUpdateClassGenerator(academySessionClassGenerator, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ACADEMYSESSIONCLASSGENERATORApi - axios parameter creator
 * @export
 */
export const ACADEMYSESSIONCLASSGENERATORApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/academysessionclassgenerator/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      academySessionClassGenerator: AcademySessionClassGenerator,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'academySessionClassGenerator' is not null or undefined
      assertParamExists(
        "runCreate",
        "academySessionClassGenerator",
        academySessionClassGenerator
      );
      const localVarPath = `/academysessionclassgenerator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySessionClassGenerator,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/academysessionclassgenerator`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/academysessionclassgenerator/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/academysessionclassgenerator/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'academySessionClassGenerator' is not null or undefined
      assertParamExists(
        "runPatch",
        "academySessionClassGenerator",
        academySessionClassGenerator
      );
      const localVarPath = `/academysessionclassgenerator/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySessionClassGenerator,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/academysessionclassgenerator/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/academysessionclassgenerator/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'academySessionClassGenerator' is not null or undefined
      assertParamExists(
        "runUpdate",
        "academySessionClassGenerator",
        academySessionClassGenerator
      );
      const localVarPath = `/academysessionclassgenerator/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        academySessionClassGenerator,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ACADEMYSESSIONCLASSGENERATORApi - functional programming interface
 * @export
 */
export const ACADEMYSESSIONCLASSGENERATORApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ACADEMYSESSIONCLASSGENERATORApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AcademySessionClassGeneratorAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AcademySessionClassGenerator>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        academySessionClassGenerator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AcademySessionClassGenerator>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AcademySessionClassGenerator>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        academySessionClassGenerator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AcademySessionClassGenerator>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        academySessionClassGenerator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACADEMYSESSIONCLASSGENERATORApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ACADEMYSESSIONCLASSGENERATORApi - factory interface
 * @export
 */
export const ACADEMYSESSIONCLASSGENERATORApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ACADEMYSESSIONCLASSGENERATORApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AcademySessionClassGeneratorAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySessionClassGenerator> {
      return localVarFp
        .runCreate(academySessionClassGenerator, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySessionClassGenerator> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AcademySessionClassGenerator> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, academySessionClassGenerator, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AcademySessionClassGenerator>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      academySessionClassGenerator: AcademySessionClassGenerator,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, academySessionClassGenerator, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ACADEMYSESSIONCLASSGENERATORApi - object-oriented interface
 * @export
 * @class ACADEMYSESSIONCLASSGENERATORApi
 * @extends {BaseAPI}
 */
export class ACADEMYSESSIONCLASSGENERATORApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runCreate(
    academySessionClassGenerator: AcademySessionClassGenerator,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runCreate(academySessionClassGenerator, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runPatch(
    id: string,
    academySessionClassGenerator: AcademySessionClassGenerator,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runPatch(id, academySessionClassGenerator, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AcademySessionClassGenerator} academySessionClassGenerator Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACADEMYSESSIONCLASSGENERATORApi
   */
  public runUpdate(
    id: string,
    academySessionClassGenerator: AcademySessionClassGenerator,
    options?: RawAxiosRequestConfig
  ) {
    return ACADEMYSESSIONCLASSGENERATORApiFp(this.configuration)
      .runUpdate(id, academySessionClassGenerator, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ACCOUNTINGApi - axios parameter creator
 * @export
 */
export const ACCOUNTINGApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJE: async (
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemType' is not null or undefined
      assertParamExists("deleteJE", "systemType", systemType);
      // verify required parameter 'docType' is not null or undefined
      assertParamExists("deleteJE", "docType", docType);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("deleteJE", "requestBody", requestBody);
      const localVarPath = `/accounting/{systemType}/{docType}/deleteJE`
        .replace(`{${"systemType"}}`, encodeURIComponent(String(systemType)))
        .replace(`{${"docType"}}`, encodeURIComponent(String(docType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * run create a Journal Entry record in accounting system
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody document ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateJEinAccounting: async (
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemType' is not null or undefined
      assertParamExists("runCreateJEinAccounting", "systemType", systemType);
      // verify required parameter 'docType' is not null or undefined
      assertParamExists("runCreateJEinAccounting", "docType", docType);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCreateJEinAccounting", "requestBody", requestBody);
      const localVarPath = `/accounting/{systemType}/{docType}/createJE`
        .replace(`{${"systemType"}}`, encodeURIComponent(String(systemType)))
        .replace(`{${"docType"}}`, encodeURIComponent(String(docType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {string} docType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchDocuments: async (
      dateFrom: string,
      dateTo: string,
      docType: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runSearchDocuments", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runSearchDocuments", "dateTo", dateTo);
      // verify required parameter 'docType' is not null or undefined
      assertParamExists("runSearchDocuments", "docType", docType);
      const localVarPath = `/accounting/{docType}/{dateFrom}/{dateTo}`
        .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
        .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)))
        .replace(`{${"docType"}}`, encodeURIComponent(String(docType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Void JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voidJE: async (
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemType' is not null or undefined
      assertParamExists("voidJE", "systemType", systemType);
      // verify required parameter 'docType' is not null or undefined
      assertParamExists("voidJE", "docType", docType);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("voidJE", "requestBody", requestBody);
      const localVarPath = `/accounting/{systemType}/{docType}/voidJE`
        .replace(`{${"systemType"}}`, encodeURIComponent(String(systemType)))
        .replace(`{${"docType"}}`, encodeURIComponent(String(docType)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ACCOUNTINGApi - functional programming interface
 * @export
 */
export const ACCOUNTINGApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ACCOUNTINGApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteJE(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJE(
        systemType,
        docType,
        requestBody,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTINGApi.deleteJE"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * run create a Journal Entry record in accounting system
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody document ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreateJEinAccounting(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCreateJEinAccounting(
          systemType,
          docType,
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTINGApi.runCreateJEinAccounting"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {string} docType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearchDocuments(
      dateFrom: string,
      dateTo: string,
      docType: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BillDocumentType>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSearchDocuments(
          dateFrom,
          dateTo,
          docType,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTINGApi.runSearchDocuments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Void JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async voidJE(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.voidJE(
        systemType,
        docType,
        requestBody,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTINGApi.voidJE"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ACCOUNTINGApi - factory interface
 * @export
 */
export const ACCOUNTINGApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ACCOUNTINGApiFp(configuration);
  return {
    /**
     * Delete JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteJE(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<FinalResponse> {
      return localVarFp
        .deleteJE(systemType, docType, requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     * run create a Journal Entry record in accounting system
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody document ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateJEinAccounting(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<FinalResponse> {
      return localVarFp
        .runCreateJEinAccounting(systemType, docType, requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {string} docType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchDocuments(
      dateFrom: string,
      dateTo: string,
      docType: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BillDocumentType>> {
      return localVarFp
        .runSearchDocuments(dateFrom, dateTo, docType, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Void JE record
     * @summary
     * @param {string} systemType
     * @param {string} docType
     * @param {Array<string>} requestBody Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    voidJE(
      systemType: string,
      docType: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<FinalResponse> {
      return localVarFp
        .voidJE(systemType, docType, requestBody, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ACCOUNTINGApi - object-oriented interface
 * @export
 * @class ACCOUNTINGApi
 * @extends {BaseAPI}
 */
export class ACCOUNTINGApi extends BaseAPI {
  /**
   * Delete JE record
   * @summary
   * @param {string} systemType
   * @param {string} docType
   * @param {Array<string>} requestBody Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTINGApi
   */
  public deleteJE(
    systemType: string,
    docType: string,
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTINGApiFp(this.configuration)
      .deleteJE(systemType, docType, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * run create a Journal Entry record in accounting system
   * @summary
   * @param {string} systemType
   * @param {string} docType
   * @param {Array<string>} requestBody document ids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTINGApi
   */
  public runCreateJEinAccounting(
    systemType: string,
    docType: string,
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTINGApiFp(this.configuration)
      .runCreateJEinAccounting(systemType, docType, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {string} docType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTINGApi
   */
  public runSearchDocuments(
    dateFrom: string,
    dateTo: string,
    docType: string,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTINGApiFp(this.configuration)
      .runSearchDocuments(dateFrom, dateTo, docType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Void JE record
   * @summary
   * @param {string} systemType
   * @param {string} docType
   * @param {Array<string>} requestBody Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTINGApi
   */
  public voidJE(
    systemType: string,
    docType: string,
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTINGApiFp(this.configuration)
      .voidJE(systemType, docType, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ACCOUNTTRANSACTIONApi - axios parameter creator
 * @export
 */
export const ACCOUNTTRANSACTIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/accounttransaction/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      accountTransaction: AccountTransaction,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountTransaction' is not null or undefined
      assertParamExists("runCreate", "accountTransaction", accountTransaction);
      const localVarPath = `/accounttransaction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        accountTransaction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounttransaction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/accounttransaction/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/accounttransaction/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/accounttransaction/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runOutstandingByStudents: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounttransaction-api/outstanding-by-students`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      accountTransaction: AccountTransaction,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'accountTransaction' is not null or undefined
      assertParamExists("runPatch", "accountTransaction", accountTransaction);
      const localVarPath = `/accounttransaction/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        accountTransaction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/accounttransaction/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/accounttransaction/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      accountTransaction: AccountTransaction,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'accountTransaction' is not null or undefined
      assertParamExists("runUpdate", "accountTransaction", accountTransaction);
      const localVarPath = `/accounttransaction/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        accountTransaction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ACCOUNTTRANSACTIONApi - functional programming interface
 * @export
 */
export const ACCOUNTTRANSACTIONApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ACCOUNTTRANSACTIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AccountTransactionAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AccountTransaction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        accountTransaction,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AccountTransaction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AccountTransaction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AccountTransaction>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runOutstandingByStudents(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OutstandingByStudent>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runOutstandingByStudents(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runOutstandingByStudents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        accountTransaction,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AccountTransaction>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        accountTransaction,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACCOUNTTRANSACTIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ACCOUNTTRANSACTIONApi - factory interface
 * @export
 */
export const ACCOUNTTRANSACTIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ACCOUNTTRANSACTIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AccountTransactionAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AccountTransaction> {
      return localVarFp
        .runCreate(accountTransaction, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AccountTransaction> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AccountTransaction> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AccountTransaction>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runOutstandingByStudents(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OutstandingByStudent>> {
      return localVarFp
        .runOutstandingByStudents(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, accountTransaction, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AccountTransaction>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AccountTransaction} accountTransaction Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      accountTransaction: AccountTransaction,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, accountTransaction, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ACCOUNTTRANSACTIONApi - object-oriented interface
 * @export
 * @class ACCOUNTTRANSACTIONApi
 * @extends {BaseAPI}
 */
export class ACCOUNTTRANSACTIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AccountTransaction} accountTransaction Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runCreate(
    accountTransaction: AccountTransaction,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runCreate(accountTransaction, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runOutstandingByStudents(options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runOutstandingByStudents(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AccountTransaction} accountTransaction Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runPatch(
    id: string,
    accountTransaction: AccountTransaction,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runPatch(id, accountTransaction, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AccountTransaction} accountTransaction Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACCOUNTTRANSACTIONApi
   */
  public runUpdate(
    id: string,
    accountTransaction: AccountTransaction,
    options?: RawAxiosRequestConfig
  ) {
    return ACCOUNTTRANSACTIONApiFp(this.configuration)
      .runUpdate(id, accountTransaction, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ACTIONHISTORYApi - axios parameter creator
 * @export
 */
export const ACTIONHISTORYApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/actionhistory/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      actionHistory: ActionHistory,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'actionHistory' is not null or undefined
      assertParamExists("runCreate", "actionHistory", actionHistory);
      const localVarPath = `/actionhistory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        actionHistory,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/actionhistory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/actionhistory/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/actionhistory/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      actionHistory: ActionHistory,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'actionHistory' is not null or undefined
      assertParamExists("runPatch", "actionHistory", actionHistory);
      const localVarPath = `/actionhistory/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        actionHistory,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/actionhistory/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/actionhistory/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      actionHistory: ActionHistory,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'actionHistory' is not null or undefined
      assertParamExists("runUpdate", "actionHistory", actionHistory);
      const localVarPath = `/actionhistory/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        actionHistory,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ACTIONHISTORYApi - functional programming interface
 * @export
 */
export const ACTIONHISTORYApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ACTIONHISTORYApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ActionHistoryAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionHistory>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        actionHistory,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionHistory>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionHistory>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        actionHistory,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ActionHistory>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        actionHistory,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ACTIONHISTORYApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ACTIONHISTORYApi - factory interface
 * @export
 */
export const ACTIONHISTORYApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ACTIONHISTORYApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ActionHistoryAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActionHistory> {
      return localVarFp
        .runCreate(actionHistory, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActionHistory> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActionHistory> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, actionHistory, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ActionHistory>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ActionHistory} actionHistory Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      actionHistory: ActionHistory,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, actionHistory, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ACTIONHISTORYApi - object-oriented interface
 * @export
 * @class ACTIONHISTORYApi
 * @extends {BaseAPI}
 */
export class ACTIONHISTORYApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ACTIONHISTORYApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {ActionHistory} actionHistory Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runCreate(
    actionHistory: ActionHistory,
    options?: RawAxiosRequestConfig
  ) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runCreate(actionHistory, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ActionHistory} actionHistory Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runPatch(
    id: string,
    actionHistory: ActionHistory,
    options?: RawAxiosRequestConfig
  ) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runPatch(id, actionHistory, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ActionHistory} actionHistory Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ACTIONHISTORYApi
   */
  public runUpdate(
    id: string,
    actionHistory: ActionHistory,
    options?: RawAxiosRequestConfig
  ) {
    return ACTIONHISTORYApiFp(this.configuration)
      .runUpdate(id, actionHistory, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AGENTApi - axios parameter creator
 * @export
 */
export const AGENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/agent/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      agent: Agent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agent' is not null or undefined
      assertParamExists("runCreate", "agent", agent);
      const localVarPath = `/agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        agent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/agent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/agent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      agent: Agent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'agent' is not null or undefined
      assertParamExists("runPatch", "agent", agent);
      const localVarPath = `/agent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        agent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/agent/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/agent/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      agent: Agent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'agent' is not null or undefined
      assertParamExists("runUpdate", "agent", agent);
      const localVarPath = `/agent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        agent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AGENTApi - functional programming interface
 * @export
 */
export const AGENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AGENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AgentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        agent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        agent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        agent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AGENTApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AGENTApi - factory interface
 * @export
 */
export const AGENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AGENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AgentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Agent> {
      return localVarFp
        .runCreate(agent, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Agent> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Agent> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, agent, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Agent>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Agent} agent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      agent: Agent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, agent, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * AGENTApi - object-oriented interface
 * @export
 * @class AGENTApi
 * @extends {BaseAPI}
 */
export class AGENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return AGENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Agent} agent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runCreate(agent: Agent, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runCreate(agent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Agent} agent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runPatch(id: string, agent: Agent, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runPatch(id, agent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AGENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Agent} agent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AGENTApi
   */
  public runUpdate(id: string, agent: Agent, options?: RawAxiosRequestConfig) {
    return AGENTApiFp(this.configuration)
      .runUpdate(id, agent, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ANNOUNCEMENTApi - axios parameter creator
 * @export
 */
export const ANNOUNCEMENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusConfirm: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("announcementControllerSetStatusConfirm", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("announcementControllerSetStatusConfirm", "body", body);
      const localVarPath = `/announcement/{id}/set-confirm`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusDraft: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("announcementControllerSetStatusDraft", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("announcementControllerSetStatusDraft", "body", body);
      const localVarPath = `/announcement/{id}/set-draft`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusVoid: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("announcementControllerSetStatusVoid", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("announcementControllerSetStatusVoid", "body", body);
      const localVarPath = `/announcement/{id}/set-void`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/announcement/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      announcement: Announcement,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'announcement' is not null or undefined
      assertParamExists("runCreate", "announcement", announcement);
      const localVarPath = `/announcement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcement,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/announcement/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/announcement/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttachment: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetAttachment", "id", id);
      const localVarPath = `/announcement-api/{id}/attachment`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetInboxList: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcement-api/getinbox`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserAnnouncement: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcement-api/announcement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserOneAnnouncement: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetUserOneAnnouncement", "id", id);
      const localVarPath = `/announcement-api/{id}/announcement`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserOtherAnnouncement: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcement-api/otherannouncement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      announcement: Announcement,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'announcement' is not null or undefined
      assertParamExists("runPatch", "announcement", announcement);
      const localVarPath = `/announcement/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcement,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/announcement/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadAnnouncement: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runReadAnnouncement", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runReadAnnouncement", "body", body);
      const localVarPath = `/announcement-api/{id}/readannouncement`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadInbox: async (
      type: string,
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("runReadInbox", "type", type);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runReadInbox", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runReadInbox", "body", body);
      const localVarPath = `/announcement-api/{type}/{id}/readInbox`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/announcement/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      announcement: Announcement,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'announcement' is not null or undefined
      assertParamExists("runUpdate", "announcement", announcement);
      const localVarPath = `/announcement/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcement,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValue} keyValue Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadAttachment: async (
      id: string,
      keyValue: KeyValue,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadAttachment", "id", id);
      // verify required parameter 'keyValue' is not null or undefined
      assertParamExists("runUploadAttachment", "keyValue", keyValue);
      const localVarPath = `/announcement-api/{id}/attachment`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        keyValue,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ANNOUNCEMENTApi - functional programming interface
 * @export
 */
export const ANNOUNCEMENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ANNOUNCEMENTApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementControllerSetStatusConfirm(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ANNOUNCEMENTApi.announcementControllerSetStatusConfirm"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementControllerSetStatusDraft(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ANNOUNCEMENTApi.announcementControllerSetStatusDraft"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async announcementControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.announcementControllerSetStatusVoid(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ANNOUNCEMENTApi.announcementControllerSetStatusVoid"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AnnouncementAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        announcement,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetAttachment(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetAttachment(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runGetAttachment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetInboxList(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SystemInboxResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetInboxList(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runGetInboxList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetUserAnnouncement(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AnnouncementResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetUserAnnouncement(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runGetUserAnnouncement"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetUserOneAnnouncement(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnnouncementResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetUserOneAnnouncement(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runGetUserOneAnnouncement"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetUserOtherAnnouncement(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AnnouncementResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetUserOtherAnnouncement(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runGetUserOtherAnnouncement"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        announcement,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReadAnnouncement(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runReadAnnouncement(id, body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runReadAnnouncement"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReadInbox(
      type: string,
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SystemInboxResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runReadInbox(
        type,
        id,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runReadInbox"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Announcement>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        announcement,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValue} keyValue Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadAttachment(
      id: string,
      keyValue: KeyValue,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUploadAttachment(
          id,
          keyValue,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTApi.runUploadAttachment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ANNOUNCEMENTApi - factory interface
 * @export
 */
export const ANNOUNCEMENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ANNOUNCEMENTApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .announcementControllerSetStatusConfirm(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .announcementControllerSetStatusDraft(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    announcementControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .announcementControllerSetStatusVoid(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AnnouncementAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Announcement> {
      return localVarFp
        .runCreate(announcement, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Announcement> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Announcement> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttachment(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .runGetAttachment(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetInboxList(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SystemInboxResponse>> {
      return localVarFp
        .runGetInboxList(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserAnnouncement(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AnnouncementResponse>> {
      return localVarFp
        .runGetUserAnnouncement(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserOneAnnouncement(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AnnouncementResponse> {
      return localVarFp
        .runGetUserOneAnnouncement(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetUserOtherAnnouncement(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AnnouncementResponse>> {
      return localVarFp
        .runGetUserOtherAnnouncement(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, announcement, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadAnnouncement(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runReadAnnouncement(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {string} id
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadInbox(
      type: string,
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemInboxResponse> {
      return localVarFp
        .runReadInbox(type, id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Announcement>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Announcement} announcement Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      announcement: Announcement,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, announcement, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValue} keyValue Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadAttachment(
      id: string,
      keyValue: KeyValue,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadAttachment(id, keyValue, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ANNOUNCEMENTApi - object-oriented interface
 * @export
 * @class ANNOUNCEMENTApi
 * @extends {BaseAPI}
 */
export class ANNOUNCEMENTApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public announcementControllerSetStatusConfirm(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .announcementControllerSetStatusConfirm(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public announcementControllerSetStatusDraft(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .announcementControllerSetStatusDraft(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public announcementControllerSetStatusVoid(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .announcementControllerSetStatusVoid(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Announcement} announcement Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runCreate(
    announcement: Announcement,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runCreate(announcement, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runGetAttachment(id: string, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runGetAttachment(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runGetInboxList(options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runGetInboxList(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runGetUserAnnouncement(options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runGetUserAnnouncement(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runGetUserOneAnnouncement(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runGetUserOneAnnouncement(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runGetUserOtherAnnouncement(options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runGetUserOtherAnnouncement(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Announcement} announcement Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runPatch(
    id: string,
    announcement: Announcement,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runPatch(id, announcement, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runReadAnnouncement(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runReadAnnouncement(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} type
   * @param {string} id
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runReadInbox(
    type: string,
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runReadInbox(type, id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Announcement} announcement Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runUpdate(
    id: string,
    announcement: Announcement,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runUpdate(id, announcement, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {KeyValue} keyValue Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTApi
   */
  public runUploadAttachment(
    id: string,
    keyValue: KeyValue,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTApiFp(this.configuration)
      .runUploadAttachment(id, keyValue, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ANNOUNCEMENTTYPEApi - axios parameter creator
 * @export
 */
export const ANNOUNCEMENTTYPEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/announcementtype/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      announcementType: AnnouncementType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'announcementType' is not null or undefined
      assertParamExists("runCreate", "announcementType", announcementType);
      const localVarPath = `/announcementtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcementType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/announcementtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/announcementtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/announcementtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      announcementType: AnnouncementType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'announcementType' is not null or undefined
      assertParamExists("runPatch", "announcementType", announcementType);
      const localVarPath = `/announcementtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcementType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/announcementtype/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/announcementtype/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      announcementType: AnnouncementType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'announcementType' is not null or undefined
      assertParamExists("runUpdate", "announcementType", announcementType);
      const localVarPath = `/announcementtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        announcementType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ANNOUNCEMENTTYPEApi - functional programming interface
 * @export
 */
export const ANNOUNCEMENTTYPEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ANNOUNCEMENTTYPEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AnnouncementTypeAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnnouncementType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        announcementType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnnouncementType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AnnouncementType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        announcementType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AnnouncementType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        announcementType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ANNOUNCEMENTTYPEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ANNOUNCEMENTTYPEApi - factory interface
 * @export
 */
export const ANNOUNCEMENTTYPEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ANNOUNCEMENTTYPEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AnnouncementTypeAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AnnouncementType> {
      return localVarFp
        .runCreate(announcementType, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AnnouncementType> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AnnouncementType> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, announcementType, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AnnouncementType>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AnnouncementType} announcementType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      announcementType: AnnouncementType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, announcementType, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ANNOUNCEMENTTYPEApi - object-oriented interface
 * @export
 * @class ANNOUNCEMENTTYPEApi
 * @extends {BaseAPI}
 */
export class ANNOUNCEMENTTYPEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AnnouncementType} announcementType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runCreate(
    announcementType: AnnouncementType,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runCreate(announcementType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AnnouncementType} announcementType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runPatch(
    id: string,
    announcementType: AnnouncementType,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runPatch(id, announcementType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AnnouncementType} announcementType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ANNOUNCEMENTTYPEApi
   */
  public runUpdate(
    id: string,
    announcementType: AnnouncementType,
    options?: RawAxiosRequestConfig
  ) {
    return ANNOUNCEMENTTYPEApiFp(this.configuration)
      .runUpdate(id, announcementType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * APPINTEGRATIONApi - axios parameter creator
 * @export
 */
export const APPINTEGRATIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/appintegration/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      appIntegration: AppIntegration,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appIntegration' is not null or undefined
      assertParamExists("runCreate", "appIntegration", appIntegration);
      const localVarPath = `/appintegration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegration,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/appintegration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/appintegration/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/appintegration/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      appIntegration: AppIntegration,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'appIntegration' is not null or undefined
      assertParamExists("runPatch", "appIntegration", appIntegration);
      const localVarPath = `/appintegration/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegration,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/appintegration/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRunGetOrgIntegrationData: async (
      appId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("runRunGetOrgIntegrationData", "appId", appId);
      const localVarPath = `/appintegration-api/branch/{appId}`.replace(
        `{${"appId"}}`,
        encodeURIComponent(String(appId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/appintegration/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      appIntegration: AppIntegration,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'appIntegration' is not null or undefined
      assertParamExists("runUpdate", "appIntegration", appIntegration);
      const localVarPath = `/appintegration/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegration,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {string} action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateIntegrationStatus: async (
      appId: string,
      action: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appId' is not null or undefined
      assertParamExists("runUpdateIntegrationStatus", "appId", appId);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("runUpdateIntegrationStatus", "action", action);
      const localVarPath = `/appintegration-api/{appId}/{action}`
        .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * APPINTEGRATIONApi - functional programming interface
 * @export
 */
export const APPINTEGRATIONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    APPINTEGRATIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppIntegrationAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        appIntegration,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        appIntegration,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runRunGetOrgIntegrationData(
      appId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runRunGetOrgIntegrationData(
          appId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runRunGetOrgIntegrationData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppIntegration>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        appIntegration,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {string} action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateIntegrationStatus(
      appId: string,
      action: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateIntegrationStatus(
          appId,
          action,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONApi.runUpdateIntegrationStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * APPINTEGRATIONApi - factory interface
 * @export
 */
export const APPINTEGRATIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = APPINTEGRATIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppIntegrationAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegration> {
      return localVarFp
        .runCreate(appIntegration, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegration> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegration> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, appIntegration, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRunGetOrgIntegrationData(
      appId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegration> {
      return localVarFp
        .runRunGetOrgIntegrationData(appId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppIntegration>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegration} appIntegration Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      appIntegration: AppIntegration,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, appIntegration, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} appId
     * @param {string} action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateIntegrationStatus(
      appId: string,
      action: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegration> {
      return localVarFp
        .runUpdateIntegrationStatus(appId, action, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * APPINTEGRATIONApi - object-oriented interface
 * @export
 * @class APPINTEGRATIONApi
 * @extends {BaseAPI}
 */
export class APPINTEGRATIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AppIntegration} appIntegration Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runCreate(
    appIntegration: AppIntegration,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runCreate(appIntegration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppIntegration} appIntegration Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runPatch(
    id: string,
    appIntegration: AppIntegration,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runPatch(id, appIntegration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} appId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runRunGetOrgIntegrationData(
    appId: string,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runRunGetOrgIntegrationData(appId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppIntegration} appIntegration Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runUpdate(
    id: string,
    appIntegration: AppIntegration,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runUpdate(id, appIntegration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} appId
   * @param {string} action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONApi
   */
  public runUpdateIntegrationStatus(
    appId: string,
    action: string,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONApiFp(this.configuration)
      .runUpdateIntegrationStatus(appId, action, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * APPINTEGRATIONLOGApi - axios parameter creator
 * @export
 */
export const APPINTEGRATIONLOGApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/appintegrationlog/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      appIntegrationLog: AppIntegrationLog,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appIntegrationLog' is not null or undefined
      assertParamExists("runCreate", "appIntegrationLog", appIntegrationLog);
      const localVarPath = `/appintegrationlog`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegrationLog,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/appintegrationlog`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/appintegrationlog/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/appintegrationlog/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'appIntegrationLog' is not null or undefined
      assertParamExists("runPatch", "appIntegrationLog", appIntegrationLog);
      const localVarPath = `/appintegrationlog/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegrationLog,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/appintegrationlog/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/appintegrationlog/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'appIntegrationLog' is not null or undefined
      assertParamExists("runUpdate", "appIntegrationLog", appIntegrationLog);
      const localVarPath = `/appintegrationlog/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appIntegrationLog,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * APPINTEGRATIONLOGApi - functional programming interface
 * @export
 */
export const APPINTEGRATIONLOGApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    APPINTEGRATIONLOGApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppIntegrationLogAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppIntegrationLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        appIntegrationLog,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppIntegrationLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppIntegrationLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        appIntegrationLog,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppIntegrationLog>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        appIntegrationLog,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPINTEGRATIONLOGApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * APPINTEGRATIONLOGApi - factory interface
 * @export
 */
export const APPINTEGRATIONLOGApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = APPINTEGRATIONLOGApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppIntegrationLogAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegrationLog> {
      return localVarFp
        .runCreate(appIntegrationLog, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegrationLog> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppIntegrationLog> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, appIntegrationLog, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppIntegrationLog>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppIntegrationLog} appIntegrationLog Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      appIntegrationLog: AppIntegrationLog,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, appIntegrationLog, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * APPINTEGRATIONLOGApi - object-oriented interface
 * @export
 * @class APPINTEGRATIONLOGApi
 * @extends {BaseAPI}
 */
export class APPINTEGRATIONLOGApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AppIntegrationLog} appIntegrationLog Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runCreate(
    appIntegrationLog: AppIntegrationLog,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runCreate(appIntegrationLog, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppIntegrationLog} appIntegrationLog Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runPatch(
    id: string,
    appIntegrationLog: AppIntegrationLog,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runPatch(id, appIntegrationLog, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppIntegrationLog} appIntegrationLog Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPINTEGRATIONLOGApi
   */
  public runUpdate(
    id: string,
    appIntegrationLog: AppIntegrationLog,
    options?: RawAxiosRequestConfig
  ) {
    return APPINTEGRATIONLOGApiFp(this.configuration)
      .runUpdate(id, appIntegrationLog, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * APPUSERANNOUNCEMENTVIEWApi - axios parameter creator
 * @export
 */
export const APPUSERANNOUNCEMENTVIEWApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/appuserannouncementview/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      appUserAnnouncementView: AppUserAnnouncementView,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appUserAnnouncementView' is not null or undefined
      assertParamExists(
        "runCreate",
        "appUserAnnouncementView",
        appUserAnnouncementView
      );
      const localVarPath = `/appuserannouncementview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appUserAnnouncementView,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/appuserannouncementview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/appuserannouncementview/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/appuserannouncementview/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'appUserAnnouncementView' is not null or undefined
      assertParamExists(
        "runPatch",
        "appUserAnnouncementView",
        appUserAnnouncementView
      );
      const localVarPath = `/appuserannouncementview/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appUserAnnouncementView,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/appuserannouncementview/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/appuserannouncementview/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'appUserAnnouncementView' is not null or undefined
      assertParamExists(
        "runUpdate",
        "appUserAnnouncementView",
        appUserAnnouncementView
      );
      const localVarPath = `/appuserannouncementview/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appUserAnnouncementView,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * APPUSERANNOUNCEMENTVIEWApi - functional programming interface
 * @export
 */
export const APPUSERANNOUNCEMENTVIEWApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    APPUSERANNOUNCEMENTVIEWApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppUserAnnouncementViewAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppUserAnnouncementView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        appUserAnnouncementView,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppUserAnnouncementView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AppUserAnnouncementView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        appUserAnnouncementView,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AppUserAnnouncementView>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        appUserAnnouncementView,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["APPUSERANNOUNCEMENTVIEWApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * APPUSERANNOUNCEMENTVIEWApi - factory interface
 * @export
 */
export const APPUSERANNOUNCEMENTVIEWApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = APPUSERANNOUNCEMENTVIEWApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppUserAnnouncementViewAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppUserAnnouncementView> {
      return localVarFp
        .runCreate(appUserAnnouncementView, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppUserAnnouncementView> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AppUserAnnouncementView> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, appUserAnnouncementView, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AppUserAnnouncementView>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {AppUserAnnouncementView} appUserAnnouncementView Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      appUserAnnouncementView: AppUserAnnouncementView,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, appUserAnnouncementView, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * APPUSERANNOUNCEMENTVIEWApi - object-oriented interface
 * @export
 * @class APPUSERANNOUNCEMENTVIEWApi
 * @extends {BaseAPI}
 */
export class APPUSERANNOUNCEMENTVIEWApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {AppUserAnnouncementView} appUserAnnouncementView Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runCreate(
    appUserAnnouncementView: AppUserAnnouncementView,
    options?: RawAxiosRequestConfig
  ) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runCreate(appUserAnnouncementView, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppUserAnnouncementView} appUserAnnouncementView Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runPatch(
    id: string,
    appUserAnnouncementView: AppUserAnnouncementView,
    options?: RawAxiosRequestConfig
  ) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runPatch(id, appUserAnnouncementView, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {AppUserAnnouncementView} appUserAnnouncementView Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APPUSERANNOUNCEMENTVIEWApi
   */
  public runUpdate(
    id: string,
    appUserAnnouncementView: AppUserAnnouncementView,
    options?: RawAxiosRequestConfig
  ) {
    return APPUSERANNOUNCEMENTVIEWApiFp(this.configuration)
      .runUpdate(id, appUserAnnouncementView, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AREAApi - axios parameter creator
 * @export
 */
export const AREAApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/area/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      area: Area,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'area' is not null or undefined
      assertParamExists("runCreate", "area", area);
      const localVarPath = `/area`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        area,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/area`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/area/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/area/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      area: Area,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'area' is not null or undefined
      assertParamExists("runPatch", "area", area);
      const localVarPath = `/area/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        area,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/area/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/area/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      area: Area,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'area' is not null or undefined
      assertParamExists("runUpdate", "area", area);
      const localVarPath = `/area/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        area,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AREAApi - functional programming interface
 * @export
 */
export const AREAApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AREAApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AreaAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      area: Area,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        area,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runDefault"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Area>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runFindOne"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      area: Area,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        area,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Area>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      area: Area,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        area,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AREAApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AREAApi - factory interface
 * @export
 */
export const AREAApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AREAApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AreaAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(area: Area, options?: RawAxiosRequestConfig): AxiosPromise<Area> {
      return localVarFp
        .runCreate(area, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Area> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Area> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      area: Area,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, area, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Area>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Area} area Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      area: Area,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, area, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * AREAApi - object-oriented interface
 * @export
 * @class AREAApi
 * @extends {BaseAPI}
 */
export class AREAApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return AREAApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Area} area Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runCreate(area: Area, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runCreate(area, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Area} area Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runPatch(id: string, area: Area, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runPatch(id, area, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AREAApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Area} area Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AREAApi
   */
  public runUpdate(id: string, area: Area, options?: RawAxiosRequestConfig) {
    return AREAApiFp(this.configuration)
      .runUpdate(id, area, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * BILLINGSCHEDULEApi - axios parameter creator
 * @export
 */
export const BILLINGSCHEDULEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/billingschedule/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      billingSchedule: BillingSchedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'billingSchedule' is not null or undefined
      assertParamExists("runCreate", "billingSchedule", billingSchedule);
      const localVarPath = `/billingschedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        billingSchedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/billingschedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/billingschedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/billingschedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      billingSchedule: BillingSchedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'billingSchedule' is not null or undefined
      assertParamExists("runPatch", "billingSchedule", billingSchedule);
      const localVarPath = `/billingschedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        billingSchedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/billingschedule/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/billingschedule/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      billingSchedule: BillingSchedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'billingSchedule' is not null or undefined
      assertParamExists("runUpdate", "billingSchedule", billingSchedule);
      const localVarPath = `/billingschedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        billingSchedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BILLINGSCHEDULEApi - functional programming interface
 * @export
 */
export const BILLINGSCHEDULEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BILLINGSCHEDULEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BillingScheduleAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BillingSchedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        billingSchedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BillingSchedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BillingSchedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        billingSchedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BillingSchedule>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        billingSchedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BILLINGSCHEDULEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BILLINGSCHEDULEApi - factory interface
 * @export
 */
export const BILLINGSCHEDULEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BILLINGSCHEDULEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BillingScheduleAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BillingSchedule> {
      return localVarFp
        .runCreate(billingSchedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BillingSchedule> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BillingSchedule> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, billingSchedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BillingSchedule>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {BillingSchedule} billingSchedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      billingSchedule: BillingSchedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, billingSchedule, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * BILLINGSCHEDULEApi - object-oriented interface
 * @export
 * @class BILLINGSCHEDULEApi
 * @extends {BaseAPI}
 */
export class BILLINGSCHEDULEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {BillingSchedule} billingSchedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runCreate(
    billingSchedule: BillingSchedule,
    options?: RawAxiosRequestConfig
  ) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runCreate(billingSchedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {BillingSchedule} billingSchedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runPatch(
    id: string,
    billingSchedule: BillingSchedule,
    options?: RawAxiosRequestConfig
  ) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runPatch(id, billingSchedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {BillingSchedule} billingSchedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BILLINGSCHEDULEApi
   */
  public runUpdate(
    id: string,
    billingSchedule: BillingSchedule,
    options?: RawAxiosRequestConfig
  ) {
    return BILLINGSCHEDULEApiFp(this.configuration)
      .runUpdate(id, billingSchedule, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * BRANCHApi - axios parameter creator
 * @export
 */
export const BRANCHApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/branch/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      branch: Branch,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'branch' is not null or undefined
      assertParamExists("runCreate", "branch", branch);
      const localVarPath = `/branch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        branch,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/branch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/branch/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/branch/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPhoto", "id", id);
      const localVarPath = `/branch-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      branch: Branch,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'branch' is not null or undefined
      assertParamExists("runPatch", "branch", branch);
      const localVarPath = `/branch/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        branch,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/branch/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/branch/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      branch: Branch,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'branch' is not null or undefined
      assertParamExists("runUpdate", "branch", branch);
      const localVarPath = `/branch/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        branch,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto: async (
      id: string,
      uploadPhoto: UploadPhoto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadPhoto", "id", id);
      // verify required parameter 'uploadPhoto' is not null or undefined
      assertParamExists("runUploadPhoto", "uploadPhoto", uploadPhoto);
      const localVarPath = `/branch-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadPhoto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BRANCHApi - functional programming interface
 * @export
 */
export const BRANCHApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BRANCHApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BranchAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        branch,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetPhoto(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runGetPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        branch,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        branch,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUploadPhoto(
        id,
        uploadPhoto,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["BRANCHApi.runUploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BRANCHApi - factory interface
 * @export
 */
export const BRANCHApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BRANCHApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BranchAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Branch> {
      return localVarFp
        .runCreate(branch, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Branch> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Branch> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .runGetPhoto(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, branch, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Branch>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Branch} branch Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      branch: Branch,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, branch, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadPhoto(id, uploadPhoto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * BRANCHApi - object-oriented interface
 * @export
 * @class BRANCHApi
 * @extends {BaseAPI}
 */
export class BRANCHApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return BRANCHApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Branch} branch Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runCreate(branch: Branch, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runCreate(branch, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runGetPhoto(id: string, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runGetPhoto(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Branch} branch Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runPatch(id: string, branch: Branch, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runPatch(id, branch, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BRANCHApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return BRANCHApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Branch} branch Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runUpdate(
    id: string,
    branch: Branch,
    options?: RawAxiosRequestConfig
  ) {
    return BRANCHApiFp(this.configuration)
      .runUpdate(id, branch, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UploadPhoto} uploadPhoto Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BRANCHApi
   */
  public runUploadPhoto(
    id: string,
    uploadPhoto: UploadPhoto,
    options?: RawAxiosRequestConfig
  ) {
    return BRANCHApiFp(this.configuration)
      .runUploadPhoto(id, uploadPhoto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CATEGORYApi - axios parameter creator
 * @export
 */
export const CATEGORYApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/category/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/category-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      category: Category,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists("runCreate", "category", category);
      const localVarPath = `/category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        category,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/category`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/category/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/category/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      category: Category,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'category' is not null or undefined
      assertParamExists("runPatch", "category", category);
      const localVarPath = `/category/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        category,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/category/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/category/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      category: Category,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'category' is not null or undefined
      assertParamExists("runUpdate", "category", category);
      const localVarPath = `/category/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        category,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CATEGORYApi - functional programming interface
 * @export
 */
export const CATEGORYApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CATEGORYApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CategoryAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      category: Category,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        category,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      category: Category,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        category,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Category>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      category: Category,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        category,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CATEGORYApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CATEGORYApi - factory interface
 * @export
 */
export const CATEGORYApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CATEGORYApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CategoryAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      category: Category,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Category> {
      return localVarFp
        .runCreate(category, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Category> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Category> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      category: Category,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, category, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Category>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Category} category Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      category: Category,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, category, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * CATEGORYApi - object-oriented interface
 * @export
 * @class CATEGORYApi
 * @extends {BaseAPI}
 */
export class CATEGORYApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CATEGORYApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return CATEGORYApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Category} category Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runCreate(category: Category, options?: RawAxiosRequestConfig) {
    return CATEGORYApiFp(this.configuration)
      .runCreate(category, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return CATEGORYApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return CATEGORYApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return CATEGORYApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Category} category Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runPatch(
    id: string,
    category: Category,
    options?: RawAxiosRequestConfig
  ) {
    return CATEGORYApiFp(this.configuration)
      .runPatch(id, category, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CATEGORYApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return CATEGORYApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Category} category Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CATEGORYApi
   */
  public runUpdate(
    id: string,
    category: Category,
    options?: RawAxiosRequestConfig
  ) {
    return CATEGORYApiFp(this.configuration)
      .runUpdate(id, category, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CREDITNOTEApi - axios parameter creator
 * @export
 */
export const CREDITNOTEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/creditnote/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusConfirm: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusConfirm", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusConfirm", "body", body);
      const localVarPath = `/creditnote/{id}/set-confirm`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusDraft: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusDraft", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusDraft", "body", body);
      const localVarPath = `/creditnote/{id}/set-draft`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusVoid: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusVoid", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("creditNoteControllerSetStatusVoid", "body", body);
      const localVarPath = `/creditnote/{id}/set-void`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      creditNote: CreditNote,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'creditNote' is not null or undefined
      assertParamExists("runCreate", "creditNote", creditNote);
      const localVarPath = `/creditnote`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        creditNote,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/creditnote`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/creditnote/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/creditnote/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      creditNote: CreditNote,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'creditNote' is not null or undefined
      assertParamExists("runPatch", "creditNote", creditNote);
      const localVarPath = `/creditnote/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        creditNote,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/creditnote/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint: async (
      id: string,
      formatId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPrint", "id", id);
      // verify required parameter 'formatId' is not null or undefined
      assertParamExists("runPrint", "formatId", formatId);
      const localVarPath = `/creditnote-api/{id}/print/{formatId}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"formatId"}}`, encodeURIComponent(String(formatId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/creditnote/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      creditNote: CreditNote,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'creditNote' is not null or undefined
      assertParamExists("runUpdate", "creditNote", creditNote);
      const localVarPath = `/creditnote/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        creditNote,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CREDITNOTEApi - functional programming interface
 * @export
 */
export const CREDITNOTEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CREDITNOTEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CreditNoteAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async creditNoteControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.creditNoteControllerSetStatusConfirm(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "CREDITNOTEApi.creditNoteControllerSetStatusConfirm"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async creditNoteControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.creditNoteControllerSetStatusDraft(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "CREDITNOTEApi.creditNoteControllerSetStatusDraft"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async creditNoteControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.creditNoteControllerSetStatusVoid(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.creditNoteControllerSetStatusVoid"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditNote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        creditNote,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditNote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditNote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        creditNote,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPrint(
        id,
        formatId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runPrint"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CreditNote>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        creditNote,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CREDITNOTEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CREDITNOTEApi - factory interface
 * @export
 */
export const CREDITNOTEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CREDITNOTEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CreditNoteAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .creditNoteControllerSetStatusConfirm(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .creditNoteControllerSetStatusDraft(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    creditNoteControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .creditNoteControllerSetStatusVoid(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreditNote> {
      return localVarFp
        .runCreate(creditNote, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreditNote> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CreditNote> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, creditNote, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runPrint(id, formatId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CreditNote>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CreditNote} creditNote Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      creditNote: CreditNote,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, creditNote, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * CREDITNOTEApi - object-oriented interface
 * @export
 * @class CREDITNOTEApi
 * @extends {BaseAPI}
 */
export class CREDITNOTEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public creditNoteControllerSetStatusConfirm(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .creditNoteControllerSetStatusConfirm(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public creditNoteControllerSetStatusDraft(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .creditNoteControllerSetStatusDraft(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public creditNoteControllerSetStatusVoid(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .creditNoteControllerSetStatusVoid(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CreditNote} creditNote Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runCreate(creditNote: CreditNote, options?: RawAxiosRequestConfig) {
    return CREDITNOTEApiFp(this.configuration)
      .runCreate(creditNote, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return CREDITNOTEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return CREDITNOTEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return CREDITNOTEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CreditNote} creditNote Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runPatch(
    id: string,
    creditNote: CreditNote,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .runPatch(id, creditNote, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} formatId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runPrint(
    id: string,
    formatId: string,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .runPrint(id, formatId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return CREDITNOTEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CreditNote} creditNote Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CREDITNOTEApi
   */
  public runUpdate(
    id: string,
    creditNote: CreditNote,
    options?: RawAxiosRequestConfig
  ) {
    return CREDITNOTEApiFp(this.configuration)
      .runUpdate(id, creditNote, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CUSTOMFIELDApi - axios parameter creator
 * @export
 */
export const CUSTOMFIELDApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/customfield/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      customField: CustomField,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'customField' is not null or undefined
      assertParamExists("runCreate", "customField", customField);
      const localVarPath = `/customfield`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customField,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/customfield`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/customfield/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/customfield/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      customField: CustomField,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'customField' is not null or undefined
      assertParamExists("runPatch", "customField", customField);
      const localVarPath = `/customfield/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customField,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/customfield/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/customfield/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      customField: CustomField,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'customField' is not null or undefined
      assertParamExists("runUpdate", "customField", customField);
      const localVarPath = `/customfield/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customField,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CUSTOMFIELDApi - functional programming interface
 * @export
 */
export const CUSTOMFIELDApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CUSTOMFIELDApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CustomFieldAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        customField,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        customField,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CustomField>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        customField,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMFIELDApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CUSTOMFIELDApi - factory interface
 * @export
 */
export const CUSTOMFIELDApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CUSTOMFIELDApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CustomFieldAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomField> {
      return localVarFp
        .runCreate(customField, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomField> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomField> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, customField, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CustomField>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomField} customField Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      customField: CustomField,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, customField, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * CUSTOMFIELDApi - object-oriented interface
 * @export
 * @class CUSTOMFIELDApi
 * @extends {BaseAPI}
 */
export class CUSTOMFIELDApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMFIELDApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CustomField} customField Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runCreate(customField: CustomField, options?: RawAxiosRequestConfig) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runCreate(customField, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CustomField} customField Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runPatch(
    id: string,
    customField: CustomField,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runPatch(id, customField, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CustomField} customField Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMFIELDApi
   */
  public runUpdate(
    id: string,
    customField: CustomField,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMFIELDApiFp(this.configuration)
      .runUpdate(id, customField, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CUSTOMIZEPRINTFORMATApi - axios parameter creator
 * @export
 */
export const CUSTOMIZEPRINTFORMATApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/customizeprintformat/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      customizePrintFormat: CustomizePrintFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'customizePrintFormat' is not null or undefined
      assertParamExists(
        "runCreate",
        "customizePrintFormat",
        customizePrintFormat
      );
      const localVarPath = `/customizeprintformat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customizePrintFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/customizeprintformat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/customizeprintformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/customizeprintformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/customizeprintformat/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'customizePrintFormat' is not null or undefined
      assertParamExists(
        "runPatch",
        "customizePrintFormat",
        customizePrintFormat
      );
      const localVarPath = `/customizeprintformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customizePrintFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/customizeprintformat/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/customizeprintformat/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'customizePrintFormat' is not null or undefined
      assertParamExists(
        "runUpdate",
        "customizePrintFormat",
        customizePrintFormat
      );
      const localVarPath = `/customizeprintformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        customizePrintFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CUSTOMIZEPRINTFORMATApi - functional programming interface
 * @export
 */
export const CUSTOMIZEPRINTFORMATApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    CUSTOMIZEPRINTFORMATApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CustomizePrintFormatAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CustomizePrintFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        customizePrintFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CustomizePrintFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CustomizePrintFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CustomizePrintFormat>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        customizePrintFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CustomizePrintFormat>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        customizePrintFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CUSTOMIZEPRINTFORMATApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CUSTOMIZEPRINTFORMATApi - factory interface
 * @export
 */
export const CUSTOMIZEPRINTFORMATApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CUSTOMIZEPRINTFORMATApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CustomizePrintFormatAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomizePrintFormat> {
      return localVarFp
        .runCreate(customizePrintFormat, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomizePrintFormat> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CustomizePrintFormat> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CustomizePrintFormat>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, customizePrintFormat, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CustomizePrintFormat>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {CustomizePrintFormat} customizePrintFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      customizePrintFormat: CustomizePrintFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, customizePrintFormat, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * CUSTOMIZEPRINTFORMATApi - object-oriented interface
 * @export
 * @class CUSTOMIZEPRINTFORMATApi
 * @extends {BaseAPI}
 */
export class CUSTOMIZEPRINTFORMATApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CustomizePrintFormat} customizePrintFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runCreate(
    customizePrintFormat: CustomizePrintFormat,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runCreate(customizePrintFormat, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CustomizePrintFormat} customizePrintFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runPatch(
    id: string,
    customizePrintFormat: CustomizePrintFormat,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runPatch(id, customizePrintFormat, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {CustomizePrintFormat} customizePrintFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CUSTOMIZEPRINTFORMATApi
   */
  public runUpdate(
    id: string,
    customizePrintFormat: CustomizePrintFormat,
    options?: RawAxiosRequestConfig
  ) {
    return CUSTOMIZEPRINTFORMATApiFp(this.configuration)
      .runUpdate(id, customizePrintFormat, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DEVELOPERPORTALApi - axios parameter creator
 * @export
 */
export const DEVELOPERPORTALApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperInstalledXOrgs: async (
      developerPortalAppId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'developerPortalAppId' is not null or undefined
      assertParamExists(
        "runDeveloperInstalledXOrgs",
        "developerPortalAppId",
        developerPortalAppId
      );
      const localVarPath =
        `/developer/installed-xorgs/{developerPortalAppId}`.replace(
          `{${"developerPortalAppId"}}`,
          encodeURIComponent(String(developerPortalAppId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperPublish: async (
      developerPortalAppId: string,
      miniApp: MiniApp,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'developerPortalAppId' is not null or undefined
      assertParamExists(
        "runDeveloperPublish",
        "developerPortalAppId",
        developerPortalAppId
      );
      // verify required parameter 'miniApp' is not null or undefined
      assertParamExists("runDeveloperPublish", "miniApp", miniApp);
      const localVarPath = `/developer/publish/{developerPortalAppId}`.replace(
        `{${"developerPortalAppId"}}`,
        encodeURIComponent(String(developerPortalAppId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniApp,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperPublishDev: async (
      developerPortalAppId: string,
      miniApp: MiniApp,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'developerPortalAppId' is not null or undefined
      assertParamExists(
        "runDeveloperPublishDev",
        "developerPortalAppId",
        developerPortalAppId
      );
      // verify required parameter 'miniApp' is not null or undefined
      assertParamExists("runDeveloperPublishDev", "miniApp", miniApp);
      const localVarPath =
        `/developer/publish-dev/{developerPortalAppId}`.replace(
          `{${"developerPortalAppId"}}`,
          encodeURIComponent(String(developerPortalAppId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniApp,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DEVELOPERPORTALApi - functional programming interface
 * @export
 */
export const DEVELOPERPORTALApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DEVELOPERPORTALApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDeveloperInstalledXOrgs(
      developerPortalAppId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DeveloperPortalInstalledXOrgsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDeveloperInstalledXOrgs(
          developerPortalAppId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DEVELOPERPORTALApi.runDeveloperInstalledXOrgs"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDeveloperPublish(
      developerPortalAppId: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniApp>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDeveloperPublish(
          developerPortalAppId,
          miniApp,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DEVELOPERPORTALApi.runDeveloperPublish"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDeveloperPublishDev(
      developerPortalAppId: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniApp>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDeveloperPublishDev(
          developerPortalAppId,
          miniApp,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DEVELOPERPORTALApi.runDeveloperPublishDev"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DEVELOPERPORTALApi - factory interface
 * @export
 */
export const DEVELOPERPORTALApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DEVELOPERPORTALApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperInstalledXOrgs(
      developerPortalAppId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DeveloperPortalInstalledXOrgsResponse> {
      return localVarFp
        .runDeveloperInstalledXOrgs(developerPortalAppId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperPublish(
      developerPortalAppId: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniApp> {
      return localVarFp
        .runDeveloperPublish(developerPortalAppId, miniApp, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} developerPortalAppId
     * @param {MiniApp} miniApp Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDeveloperPublishDev(
      developerPortalAppId: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniApp> {
      return localVarFp
        .runDeveloperPublishDev(developerPortalAppId, miniApp, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * DEVELOPERPORTALApi - object-oriented interface
 * @export
 * @class DEVELOPERPORTALApi
 * @extends {BaseAPI}
 */
export class DEVELOPERPORTALApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {string} developerPortalAppId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DEVELOPERPORTALApi
   */
  public runDeveloperInstalledXOrgs(
    developerPortalAppId: string,
    options?: RawAxiosRequestConfig
  ) {
    return DEVELOPERPORTALApiFp(this.configuration)
      .runDeveloperInstalledXOrgs(developerPortalAppId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} developerPortalAppId
   * @param {MiniApp} miniApp Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DEVELOPERPORTALApi
   */
  public runDeveloperPublish(
    developerPortalAppId: string,
    miniApp: MiniApp,
    options?: RawAxiosRequestConfig
  ) {
    return DEVELOPERPORTALApiFp(this.configuration)
      .runDeveloperPublish(developerPortalAppId, miniApp, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} developerPortalAppId
   * @param {MiniApp} miniApp Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DEVELOPERPORTALApi
   */
  public runDeveloperPublishDev(
    developerPortalAppId: string,
    miniApp: MiniApp,
    options?: RawAxiosRequestConfig
  ) {
    return DEVELOPERPORTALApiFp(this.configuration)
      .runDeveloperPublishDev(developerPortalAppId, miniApp, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DOCUMENTNOFORMATApi - axios parameter creator
 * @export
 */
export const DOCUMENTNOFORMATApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/documentnoformat/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      documentNoFormat: DocumentNoFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'documentNoFormat' is not null or undefined
      assertParamExists("runCreate", "documentNoFormat", documentNoFormat);
      const localVarPath = `/documentnoformat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentNoFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/documentnoformat`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/documentnoformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/documentnoformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} doctype
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runListDocFormats: async (
      doctype: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'doctype' is not null or undefined
      assertParamExists("runListDocFormats", "doctype", doctype);
      const localVarPath =
        `/documentnoformat-api/listdocformats/{doctype}`.replace(
          `{${"doctype"}}`,
          encodeURIComponent(String(doctype))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      documentNoFormat: DocumentNoFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'documentNoFormat' is not null or undefined
      assertParamExists("runPatch", "documentNoFormat", documentNoFormat);
      const localVarPath = `/documentnoformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentNoFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/documentnoformat/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/documentnoformat/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      documentNoFormat: DocumentNoFormat,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'documentNoFormat' is not null or undefined
      assertParamExists("runUpdate", "documentNoFormat", documentNoFormat);
      const localVarPath = `/documentnoformat/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        documentNoFormat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DOCUMENTNOFORMATApi - functional programming interface
 * @export
 */
export const DOCUMENTNOFORMATApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DOCUMENTNOFORMATApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentNoFormatAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DocumentNoFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        documentNoFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DocumentNoFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DocumentNoFormat>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} doctype
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runListDocFormats(
      doctype: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentNoFormat>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runListDocFormats(doctype, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runListDocFormats"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        documentNoFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentNoFormat>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        documentNoFormat,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DOCUMENTNOFORMATApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DOCUMENTNOFORMATApi - factory interface
 * @export
 */
export const DOCUMENTNOFORMATApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DOCUMENTNOFORMATApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<DocumentNoFormatAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DocumentNoFormat> {
      return localVarFp
        .runCreate(documentNoFormat, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DocumentNoFormat> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DocumentNoFormat> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} doctype
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runListDocFormats(
      doctype: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<DocumentNoFormat>> {
      return localVarFp
        .runListDocFormats(doctype, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, documentNoFormat, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<DocumentNoFormat>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {DocumentNoFormat} documentNoFormat Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      documentNoFormat: DocumentNoFormat,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, documentNoFormat, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * DOCUMENTNOFORMATApi - object-oriented interface
 * @export
 * @class DOCUMENTNOFORMATApi
 * @extends {BaseAPI}
 */
export class DOCUMENTNOFORMATApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {DocumentNoFormat} documentNoFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runCreate(
    documentNoFormat: DocumentNoFormat,
    options?: RawAxiosRequestConfig
  ) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runCreate(documentNoFormat, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} doctype
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runListDocFormats(doctype: string, options?: RawAxiosRequestConfig) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runListDocFormats(doctype, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {DocumentNoFormat} documentNoFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runPatch(
    id: string,
    documentNoFormat: DocumentNoFormat,
    options?: RawAxiosRequestConfig
  ) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runPatch(id, documentNoFormat, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {DocumentNoFormat} documentNoFormat Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DOCUMENTNOFORMATApi
   */
  public runUpdate(
    id: string,
    documentNoFormat: DocumentNoFormat,
    options?: RawAxiosRequestConfig
  ) {
    return DOCUMENTNOFORMATApiFp(this.configuration)
      .runUpdate(id, documentNoFormat, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerGetHello(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.appControllerGetHello(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["DefaultApi.appControllerGetHello"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .appControllerGetHello(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerGetHello(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerGetHello(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EINVOICEApi - axios parameter creator
 * @export
 */
export const EINVOICEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {EinvoiceCancelRequest} einvoiceCancelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCancelEinvoice: async (
      einvoiceCancelRequest: EinvoiceCancelRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'einvoiceCancelRequest' is not null or undefined
      assertParamExists(
        "runCancelEinvoice",
        "einvoiceCancelRequest",
        einvoiceCancelRequest
      );
      const localVarPath = `/einvoice/cancelEinvoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        einvoiceCancelRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} datefrom
     * @param {string} dateto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDetails: async (
      datefrom: string,
      dateto: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'datefrom' is not null or undefined
      assertParamExists("runGetDashboardDetails", "datefrom", datefrom);
      // verify required parameter 'dateto' is not null or undefined
      assertParamExists("runGetDashboardDetails", "dateto", dateto);
      const localVarPath = `/einvoice/dashboard/{datefrom}/{dateto}`
        .replace(`{${"datefrom"}}`, encodeURIComponent(String(datefrom)))
        .replace(`{${"dateto"}}`, encodeURIComponent(String(dateto)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDocList: async (
      type: string,
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists("runGetDashboardDocList", "type", type);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runGetDashboardDocList", "requestBody", requestBody);
      const localVarPath = `/einvoice/dashboard/docList/{type}`.replace(
        `{${"type"}}`,
        encodeURIComponent(String(type))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {EinvoiceDashboardSync} einvoiceDashboardSync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDocSync: async (
      einvoiceDashboardSync: EinvoiceDashboardSync,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'einvoiceDashboardSync' is not null or undefined
      assertParamExists(
        "runGetDashboardDocSync",
        "einvoiceDashboardSync",
        einvoiceDashboardSync
      );
      const localVarPath = `/einvoice/dashboard/synchronized`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        einvoiceDashboardSync,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} document
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEinvoiceSummary: async (
      document: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'document' is not null or undefined
      assertParamExists("runGetEinvoiceSummary", "document", document);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetEinvoiceSummary", "id", id);
      const localVarPath = `/einvoice/summary/{document}/{id}`
        .replace(`{${"document"}}`, encodeURIComponent(String(document)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetFileName: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/einvoice/filename`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetURL: async (
      id: string,
      type: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetURL", "id", id);
      // verify required parameter 'type' is not null or undefined
      assertParamExists("runGetURL", "type", type);
      const localVarPath = `/einvoice/{id}/{type}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"type"}}`, encodeURIComponent(String(type)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EINVOICEApi - functional programming interface
 * @export
 */
export const EINVOICEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EINVOICEApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {EinvoiceCancelRequest} einvoiceCancelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCancelEinvoice(
      einvoiceCancelRequest: EinvoiceCancelRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCancelEinvoice(
          einvoiceCancelRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runCancelEinvoice"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} datefrom
     * @param {string} dateto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetDashboardDetails(
      datefrom: string,
      dateto: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EinvoiceDashboardDataList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetDashboardDetails(
          datefrom,
          dateto,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetDashboardDetails"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetDashboardDocList(
      type: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<EinvoiceDashboardDocList>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetDashboardDocList(
          type,
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetDashboardDocList"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {EinvoiceDashboardSync} einvoiceDashboardSync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetDashboardDocSync(
      einvoiceDashboardSync: EinvoiceDashboardSync,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetDashboardDocSync(
          einvoiceDashboardSync,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetDashboardDocSync"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} document
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetEinvoiceSummary(
      document: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EinvoiceRecordSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetEinvoiceSummary(
          document,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetEinvoiceSummary"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetFileName(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MicroFrontendAssetsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetFileName(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetFileName"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetURL(
      id: string,
      type: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EinvoiceRecordURLResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetURL(
        id,
        type,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["EINVOICEApi.runGetURL"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * EINVOICEApi - factory interface
 * @export
 */
export const EINVOICEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EINVOICEApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {EinvoiceCancelRequest} einvoiceCancelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCancelEinvoice(
      einvoiceCancelRequest: EinvoiceCancelRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runCancelEinvoice(einvoiceCancelRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} datefrom
     * @param {string} dateto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDetails(
      datefrom: string,
      dateto: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EinvoiceDashboardDataList> {
      return localVarFp
        .runGetDashboardDetails(datefrom, dateto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} type
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDocList(
      type: string,
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<EinvoiceDashboardDocList>> {
      return localVarFp
        .runGetDashboardDocList(type, requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {EinvoiceDashboardSync} einvoiceDashboardSync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDashboardDocSync(
      einvoiceDashboardSync: EinvoiceDashboardSync,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runGetDashboardDocSync(einvoiceDashboardSync, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} document
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEinvoiceSummary(
      document: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EinvoiceRecordSummary> {
      return localVarFp
        .runGetEinvoiceSummary(document, id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetFileName(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MicroFrontendAssetsResponse> {
      return localVarFp
        .runGetFileName(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetURL(
      id: string,
      type: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EinvoiceRecordURLResponse> {
      return localVarFp
        .runGetURL(id, type, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * EINVOICEApi - object-oriented interface
 * @export
 * @class EINVOICEApi
 * @extends {BaseAPI}
 */
export class EINVOICEApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {EinvoiceCancelRequest} einvoiceCancelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runCancelEinvoice(
    einvoiceCancelRequest: EinvoiceCancelRequest,
    options?: RawAxiosRequestConfig
  ) {
    return EINVOICEApiFp(this.configuration)
      .runCancelEinvoice(einvoiceCancelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} datefrom
   * @param {string} dateto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetDashboardDetails(
    datefrom: string,
    dateto: string,
    options?: RawAxiosRequestConfig
  ) {
    return EINVOICEApiFp(this.configuration)
      .runGetDashboardDetails(datefrom, dateto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} type
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetDashboardDocList(
    type: string,
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return EINVOICEApiFp(this.configuration)
      .runGetDashboardDocList(type, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {EinvoiceDashboardSync} einvoiceDashboardSync
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetDashboardDocSync(
    einvoiceDashboardSync: EinvoiceDashboardSync,
    options?: RawAxiosRequestConfig
  ) {
    return EINVOICEApiFp(this.configuration)
      .runGetDashboardDocSync(einvoiceDashboardSync, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} document
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetEinvoiceSummary(
    document: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return EINVOICEApiFp(this.configuration)
      .runGetEinvoiceSummary(document, id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetFileName(options?: RawAxiosRequestConfig) {
    return EINVOICEApiFp(this.configuration)
      .runGetFileName(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EINVOICEApi
   */
  public runGetURL(id: string, type: string, options?: RawAxiosRequestConfig) {
    return EINVOICEApiFp(this.configuration)
      .runGetURL(id, type, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ENROLLMENTApi - axios parameter creator
 * @export
 */
export const ENROLLMENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/enrollment/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      enrollment: Enrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'enrollment' is not null or undefined
      assertParamExists("runCreate", "enrollment", enrollment);
      const localVarPath = `/enrollment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/enrollment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/enrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/enrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollmentSchedules: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetEnrollmentSchedules", "id", id);
      const localVarPath = `/enrollment-api/{id}/enrollment-schedules`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      enrollment: Enrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'enrollment' is not null or undefined
      assertParamExists("runPatch", "enrollment", enrollment);
      const localVarPath = `/enrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/enrollment/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRemoveClassReplacement: async (
      id: string,
      scheduleId: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runRemoveClassReplacement", "id", id);
      // verify required parameter 'scheduleId' is not null or undefined
      assertParamExists("runRemoveClassReplacement", "scheduleId", scheduleId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runRemoveClassReplacement", "body", body);
      const localVarPath =
        `/enrollment-api/{id}/remove-replacement/{scheduleId}`
          .replace(`{${"id"}}`, encodeURIComponent(String(id)))
          .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {ScheduleAttendanceReplacement} scheduleAttendanceReplacement Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReplaceClass: async (
      id: string,
      scheduleId: string,
      scheduleAttendanceReplacement: ScheduleAttendanceReplacement,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runReplaceClass", "id", id);
      // verify required parameter 'scheduleId' is not null or undefined
      assertParamExists("runReplaceClass", "scheduleId", scheduleId);
      // verify required parameter 'scheduleAttendanceReplacement' is not null or undefined
      assertParamExists(
        "runReplaceClass",
        "scheduleAttendanceReplacement",
        scheduleAttendanceReplacement
      );
      const localVarPath = `/enrollment-api/{id}/replace-class/{scheduleId}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleAttendanceReplacement,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRestartEnrollment: async (
      id: string,
      enrollment: Enrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runRestartEnrollment", "id", id);
      // verify required parameter 'enrollment' is not null or undefined
      assertParamExists("runRestartEnrollment", "enrollment", enrollment);
      const localVarPath = `/enrollment-api/{id}/restart`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/enrollment/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStopEnrollment: async (
      id: string,
      enrollment: Enrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runStopEnrollment", "id", id);
      // verify required parameter 'enrollment' is not null or undefined
      assertParamExists("runStopEnrollment", "enrollment", enrollment);
      const localVarPath = `/enrollment-api/{id}/stop`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      enrollment: Enrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'enrollment' is not null or undefined
      assertParamExists("runUpdate", "enrollment", enrollment);
      const localVarPath = `/enrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        enrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ENROLLMENTApi - functional programming interface
 * @export
 */
export const ENROLLMENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ENROLLMENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<EnrollmentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        enrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetEnrollmentSchedules(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EnrollmentSchedules>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetEnrollmentSchedules(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runGetEnrollmentSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        enrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runRemoveClassReplacement(
      id: string,
      scheduleId: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runRemoveClassReplacement(
          id,
          scheduleId,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runRemoveClassReplacement"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {ScheduleAttendanceReplacement} scheduleAttendanceReplacement Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReplaceClass(
      id: string,
      scheduleId: string,
      scheduleAttendanceReplacement: ScheduleAttendanceReplacement,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runReplaceClass(
        id,
        scheduleId,
        scheduleAttendanceReplacement,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runReplaceClass"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runRestartEnrollment(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runRestartEnrollment(
          id,
          enrollment,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runRestartEnrollment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Enrollment>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runStopEnrollment(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runStopEnrollment(
          id,
          enrollment,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runStopEnrollment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        enrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ENROLLMENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ENROLLMENTApi - factory interface
 * @export
 */
export const ENROLLMENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ENROLLMENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<EnrollmentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Enrollment> {
      return localVarFp
        .runCreate(enrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Enrollment> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Enrollment> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollmentSchedules(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EnrollmentSchedules> {
      return localVarFp
        .runGetEnrollmentSchedules(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, enrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRemoveClassReplacement(
      id: string,
      scheduleId: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runRemoveClassReplacement(id, scheduleId, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} scheduleId
     * @param {ScheduleAttendanceReplacement} scheduleAttendanceReplacement Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReplaceClass(
      id: string,
      scheduleId: string,
      scheduleAttendanceReplacement: ScheduleAttendanceReplacement,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runReplaceClass(id, scheduleId, scheduleAttendanceReplacement, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRestartEnrollment(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runRestartEnrollment(id, enrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Enrollment>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStopEnrollment(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runStopEnrollment(id, enrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Enrollment} enrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      enrollment: Enrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, enrollment, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ENROLLMENTApi - object-oriented interface
 * @export
 * @class ENROLLMENTApi
 * @extends {BaseAPI}
 */
export class ENROLLMENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Enrollment} enrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runCreate(enrollment: Enrollment, options?: RawAxiosRequestConfig) {
    return ENROLLMENTApiFp(this.configuration)
      .runCreate(enrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ENROLLMENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ENROLLMENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ENROLLMENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runGetEnrollmentSchedules(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runGetEnrollmentSchedules(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Enrollment} enrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runPatch(
    id: string,
    enrollment: Enrollment,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runPatch(id, enrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} scheduleId
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runRemoveClassReplacement(
    id: string,
    scheduleId: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runRemoveClassReplacement(id, scheduleId, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} scheduleId
   * @param {ScheduleAttendanceReplacement} scheduleAttendanceReplacement Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runReplaceClass(
    id: string,
    scheduleId: string,
    scheduleAttendanceReplacement: ScheduleAttendanceReplacement,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runReplaceClass(id, scheduleId, scheduleAttendanceReplacement, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Enrollment} enrollment Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runRestartEnrollment(
    id: string,
    enrollment: Enrollment,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runRestartEnrollment(id, enrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ENROLLMENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Enrollment} enrollment Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runStopEnrollment(
    id: string,
    enrollment: Enrollment,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runStopEnrollment(id, enrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Enrollment} enrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ENROLLMENTApi
   */
  public runUpdate(
    id: string,
    enrollment: Enrollment,
    options?: RawAxiosRequestConfig
  ) {
    return ENROLLMENTApiFp(this.configuration)
      .runUpdate(id, enrollment, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * HOLIDAYApi - axios parameter creator
 * @export
 */
export const HOLIDAYApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/holiday/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      holiday: Holiday,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'holiday' is not null or undefined
      assertParamExists("runCreate", "holiday", holiday);
      const localVarPath = `/holiday`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        holiday,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/holiday`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/holiday/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/holiday/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHolidays: async (
      month: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'month' is not null or undefined
      assertParamExists("runGetHolidays", "month", month);
      const localVarPath = `/holiday-api/holidays/{month}`.replace(
        `{${"month"}}`,
        encodeURIComponent(String(month))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runIsHoliday: async (
      date: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists("runIsHoliday", "date", date);
      const localVarPath = `/holiday-api/isholiday/{date}`.replace(
        `{${"date"}}`,
        encodeURIComponent(String(date))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      holiday: Holiday,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'holiday' is not null or undefined
      assertParamExists("runPatch", "holiday", holiday);
      const localVarPath = `/holiday/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        holiday,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/holiday/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/holiday/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      holiday: Holiday,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'holiday' is not null or undefined
      assertParamExists("runUpdate", "holiday", holiday);
      const localVarPath = `/holiday/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        holiday,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HOLIDAYApi - functional programming interface
 * @export
 */
export const HOLIDAYApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HOLIDAYApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<HolidayAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Holiday>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        holiday,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Holiday>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Holiday>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetHolidays(
      month: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Holiday>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetHolidays(
        month,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runGetHolidays"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runIsHoliday(
      date: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runIsHoliday(
        date,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runIsHoliday"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        holiday,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Holiday>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        holiday,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HOLIDAYApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HOLIDAYApi - factory interface
 * @export
 */
export const HOLIDAYApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HOLIDAYApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<HolidayAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Holiday> {
      return localVarFp
        .runCreate(holiday, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Holiday> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Holiday> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHolidays(
      month: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Holiday>> {
      return localVarFp
        .runGetHolidays(month, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runIsHoliday(
      date: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<boolean> {
      return localVarFp
        .runIsHoliday(date, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, holiday, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Holiday>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Holiday} holiday Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      holiday: Holiday,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, holiday, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * HOLIDAYApi - object-oriented interface
 * @export
 * @class HOLIDAYApi
 * @extends {BaseAPI}
 */
export class HOLIDAYApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return HOLIDAYApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Holiday} holiday Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runCreate(holiday: Holiday, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runCreate(holiday, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} month
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runGetHolidays(month: string, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runGetHolidays(month, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runIsHoliday(date: string, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runIsHoliday(date, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Holiday} holiday Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runPatch(
    id: string,
    holiday: Holiday,
    options?: RawAxiosRequestConfig
  ) {
    return HOLIDAYApiFp(this.configuration)
      .runPatch(id, holiday, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return HOLIDAYApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return HOLIDAYApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Holiday} holiday Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HOLIDAYApi
   */
  public runUpdate(
    id: string,
    holiday: Holiday,
    options?: RawAxiosRequestConfig
  ) {
    return HOLIDAYApiFp(this.configuration)
      .runUpdate(id, holiday, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * INVOICEApi - axios parameter creator
 * @export
 */
export const INVOICEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/invoice/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusConfirm: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("invoiceControllerSetStatusConfirm", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("invoiceControllerSetStatusConfirm", "body", body);
      const localVarPath = `/invoice/{id}/set-confirm`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusDraft: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("invoiceControllerSetStatusDraft", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("invoiceControllerSetStatusDraft", "body", body);
      const localVarPath = `/invoice/{id}/set-draft`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusVoid: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("invoiceControllerSetStatusVoid", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("invoiceControllerSetStatusVoid", "body", body);
      const localVarPath = `/invoice/{id}/set-void`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      invoice: Invoice,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'invoice' is not null or undefined
      assertParamExists("runCreate", "invoice", invoice);
      const localVarPath = `/invoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        invoice,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/invoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/invoice/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/invoice/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {GenerateBulkInvoice} generateBulkInvoice Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateBulkInvoice: async (
      generateBulkInvoice: GenerateBulkInvoice,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'generateBulkInvoice' is not null or undefined
      assertParamExists(
        "runGenerateBulkInvoice",
        "generateBulkInvoice",
        generateBulkInvoice
      );
      const localVarPath = `/invoice-api/generate-bulk-invoice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateBulkInvoice,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateHistory: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/invoice-api/generate-history`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      invoice: Invoice,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'invoice' is not null or undefined
      assertParamExists("runPatch", "invoice", invoice);
      const localVarPath = `/invoice/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        invoice,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/invoice/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {DateRangeFilter} dateRangeFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrepareBilling: async (
      dateRangeFilter: DateRangeFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateRangeFilter' is not null or undefined
      assertParamExists(
        "runPrepareBilling",
        "dateRangeFilter",
        dateRangeFilter
      );
      const localVarPath = `/invoice-api/prepare-billing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dateRangeFilter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint: async (
      id: string,
      formatId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPrint", "id", id);
      // verify required parameter 'formatId' is not null or undefined
      assertParamExists("runPrint", "formatId", formatId);
      const localVarPath = `/invoice-api/{id}/print/{formatId}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"formatId"}}`, encodeURIComponent(String(formatId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/invoice/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTotalInvoiceAmount: async (
      month: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'month' is not null or undefined
      assertParamExists("runTotalInvoiceAmount", "month", month);
      const localVarPath = `/invoice-api/totalsales/{month}`.replace(
        `{${"month"}}`,
        encodeURIComponent(String(month))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      invoice: Invoice,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'invoice' is not null or undefined
      assertParamExists("runUpdate", "invoice", invoice);
      const localVarPath = `/invoice/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        invoice,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * INVOICEApi - functional programming interface
 * @export
 */
export const INVOICEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = INVOICEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InvoiceAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invoiceControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invoiceControllerSetStatusConfirm(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.invoiceControllerSetStatusConfirm"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invoiceControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invoiceControllerSetStatusDraft(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.invoiceControllerSetStatusDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invoiceControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.invoiceControllerSetStatusVoid(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.invoiceControllerSetStatusVoid"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        invoice,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {GenerateBulkInvoice} generateBulkInvoice Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGenerateBulkInvoice(
      generateBulkInvoice: GenerateBulkInvoice,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueueJobProducerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGenerateBulkInvoice(
          generateBulkInvoice,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runGenerateBulkInvoice"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGenerateHistory(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BulkGenerateInvoiceHistory>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGenerateHistory(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runGenerateHistory"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        invoice,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {DateRangeFilter} dateRangeFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrepareBilling(
      dateRangeFilter: DateRangeFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BillSummaryByStudent>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runPrepareBilling(
          dateRangeFilter,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runPrepareBilling"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPrint(
        id,
        formatId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runPrint"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runTotalInvoiceAmount(
      month: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runTotalInvoiceAmount(month, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runTotalInvoiceAmount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        invoice,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["INVOICEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * INVOICEApi - factory interface
 * @export
 */
export const INVOICEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = INVOICEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<InvoiceAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .invoiceControllerSetStatusConfirm(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .invoiceControllerSetStatusDraft(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invoiceControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .invoiceControllerSetStatusVoid(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Invoice> {
      return localVarFp
        .runCreate(invoice, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Invoice> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Invoice> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {GenerateBulkInvoice} generateBulkInvoice Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateBulkInvoice(
      generateBulkInvoice: GenerateBulkInvoice,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJobProducerResponse> {
      return localVarFp
        .runGenerateBulkInvoice(generateBulkInvoice, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGenerateHistory(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BulkGenerateInvoiceHistory>> {
      return localVarFp
        .runGenerateHistory(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, invoice, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {DateRangeFilter} dateRangeFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrepareBilling(
      dateRangeFilter: DateRangeFilter,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BillSummaryByStudent>> {
      return localVarFp
        .runPrepareBilling(dateRangeFilter, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runPrint(id, formatId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Invoice>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTotalInvoiceAmount(
      month: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<number> {
      return localVarFp
        .runTotalInvoiceAmount(month, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Invoice} invoice Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      invoice: Invoice,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, invoice, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * INVOICEApi - object-oriented interface
 * @export
 * @class INVOICEApi
 * @extends {BaseAPI}
 */
export class INVOICEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public invoiceControllerSetStatusConfirm(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .invoiceControllerSetStatusConfirm(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public invoiceControllerSetStatusDraft(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .invoiceControllerSetStatusDraft(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public invoiceControllerSetStatusVoid(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .invoiceControllerSetStatusVoid(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Invoice} invoice Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runCreate(invoice: Invoice, options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runCreate(invoice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {GenerateBulkInvoice} generateBulkInvoice Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runGenerateBulkInvoice(
    generateBulkInvoice: GenerateBulkInvoice,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runGenerateBulkInvoice(generateBulkInvoice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runGenerateHistory(options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runGenerateHistory(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Invoice} invoice Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runPatch(
    id: string,
    invoice: Invoice,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runPatch(id, invoice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {DateRangeFilter} dateRangeFilter Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runPrepareBilling(
    dateRangeFilter: DateRangeFilter,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runPrepareBilling(dateRangeFilter, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} formatId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runPrint(
    id: string,
    formatId: string,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runPrint(id, formatId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} month
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runTotalInvoiceAmount(month: string, options?: RawAxiosRequestConfig) {
    return INVOICEApiFp(this.configuration)
      .runTotalInvoiceAmount(month, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Invoice} invoice Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof INVOICEApi
   */
  public runUpdate(
    id: string,
    invoice: Invoice,
    options?: RawAxiosRequestConfig
  ) {
    return INVOICEApiFp(this.configuration)
      .runUpdate(id, invoice, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * KEYVALUEPAIRApi - axios parameter creator
 * @export
 */
export const KEYVALUEPAIRApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/keyvaluepair/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      keyValuePair: KeyValuePair,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyValuePair' is not null or undefined
      assertParamExists("runCreate", "keyValuePair", keyValuePair);
      const localVarPath = `/keyvaluepair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        keyValuePair,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/keyvaluepair`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/keyvaluepair/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/keyvaluepair/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      keyValuePair: KeyValuePair,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'keyValuePair' is not null or undefined
      assertParamExists("runPatch", "keyValuePair", keyValuePair);
      const localVarPath = `/keyvaluepair/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        keyValuePair,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/keyvaluepair/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/keyvaluepair/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      keyValuePair: KeyValuePair,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'keyValuePair' is not null or undefined
      assertParamExists("runUpdate", "keyValuePair", keyValuePair);
      const localVarPath = `/keyvaluepair/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        keyValuePair,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * KEYVALUEPAIRApi - functional programming interface
 * @export
 */
export const KEYVALUEPAIRApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    KEYVALUEPAIRApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<KeyValuePairAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyValuePair>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        keyValuePair,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyValuePair>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyValuePair>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        keyValuePair,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<KeyValuePair>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        keyValuePair,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["KEYVALUEPAIRApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * KEYVALUEPAIRApi - factory interface
 * @export
 */
export const KEYVALUEPAIRApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = KEYVALUEPAIRApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<KeyValuePairAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<KeyValuePair> {
      return localVarFp
        .runCreate(keyValuePair, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<KeyValuePair> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<KeyValuePair> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, keyValuePair, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<KeyValuePair>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {KeyValuePair} keyValuePair Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      keyValuePair: KeyValuePair,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, keyValuePair, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * KEYVALUEPAIRApi - object-oriented interface
 * @export
 * @class KEYVALUEPAIRApi
 * @extends {BaseAPI}
 */
export class KEYVALUEPAIRApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {KeyValuePair} keyValuePair Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runCreate(
    keyValuePair: KeyValuePair,
    options?: RawAxiosRequestConfig
  ) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runCreate(keyValuePair, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {KeyValuePair} keyValuePair Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runPatch(
    id: string,
    keyValuePair: KeyValuePair,
    options?: RawAxiosRequestConfig
  ) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runPatch(id, keyValuePair, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {KeyValuePair} keyValuePair Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KEYVALUEPAIRApi
   */
  public runUpdate(
    id: string,
    keyValuePair: KeyValuePair,
    options?: RawAxiosRequestConfig
  ) {
    return KEYVALUEPAIRApiFp(this.configuration)
      .runUpdate(id, keyValuePair, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * LEVELApi - axios parameter creator
 * @export
 */
export const LEVELApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/level/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/level-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      level: Level,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'level' is not null or undefined
      assertParamExists("runCreate", "level", level);
      const localVarPath = `/level`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        level,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/level`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/level/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/level/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/level/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      level: Level,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'level' is not null or undefined
      assertParamExists("runPatch", "level", level);
      const localVarPath = `/level/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        level,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/level/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/level/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SearchLevelWithRelations} searchLevelWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchWithRelation: async (
      searchLevelWithRelations: SearchLevelWithRelations,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchLevelWithRelations' is not null or undefined
      assertParamExists(
        "runSearchWithRelation",
        "searchLevelWithRelations",
        searchLevelWithRelations
      );
      const localVarPath = `/level-api/search-with-relation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchLevelWithRelations,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      level: Level,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'level' is not null or undefined
      assertParamExists("runUpdate", "level", level);
      const localVarPath = `/level/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        level,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LEVELApi - functional programming interface
 * @export
 */
export const LEVELApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LEVELApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LevelAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      level: Level,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Level>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        level,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Level>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Level>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Level>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      level: Level,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        level,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Level>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SearchLevelWithRelations} searchLevelWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearchWithRelation(
      searchLevelWithRelations: SearchLevelWithRelations,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LevelWithRelation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSearchWithRelation(
          searchLevelWithRelations,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runSearchWithRelation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      level: Level,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        level,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LEVELApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LEVELApi - factory interface
 * @export
 */
export const LEVELApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LEVELApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<LevelAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      level: Level,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Level> {
      return localVarFp
        .runCreate(level, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Level> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Level> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Level>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      level: Level,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, level, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Level>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SearchLevelWithRelations} searchLevelWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchWithRelation(
      searchLevelWithRelations: SearchLevelWithRelations,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<LevelWithRelation>> {
      return localVarFp
        .runSearchWithRelation(searchLevelWithRelations, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Level} level Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      level: Level,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, level, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * LEVELApi - object-oriented interface
 * @export
 * @class LEVELApi
 * @extends {BaseAPI}
 */
export class LEVELApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return LEVELApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return LEVELApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Level} level Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runCreate(level: Level, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runCreate(level, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Level} level Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runPatch(id: string, level: Level, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runPatch(id, level, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return LEVELApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SearchLevelWithRelations} searchLevelWithRelations Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runSearchWithRelation(
    searchLevelWithRelations: SearchLevelWithRelations,
    options?: RawAxiosRequestConfig
  ) {
    return LEVELApiFp(this.configuration)
      .runSearchWithRelation(searchLevelWithRelations, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Level} level Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LEVELApi
   */
  public runUpdate(id: string, level: Level, options?: RawAxiosRequestConfig) {
    return LEVELApiFp(this.configuration)
      .runUpdate(id, level, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * LOGApi - axios parameter creator
 * @export
 */
export const LOGApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Search Document Event
     * @summary
     * @param {string} docName
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDocumentEvent: async (
      docName: string,
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'docName' is not null or undefined
      assertParamExists("searchDocumentEvent", "docName", docName);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("searchDocumentEvent", "id", id);
      const localVarPath = `/log/search/{docName}/{id}`
        .replace(`{${"docName"}}`, encodeURIComponent(String(docName)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LOGApi - functional programming interface
 * @export
 */
export const LOGApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LOGApiAxiosParamCreator(configuration);
  return {
    /**
     * Search Document Event
     * @summary
     * @param {string} docName
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDocumentEvent(
      docName: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DocumentEventListItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchDocumentEvent(
          docName,
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LOGApi.searchDocumentEvent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LOGApi - factory interface
 * @export
 */
export const LOGApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LOGApiFp(configuration);
  return {
    /**
     * Search Document Event
     * @summary
     * @param {string} docName
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDocumentEvent(
      docName: string,
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<DocumentEventListItem>> {
      return localVarFp
        .searchDocumentEvent(docName, id, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * LOGApi - object-oriented interface
 * @export
 * @class LOGApi
 * @extends {BaseAPI}
 */
export class LOGApi extends BaseAPI {
  /**
   * Search Document Event
   * @summary
   * @param {string} docName
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LOGApi
   */
  public searchDocumentEvent(
    docName: string,
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return LOGApiFp(this.configuration)
      .searchDocumentEvent(docName, id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MINIAPPApi - axios parameter creator
 * @export
 */
export const MINIAPPApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/miniapp/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      miniApp: MiniApp,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniApp' is not null or undefined
      assertParamExists("runCreate", "miniApp", miniApp);
      const localVarPath = `/miniapp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniApp,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/miniapp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/miniapp/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/miniapp/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      miniApp: MiniApp,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'miniApp' is not null or undefined
      assertParamExists("runPatch", "miniApp", miniApp);
      const localVarPath = `/miniapp/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniApp,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/miniapp/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/miniapp/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      miniApp: MiniApp,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'miniApp' is not null or undefined
      assertParamExists("runUpdate", "miniApp", miniApp);
      const localVarPath = `/miniapp/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniApp,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MINIAPPApi - functional programming interface
 * @export
 */
export const MINIAPPApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MINIAPPApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MiniAppAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniApp>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        miniApp,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniApp>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniApp>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        miniApp,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MiniApp>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        miniApp,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MINIAPPApi - factory interface
 * @export
 */
export const MINIAPPApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MINIAPPApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MiniAppAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniApp> {
      return localVarFp
        .runCreate(miniApp, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniApp> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniApp> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, miniApp, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MiniApp>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniApp} miniApp Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      miniApp: MiniApp,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, miniApp, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MINIAPPApi - object-oriented interface
 * @export
 * @class MINIAPPApi
 * @extends {BaseAPI}
 */
export class MINIAPPApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {MiniApp} miniApp Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runCreate(miniApp: MiniApp, options?: RawAxiosRequestConfig) {
    return MINIAPPApiFp(this.configuration)
      .runCreate(miniApp, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return MINIAPPApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return MINIAPPApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return MINIAPPApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MiniApp} miniApp Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runPatch(
    id: string,
    miniApp: MiniApp,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPApiFp(this.configuration)
      .runPatch(id, miniApp, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return MINIAPPApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MiniApp} miniApp Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPApi
   */
  public runUpdate(
    id: string,
    miniApp: MiniApp,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPApiFp(this.configuration)
      .runUpdate(id, miniApp, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MINIAPPINSTALLATIONApi - axios parameter creator
 * @export
 */
export const MINIAPPINSTALLATIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/miniappinstallation/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      miniAppInstallation: MiniAppInstallation,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniAppInstallation' is not null or undefined
      assertParamExists(
        "runCreate",
        "miniAppInstallation",
        miniAppInstallation
      );
      const localVarPath = `/miniappinstallation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniAppInstallation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/miniappinstallation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/miniappinstallation/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/miniappinstallation/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'miniAppInstallation' is not null or undefined
      assertParamExists("runPatch", "miniAppInstallation", miniAppInstallation);
      const localVarPath = `/miniappinstallation/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniAppInstallation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/miniappinstallation/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/miniappinstallation/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'miniAppInstallation' is not null or undefined
      assertParamExists(
        "runUpdate",
        "miniAppInstallation",
        miniAppInstallation
      );
      const localVarPath = `/miniappinstallation/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        miniAppInstallation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MINIAPPINSTALLATIONApi - functional programming interface
 * @export
 */
export const MINIAPPINSTALLATIONApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    MINIAPPINSTALLATIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MiniAppInstallationAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        miniAppInstallation,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        miniAppInstallation,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MiniAppInstallation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        miniAppInstallation,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPINSTALLATIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MINIAPPINSTALLATIONApi - factory interface
 * @export
 */
export const MINIAPPINSTALLATIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MINIAPPINSTALLATIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MiniAppInstallationAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runCreate(miniAppInstallation, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, miniAppInstallation, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MiniAppInstallation>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MiniAppInstallation} miniAppInstallation Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      miniAppInstallation: MiniAppInstallation,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, miniAppInstallation, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MINIAPPINSTALLATIONApi - object-oriented interface
 * @export
 * @class MINIAPPINSTALLATIONApi
 * @extends {BaseAPI}
 */
export class MINIAPPINSTALLATIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {MiniAppInstallation} miniAppInstallation Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runCreate(
    miniAppInstallation: MiniAppInstallation,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runCreate(miniAppInstallation, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MiniAppInstallation} miniAppInstallation Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runPatch(
    id: string,
    miniAppInstallation: MiniAppInstallation,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runPatch(id, miniAppInstallation, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MiniAppInstallation} miniAppInstallation Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPINSTALLATIONApi
   */
  public runUpdate(
    id: string,
    miniAppInstallation: MiniAppInstallation,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPINSTALLATIONApiFp(this.configuration)
      .runUpdate(id, miniAppInstallation, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MINIAPPMANAGERApi - axios parameter creator
 * @export
 */
export const MINIAPPMANAGERApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetCategorizedMiniApps: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mini-app-manager/categorized-mini-apps`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetInstalledMiniApps: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mini-app-manager/installed-mini-apps`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetMiniAppDetail: async (
      miniAppCode: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniAppCode' is not null or undefined
      assertParamExists("runGetMiniAppDetail", "miniAppCode", miniAppCode);
      const localVarPath = `/mini-app-manager/mini-apps/{miniAppCode}`.replace(
        `{${"miniAppCode"}}`,
        encodeURIComponent(String(miniAppCode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runInstallMiniApp: async (
      miniAppCode: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniAppCode' is not null or undefined
      assertParamExists("runInstallMiniApp", "miniAppCode", miniAppCode);
      const localVarPath =
        `/mini-app-manager/mini-apps/{miniAppCode}/install`.replace(
          `{${"miniAppCode"}}`,
          encodeURIComponent(String(miniAppCode))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSystemDefaultMiniAppMigration: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mini-app-manager/system-default-mini-apps-migration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUninstallMiniApp: async (
      miniAppCode: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniAppCode' is not null or undefined
      assertParamExists("runUninstallMiniApp", "miniAppCode", miniAppCode);
      const localVarPath =
        `/mini-app-manager/mini-apps/{miniAppCode}/uninstall`.replace(
          `{${"miniAppCode"}}`,
          encodeURIComponent(String(miniAppCode))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateMiniAppSetting: async (
      miniAppCode: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'miniAppCode' is not null or undefined
      assertParamExists("runUpdateMiniAppSetting", "miniAppCode", miniAppCode);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runUpdateMiniAppSetting", "body", body);
      const localVarPath =
        `/mini-app-manager/mini-apps/{miniAppCode}/update-setting`.replace(
          `{${"miniAppCode"}}`,
          encodeURIComponent(String(miniAppCode))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MINIAPPMANAGERApi - functional programming interface
 * @export
 */
export const MINIAPPMANAGERApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MINIAPPMANAGERApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetCategorizedMiniApps(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CategorizedMiniAppDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetCategorizedMiniApps(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runGetCategorizedMiniApps"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetInstalledMiniApps(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InstalledMiniAppDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetInstalledMiniApps(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runGetInstalledMiniApps"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetMiniAppDetail(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MiniAppDetail>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetMiniAppDetail(
          miniAppCode,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runGetMiniAppDetail"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runInstallMiniApp(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runInstallMiniApp(miniAppCode, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runInstallMiniApp"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSystemDefaultMiniAppMigration(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MiniApp>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSystemDefaultMiniAppMigration(
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "MINIAPPMANAGERApi.runSystemDefaultMiniAppMigration"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUninstallMiniApp(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUninstallMiniApp(
          miniAppCode,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runUninstallMiniApp"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateMiniAppSetting(
      miniAppCode: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MiniAppInstallation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateMiniAppSetting(
          miniAppCode,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MINIAPPMANAGERApi.runUpdateMiniAppSetting"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MINIAPPMANAGERApi - factory interface
 * @export
 */
export const MINIAPPMANAGERApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MINIAPPMANAGERApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetCategorizedMiniApps(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CategorizedMiniAppDetail> {
      return localVarFp
        .runGetCategorizedMiniApps(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetInstalledMiniApps(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<InstalledMiniAppDetail> {
      return localVarFp
        .runGetInstalledMiniApps(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetMiniAppDetail(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppDetail> {
      return localVarFp
        .runGetMiniAppDetail(miniAppCode, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runInstallMiniApp(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runInstallMiniApp(miniAppCode, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSystemDefaultMiniAppMigration(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MiniApp>> {
      return localVarFp
        .runSystemDefaultMiniAppMigration(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUninstallMiniApp(
      miniAppCode: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runUninstallMiniApp(miniAppCode, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} miniAppCode
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateMiniAppSetting(
      miniAppCode: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MiniAppInstallation> {
      return localVarFp
        .runUpdateMiniAppSetting(miniAppCode, body, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MINIAPPMANAGERApi - object-oriented interface
 * @export
 * @class MINIAPPMANAGERApi
 * @extends {BaseAPI}
 */
export class MINIAPPMANAGERApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runGetCategorizedMiniApps(options?: RawAxiosRequestConfig) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runGetCategorizedMiniApps(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runGetInstalledMiniApps(options?: RawAxiosRequestConfig) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runGetInstalledMiniApps(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} miniAppCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runGetMiniAppDetail(
    miniAppCode: string,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runGetMiniAppDetail(miniAppCode, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} miniAppCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runInstallMiniApp(
    miniAppCode: string,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runInstallMiniApp(miniAppCode, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runSystemDefaultMiniAppMigration(options?: RawAxiosRequestConfig) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runSystemDefaultMiniAppMigration(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} miniAppCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runUninstallMiniApp(
    miniAppCode: string,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runUninstallMiniApp(miniAppCode, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} miniAppCode
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MINIAPPMANAGERApi
   */
  public runUpdateMiniAppSetting(
    miniAppCode: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return MINIAPPMANAGERApiFp(this.configuration)
      .runUpdateMiniAppSetting(miniAppCode, body, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MOBILEAPPMESSAGEApi - axios parameter creator
 * @export
 */
export const MOBILEAPPMESSAGEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/mobileappmessage/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      mobileAppMessage: MobileAppMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppMessage' is not null or undefined
      assertParamExists("runCreate", "mobileAppMessage", mobileAppMessage);
      const localVarPath = `/mobileappmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobileappmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/mobileappmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/mobileappmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMsglist: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobileappmessage-api/msglist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      mobileAppMessage: MobileAppMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'mobileAppMessage' is not null or undefined
      assertParamExists("runPatch", "mobileAppMessage", mobileAppMessage);
      const localVarPath = `/mobileappmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/mobileappmessage/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadmsg: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runReadmsg", "id", id);
      const localVarPath = `/mobileappmessage-api/{id}/read`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/mobileappmessage/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      mobileAppMessage: MobileAppMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'mobileAppMessage' is not null or undefined
      assertParamExists("runUpdate", "mobileAppMessage", mobileAppMessage);
      const localVarPath = `/mobileappmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MOBILEAPPMESSAGEApi - functional programming interface
 * @export
 */
export const MOBILEAPPMESSAGEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MOBILEAPPMESSAGEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MobileAppMessageAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MobileAppMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        mobileAppMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MobileAppMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MobileAppMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runMsglist(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SystemMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runMsglist(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runMsglist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        mobileAppMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReadmsg(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runReadmsg(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runReadmsg"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MobileAppMessage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        mobileAppMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPMESSAGEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MOBILEAPPMESSAGEApi - factory interface
 * @export
 */
export const MOBILEAPPMESSAGEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MOBILEAPPMESSAGEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MobileAppMessageAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppMessage> {
      return localVarFp
        .runCreate(mobileAppMessage, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppMessage> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppMessage> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMsglist(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SystemMessage>> {
      return localVarFp
        .runMsglist(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, mobileAppMessage, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadmsg(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemMessage> {
      return localVarFp
        .runReadmsg(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MobileAppMessage>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppMessage} mobileAppMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      mobileAppMessage: MobileAppMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, mobileAppMessage, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MOBILEAPPMESSAGEApi - object-oriented interface
 * @export
 * @class MOBILEAPPMESSAGEApi
 * @extends {BaseAPI}
 */
export class MOBILEAPPMESSAGEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {MobileAppMessage} mobileAppMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runCreate(
    mobileAppMessage: MobileAppMessage,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runCreate(mobileAppMessage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runMsglist(options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runMsglist(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MobileAppMessage} mobileAppMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runPatch(
    id: string,
    mobileAppMessage: MobileAppMessage,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runPatch(id, mobileAppMessage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runReadmsg(id: string, options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runReadmsg(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MobileAppMessage} mobileAppMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPMESSAGEApi
   */
  public runUpdate(
    id: string,
    mobileAppMessage: MobileAppMessage,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPMESSAGEApiFp(this.configuration)
      .runUpdate(id, mobileAppMessage, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MOBILEAPPUSERApi - axios parameter creator
 * @export
 */
export const MOBILEAPPUSERApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/mobileappuser/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      mobileAppUser: MobileAppUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mobileAppUser' is not null or undefined
      assertParamExists("runCreate", "mobileAppUser", mobileAppUser);
      const localVarPath = `/mobileappuser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/mobileappuser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/mobileappuser/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/mobileappuser/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      mobileAppUser: MobileAppUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'mobileAppUser' is not null or undefined
      assertParamExists("runPatch", "mobileAppUser", mobileAppUser);
      const localVarPath = `/mobileappuser/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/mobileappuser/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRemoveMessageToken: async (
      tokenCredential: TokenCredential,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenCredential' is not null or undefined
      assertParamExists(
        "runRemoveMessageToken",
        "tokenCredential",
        tokenCredential
      );
      const localVarPath = `/mobileappuser-api/removeMessageToken`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tokenCredential,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSaveMessageToken: async (
      tokenCredential: TokenCredential,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenCredential' is not null or undefined
      assertParamExists(
        "runSaveMessageToken",
        "tokenCredential",
        tokenCredential
      );
      const localVarPath = `/mobileappuser-api/saveMessageToken`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tokenCredential,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/mobileappuser/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      mobileAppUser: MobileAppUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'mobileAppUser' is not null or undefined
      assertParamExists("runUpdate", "mobileAppUser", mobileAppUser);
      const localVarPath = `/mobileappuser/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mobileAppUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MOBILEAPPUSERApi - functional programming interface
 * @export
 */
export const MOBILEAPPUSERApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MOBILEAPPUSERApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MobileAppUserAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileAppUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        mobileAppUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileAppUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MobileAppUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        mobileAppUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runRemoveMessageToken(
      tokenCredential: TokenCredential,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runRemoveMessageToken(
          tokenCredential,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runRemoveMessageToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSaveMessageToken(
      tokenCredential: TokenCredential,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSaveMessageToken(
          tokenCredential,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runSaveMessageToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<MobileAppUser>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        mobileAppUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MOBILEAPPUSERApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MOBILEAPPUSERApi - factory interface
 * @export
 */
export const MOBILEAPPUSERApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MOBILEAPPUSERApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MobileAppUserAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppUser> {
      return localVarFp
        .runCreate(mobileAppUser, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppUser> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MobileAppUser> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, mobileAppUser, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRemoveMessageToken(
      tokenCredential: TokenCredential,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runRemoveMessageToken(tokenCredential, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TokenCredential} tokenCredential Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSaveMessageToken(
      tokenCredential: TokenCredential,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runSaveMessageToken(tokenCredential, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<MobileAppUser>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {MobileAppUser} mobileAppUser Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      mobileAppUser: MobileAppUser,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, mobileAppUser, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MOBILEAPPUSERApi - object-oriented interface
 * @export
 * @class MOBILEAPPUSERApi
 * @extends {BaseAPI}
 */
export class MOBILEAPPUSERApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {MobileAppUser} mobileAppUser Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runCreate(
    mobileAppUser: MobileAppUser,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runCreate(mobileAppUser, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MobileAppUser} mobileAppUser Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runPatch(
    id: string,
    mobileAppUser: MobileAppUser,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runPatch(id, mobileAppUser, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TokenCredential} tokenCredential Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runRemoveMessageToken(
    tokenCredential: TokenCredential,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runRemoveMessageToken(tokenCredential, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TokenCredential} tokenCredential Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runSaveMessageToken(
    tokenCredential: TokenCredential,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runSaveMessageToken(tokenCredential, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {MobileAppUser} mobileAppUser Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MOBILEAPPUSERApi
   */
  public runUpdate(
    id: string,
    mobileAppUser: MobileAppUser,
    options?: RawAxiosRequestConfig
  ) {
    return MOBILEAPPUSERApiFp(this.configuration)
      .runUpdate(id, mobileAppUser, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MaintenanceApi - axios parameter creator
 * @export
 */
export const MaintenanceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerGetUpdate: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/maintenance/get-updates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunGetServiceStatus: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/maintenance/service-status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunStartService: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/maintenance/start-service`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunStopService: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/maintenance/stop-service`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunUpdate: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("maintenanceControllerRunUpdate", "id", id);
      const localVarPath = `/maintenance/run-updates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MaintenanceApi - functional programming interface
 * @export
 */
export const MaintenanceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MaintenanceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async maintenanceControllerGetUpdate(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UpgradeScript>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.maintenanceControllerGetUpdate(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MaintenanceApi.maintenanceControllerGetUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async maintenanceControllerRunGetServiceStatus(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.maintenanceControllerRunGetServiceStatus(
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "MaintenanceApi.maintenanceControllerRunGetServiceStatus"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async maintenanceControllerRunStartService(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.maintenanceControllerRunStartService(
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "MaintenanceApi.maintenanceControllerRunStartService"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async maintenanceControllerRunStopService(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.maintenanceControllerRunStopService(
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "MaintenanceApi.maintenanceControllerRunStopService"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async maintenanceControllerRunUpdate(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.maintenanceControllerRunUpdate(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MaintenanceApi.maintenanceControllerRunUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MaintenanceApi - factory interface
 * @export
 */
export const MaintenanceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MaintenanceApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerGetUpdate(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<UpgradeScript>> {
      return localVarFp
        .maintenanceControllerGetUpdate(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunGetServiceStatus(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<boolean> {
      return localVarFp
        .maintenanceControllerRunGetServiceStatus(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunStartService(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .maintenanceControllerRunStartService(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunStopService(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .maintenanceControllerRunStopService(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    maintenanceControllerRunUpdate(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .maintenanceControllerRunUpdate(id, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MaintenanceApi - object-oriented interface
 * @export
 * @class MaintenanceApi
 * @extends {BaseAPI}
 */
export class MaintenanceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MaintenanceApi
   */
  public maintenanceControllerGetUpdate(options?: RawAxiosRequestConfig) {
    return MaintenanceApiFp(this.configuration)
      .maintenanceControllerGetUpdate(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MaintenanceApi
   */
  public maintenanceControllerRunGetServiceStatus(
    options?: RawAxiosRequestConfig
  ) {
    return MaintenanceApiFp(this.configuration)
      .maintenanceControllerRunGetServiceStatus(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MaintenanceApi
   */
  public maintenanceControllerRunStartService(options?: RawAxiosRequestConfig) {
    return MaintenanceApiFp(this.configuration)
      .maintenanceControllerRunStartService(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MaintenanceApi
   */
  public maintenanceControllerRunStopService(options?: RawAxiosRequestConfig) {
    return MaintenanceApiFp(this.configuration)
      .maintenanceControllerRunStopService(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MaintenanceApi
   */
  public maintenanceControllerRunUpdate(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return MaintenanceApiFp(this.configuration)
      .maintenanceControllerRunUpdate(id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ORGANIZATIONApi - axios parameter creator
 * @export
 */
export const ORGANIZATIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/organization/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      organization: Organization,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'organization' is not null or undefined
      assertParamExists("runCreate", "organization", organization);
      const localVarPath = `/organization`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        organization,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/organization`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/organization/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/organization/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPhoto", "id", id);
      const localVarPath = `/organization-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      organization: Organization,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'organization' is not null or undefined
      assertParamExists("runPatch", "organization", organization);
      const localVarPath = `/organization/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        organization,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/organization/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/organization/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      organization: Organization,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'organization' is not null or undefined
      assertParamExists("runUpdate", "organization", organization);
      const localVarPath = `/organization/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        organization,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto: async (
      id: string,
      uploadPhoto: UploadPhoto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadPhoto", "id", id);
      // verify required parameter 'uploadPhoto' is not null or undefined
      assertParamExists("runUploadPhoto", "uploadPhoto", uploadPhoto);
      const localVarPath = `/organization-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadPhoto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ORGANIZATIONApi - functional programming interface
 * @export
 */
export const ORGANIZATIONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ORGANIZATIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OrganizationAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        organization,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetPhoto(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runGetPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        organization,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Organization>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        organization,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUploadPhoto(
        id,
        uploadPhoto,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ORGANIZATIONApi.runUploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ORGANIZATIONApi - factory interface
 * @export
 */
export const ORGANIZATIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ORGANIZATIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OrganizationAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Organization> {
      return localVarFp
        .runCreate(organization, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Organization> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Organization> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .runGetPhoto(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, organization, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Organization>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Organization} organization Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      organization: Organization,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, organization, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadPhoto(id, uploadPhoto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ORGANIZATIONApi - object-oriented interface
 * @export
 * @class ORGANIZATIONApi
 * @extends {BaseAPI}
 */
export class ORGANIZATIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Organization} organization Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runCreate(
    organization: Organization,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .runCreate(organization, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ORGANIZATIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ORGANIZATIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ORGANIZATIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runGetPhoto(id: string, options?: RawAxiosRequestConfig) {
    return ORGANIZATIONApiFp(this.configuration)
      .runGetPhoto(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Organization} organization Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runPatch(
    id: string,
    organization: Organization,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .runPatch(id, organization, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ORGANIZATIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Organization} organization Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runUpdate(
    id: string,
    organization: Organization,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .runUpdate(id, organization, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UploadPhoto} uploadPhoto Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ORGANIZATIONApi
   */
  public runUploadPhoto(
    id: string,
    uploadPhoto: UploadPhoto,
    options?: RawAxiosRequestConfig
  ) {
    return ORGANIZATIONApiFp(this.configuration)
      .runUploadPhoto(id, uploadPhoto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * OnlinepaymentApi - axios parameter creator
 * @export
 */
export const OnlinepaymentApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Check online payment status
     * @summary
     * @param {string} id The online payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkOnlinePaymentStatus: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("checkOnlinePaymentStatus", "id", id);
      const localVarPath =
        `/onlinepayment/check-online-payment-status/{id}`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get online payment data for monitoring
     * @summary
     * @param {OnlinePaymentFilter} [onlinePaymentFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOnlinePayment: async (
      onlinePaymentFilter?: OnlinePaymentFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/onlinepayment/get-online-payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        onlinePaymentFilter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request online payment for a student
     * @summary
     * @param {RequestOnlinePaymentBody} requestOnlinePaymentBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOnlinePayment: async (
      requestOnlinePaymentBody: RequestOnlinePaymentBody,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestOnlinePaymentBody' is not null or undefined
      assertParamExists(
        "requestOnlinePayment",
        "requestOnlinePaymentBody",
        requestOnlinePaymentBody
      );
      const localVarPath = `/onlinepayment/request-online-payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestOnlinePaymentBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validate online payment for a student
     * @summary
     * @param {string} onlinePaymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateOnlinePayment: async (
      onlinePaymentId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'onlinePaymentId' is not null or undefined
      assertParamExists(
        "validateOnlinePayment",
        "onlinePaymentId",
        onlinePaymentId
      );
      const localVarPath =
        `/onlinepayment/validate-online-payment/{onlinePaymentId}`.replace(
          `{${"onlinePaymentId"}}`,
          encodeURIComponent(String(onlinePaymentId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OnlinepaymentApi - functional programming interface
 * @export
 */
export const OnlinepaymentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OnlinepaymentApiAxiosParamCreator(configuration);
  return {
    /**
     * Check online payment status
     * @summary
     * @param {string} id The online payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkOnlinePaymentStatus(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OnlinePaymentData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkOnlinePaymentStatus(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OnlinepaymentApi.checkOnlinePaymentStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get online payment data for monitoring
     * @summary
     * @param {OnlinePaymentFilter} [onlinePaymentFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOnlinePayment(
      onlinePaymentFilter?: OnlinePaymentFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OnlineMonitoringData>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOnlinePayment(
          onlinePaymentFilter,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OnlinepaymentApi.getOnlinePayment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Request online payment for a student
     * @summary
     * @param {RequestOnlinePaymentBody} requestOnlinePaymentBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestOnlinePayment(
      requestOnlinePaymentBody: RequestOnlinePaymentBody,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RequestOnlinePaymentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestOnlinePayment(
          requestOnlinePaymentBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OnlinepaymentApi.requestOnlinePayment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Validate online payment for a student
     * @summary
     * @param {string} onlinePaymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateOnlinePayment(
      onlinePaymentId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ValidateOnlinePaymentResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.validateOnlinePayment(
          onlinePaymentId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["OnlinepaymentApi.validateOnlinePayment"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OnlinepaymentApi - factory interface
 * @export
 */
export const OnlinepaymentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OnlinepaymentApiFp(configuration);
  return {
    /**
     * Check online payment status
     * @summary
     * @param {string} id The online payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkOnlinePaymentStatus(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<OnlinePaymentData> {
      return localVarFp
        .checkOnlinePaymentStatus(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get online payment data for monitoring
     * @summary
     * @param {OnlinePaymentFilter} [onlinePaymentFilter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOnlinePayment(
      onlinePaymentFilter?: OnlinePaymentFilter,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OnlineMonitoringData>> {
      return localVarFp
        .getOnlinePayment(onlinePaymentFilter, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Request online payment for a student
     * @summary
     * @param {RequestOnlinePaymentBody} requestOnlinePaymentBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOnlinePayment(
      requestOnlinePaymentBody: RequestOnlinePaymentBody,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RequestOnlinePaymentResponse> {
      return localVarFp
        .requestOnlinePayment(requestOnlinePaymentBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Validate online payment for a student
     * @summary
     * @param {string} onlinePaymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateOnlinePayment(
      onlinePaymentId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ValidateOnlinePaymentResponse> {
      return localVarFp
        .validateOnlinePayment(onlinePaymentId, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * OnlinepaymentApi - object-oriented interface
 * @export
 * @class OnlinepaymentApi
 * @extends {BaseAPI}
 */
export class OnlinepaymentApi extends BaseAPI {
  /**
   * Check online payment status
   * @summary
   * @param {string} id The online payment ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnlinepaymentApi
   */
  public checkOnlinePaymentStatus(id: string, options?: RawAxiosRequestConfig) {
    return OnlinepaymentApiFp(this.configuration)
      .checkOnlinePaymentStatus(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get online payment data for monitoring
   * @summary
   * @param {OnlinePaymentFilter} [onlinePaymentFilter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnlinepaymentApi
   */
  public getOnlinePayment(
    onlinePaymentFilter?: OnlinePaymentFilter,
    options?: RawAxiosRequestConfig
  ) {
    return OnlinepaymentApiFp(this.configuration)
      .getOnlinePayment(onlinePaymentFilter, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Request online payment for a student
   * @summary
   * @param {RequestOnlinePaymentBody} requestOnlinePaymentBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnlinepaymentApi
   */
  public requestOnlinePayment(
    requestOnlinePaymentBody: RequestOnlinePaymentBody,
    options?: RawAxiosRequestConfig
  ) {
    return OnlinepaymentApiFp(this.configuration)
      .requestOnlinePayment(requestOnlinePaymentBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Validate online payment for a student
   * @summary
   * @param {string} onlinePaymentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OnlinepaymentApi
   */
  public validateOnlinePayment(
    onlinePaymentId: string,
    options?: RawAxiosRequestConfig
  ) {
    return OnlinepaymentApiFp(this.configuration)
      .validateOnlinePayment(onlinePaymentId, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PARENTApi - axios parameter creator
 * @export
 */
export const PARENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/parent/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      parent: Parent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'parent' is not null or undefined
      assertParamExists("runCreate", "parent", parent);
      const localVarPath = `/parent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        parent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/parent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/parent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/parent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/parent/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentDetails: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetStudentDetails", "id", id);
      const localVarPath = `/parent-api/getChildren/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<ImportParent>} importParent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportParents: async (
      importParent: Array<ImportParent>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'importParent' is not null or undefined
      assertParamExists("runImportParents", "importParent", importParent);
      const localVarPath = `/parent-api/imports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        importParent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      parent: Parent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'parent' is not null or undefined
      assertParamExists("runPatch", "parent", parent);
      const localVarPath = `/parent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        parent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/parent/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/parent/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      parent: Parent,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'parent' is not null or undefined
      assertParamExists("runUpdate", "parent", parent);
      const localVarPath = `/parent/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        parent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PARENTApi - functional programming interface
 * @export
 */
export const PARENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PARENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ParentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        parent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Parent>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetStudentDetails(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetStudentDetails(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runGetStudentDetails"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<ImportParent>} importParent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runImportParents(
      importParent: Array<ImportParent>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ImportErrorMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runImportParents(importParent, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runImportParents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        parent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Parent>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        parent,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PARENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PARENTApi - factory interface
 * @export
 */
export const PARENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PARENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ParentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Parent> {
      return localVarFp
        .runCreate(parent, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Parent> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Parent> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Parent>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentDetails(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Student>> {
      return localVarFp
        .runGetStudentDetails(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<ImportParent>} importParent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportParents(
      importParent: Array<ImportParent>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ImportErrorMessage>> {
      return localVarFp
        .runImportParents(importParent, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, parent, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Parent>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Parent} parent Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      parent: Parent,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, parent, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PARENTApi - object-oriented interface
 * @export
 * @class PARENTApi
 * @extends {BaseAPI}
 */
export class PARENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PARENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Parent} parent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runCreate(parent: Parent, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runCreate(parent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runGetStudentDetails(id: string, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runGetStudentDetails(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<ImportParent>} importParent Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runImportParents(
    importParent: Array<ImportParent>,
    options?: RawAxiosRequestConfig
  ) {
    return PARENTApiFp(this.configuration)
      .runImportParents(importParent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Parent} parent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runPatch(id: string, parent: Parent, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runPatch(id, parent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PARENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PARENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Parent} parent Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PARENTApi
   */
  public runUpdate(
    id: string,
    parent: Parent,
    options?: RawAxiosRequestConfig
  ) {
    return PARENTApiFp(this.configuration)
      .runUpdate(id, parent, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PAYMENTApi - axios parameter creator
 * @export
 */
export const PAYMENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/payment/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusConfirm: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("paymentControllerSetStatusConfirm", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paymentControllerSetStatusConfirm", "body", body);
      const localVarPath = `/payment/{id}/set-confirm`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusDraft: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("paymentControllerSetStatusDraft", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paymentControllerSetStatusDraft", "body", body);
      const localVarPath = `/payment/{id}/set-draft`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusVoid: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("paymentControllerSetStatusVoid", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paymentControllerSetStatusVoid", "body", body);
      const localVarPath = `/payment/{id}/set-void`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      payment: Payment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'payment' is not null or undefined
      assertParamExists("runCreate", "payment", payment);
      const localVarPath = `/payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateOnlinePaymentReceipt: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runCreateOnlinePaymentReceipt", "body", body);
      const localVarPath = `/payment-api/payment/create-online-payment-receipt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/payment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/payment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDailyCollectionByPaymentType: async (
      date: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists("runGetDailyCollectionByPaymentType", "date", date);
      const localVarPath =
        `/payment-api/dailycollectio-bypaymenttype/{date}`.replace(
          `{${"date"}}`,
          encodeURIComponent(String(date))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      payment: Payment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'payment' is not null or undefined
      assertParamExists("runPatch", "payment", payment);
      const localVarPath = `/payment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/payment/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint: async (
      id: string,
      formatId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPrint", "id", id);
      // verify required parameter 'formatId' is not null or undefined
      assertParamExists("runPrint", "formatId", formatId);
      const localVarPath = `/payment-api/{id}/print/{formatId}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"formatId"}}`, encodeURIComponent(String(formatId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRecreateOnlinePaymentReceipt: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runRecreateOnlinePaymentReceipt", "body", body);
      const localVarPath = `/payment-api/payment/recreate-online-payment-receipt`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/payment/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTotalPaymentAmount: async (
      month: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'month' is not null or undefined
      assertParamExists("runTotalPaymentAmount", "month", month);
      const localVarPath = `/payment-api/totalcollection/{month}`.replace(
        `{${"month"}}`,
        encodeURIComponent(String(month))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      payment: Payment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'payment' is not null or undefined
      assertParamExists("runUpdate", "payment", payment);
      const localVarPath = `/payment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PAYMENTApi - functional programming interface
 * @export
 */
export const PAYMENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PAYMENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PaymentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentControllerSetStatusConfirm(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.paymentControllerSetStatusConfirm"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentControllerSetStatusDraft(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.paymentControllerSetStatusDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentControllerSetStatusVoid(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.paymentControllerSetStatusVoid"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        payment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreateOnlinePaymentReceipt(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCreateOnlinePaymentReceipt(
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runCreateOnlinePaymentReceipt"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetDailyCollectionByPaymentType(
      date: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CodeLabelValue>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetDailyCollectionByPaymentType(
          date,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runGetDailyCollectionByPaymentType"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        payment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPrint(
        id,
        formatId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runPrint"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runRecreateOnlinePaymentReceipt(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runRecreateOnlinePaymentReceipt(
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runRecreateOnlinePaymentReceipt"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runTotalPaymentAmount(
      month: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runTotalPaymentAmount(month, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runTotalPaymentAmount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        payment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PAYMENTApi - factory interface
 * @export
 */
export const PAYMENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PAYMENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PaymentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerSetStatusConfirm(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerSetStatusDraft(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerSetStatusVoid(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Payment> {
      return localVarFp
        .runCreate(payment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateOnlinePaymentReceipt(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Payment> {
      return localVarFp
        .runCreateOnlinePaymentReceipt(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Payment> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Payment> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDailyCollectionByPaymentType(
      date: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CodeLabelValue>> {
      return localVarFp
        .runGetDailyCollectionByPaymentType(date, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, payment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runPrint(id, formatId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runRecreateOnlinePaymentReceipt(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Payment> {
      return localVarFp
        .runRecreateOnlinePaymentReceipt(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Payment>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTotalPaymentAmount(
      month: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<number> {
      return localVarFp
        .runTotalPaymentAmount(month, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Payment} payment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      payment: Payment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, payment, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PAYMENTApi - object-oriented interface
 * @export
 * @class PAYMENTApi
 * @extends {BaseAPI}
 */
export class PAYMENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public paymentControllerSetStatusConfirm(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .paymentControllerSetStatusConfirm(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public paymentControllerSetStatusDraft(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .paymentControllerSetStatusDraft(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public paymentControllerSetStatusVoid(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .paymentControllerSetStatusVoid(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Payment} payment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runCreate(payment: Payment, options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runCreate(payment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runCreateOnlinePaymentReceipt(
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runCreateOnlinePaymentReceipt(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runGetDailyCollectionByPaymentType(
    date: string,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runGetDailyCollectionByPaymentType(date, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Payment} payment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runPatch(
    id: string,
    payment: Payment,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runPatch(id, payment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} formatId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runPrint(
    id: string,
    formatId: string,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runPrint(id, formatId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runRecreateOnlinePaymentReceipt(
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runRecreateOnlinePaymentReceipt(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} month
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runTotalPaymentAmount(month: string, options?: RawAxiosRequestConfig) {
    return PAYMENTApiFp(this.configuration)
      .runTotalPaymentAmount(month, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Payment} payment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTApi
   */
  public runUpdate(
    id: string,
    payment: Payment,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTApiFp(this.configuration)
      .runUpdate(id, payment, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PAYMENTMETHODApi - axios parameter creator
 * @export
 */
export const PAYMENTMETHODApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/paymentmethod/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runAccountingPaymentMethod: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/paymentmethod-api/noIsolationSearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      paymentMethod: PaymentMethod,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentMethod' is not null or undefined
      assertParamExists("runCreate", "paymentMethod", paymentMethod);
      const localVarPath = `/paymentmethod`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentMethod,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/paymentmethod`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/paymentmethod/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/paymentmethod/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      paymentMethod: PaymentMethod,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'paymentMethod' is not null or undefined
      assertParamExists("runPatch", "paymentMethod", paymentMethod);
      const localVarPath = `/paymentmethod/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentMethod,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/paymentmethod/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/paymentmethod/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      paymentMethod: PaymentMethod,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'paymentMethod' is not null or undefined
      assertParamExists("runUpdate", "paymentMethod", paymentMethod);
      const localVarPath = `/paymentmethod/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentMethod,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PAYMENTMETHODApi - functional programming interface
 * @export
 */
export const PAYMENTMETHODApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PAYMENTMETHODApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PaymentMethodAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runAccountingPaymentMethod(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PaymentMethod>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runAccountingPaymentMethod(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runAccountingPaymentMethod"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        paymentMethod,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        paymentMethod,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PaymentMethod>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        paymentMethod,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PAYMENTMETHODApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PAYMENTMETHODApi - factory interface
 * @export
 */
export const PAYMENTMETHODApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PAYMENTMETHODApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PaymentMethodAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runAccountingPaymentMethod(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PaymentMethod>> {
      return localVarFp
        .runAccountingPaymentMethod(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PaymentMethod> {
      return localVarFp
        .runCreate(paymentMethod, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PaymentMethod> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PaymentMethod> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, paymentMethod, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PaymentMethod>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PaymentMethod} paymentMethod Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      paymentMethod: PaymentMethod,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, paymentMethod, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PAYMENTMETHODApi - object-oriented interface
 * @export
 * @class PAYMENTMETHODApi
 * @extends {BaseAPI}
 */
export class PAYMENTMETHODApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTMETHODApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runAccountingPaymentMethod(options?: RawAxiosRequestConfig) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runAccountingPaymentMethod(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PaymentMethod} paymentMethod Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runCreate(
    paymentMethod: PaymentMethod,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runCreate(paymentMethod, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {PaymentMethod} paymentMethod Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runPatch(
    id: string,
    paymentMethod: PaymentMethod,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runPatch(id, paymentMethod, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {PaymentMethod} paymentMethod Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PAYMENTMETHODApi
   */
  public runUpdate(
    id: string,
    paymentMethod: PaymentMethod,
    options?: RawAxiosRequestConfig
  ) {
    return PAYMENTMETHODApiFp(this.configuration)
      .runUpdate(id, paymentMethod, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PERMISSIONApi - axios parameter creator
 * @export
 */
export const PERMISSIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/permission/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      permission: Permission,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'permission' is not null or undefined
      assertParamExists("runCreate", "permission", permission);
      const localVarPath = `/permission`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/permission`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/permission/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/permission/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      permission: Permission,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists("runPatch", "permission", permission);
      const localVarPath = `/permission/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/permission/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/permission/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      permission: Permission,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'permission' is not null or undefined
      assertParamExists("runUpdate", "permission", permission);
      const localVarPath = `/permission/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PERMISSIONApi - functional programming interface
 * @export
 */
export const PERMISSIONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PERMISSIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PermissionAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        permission,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        permission,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Permission>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        permission,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PERMISSIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PERMISSIONApi - factory interface
 * @export
 */
export const PERMISSIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PERMISSIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PermissionAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Permission> {
      return localVarFp
        .runCreate(permission, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Permission> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Permission> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, permission, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Permission>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Permission} permission Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      permission: Permission,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, permission, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PERMISSIONApi - object-oriented interface
 * @export
 * @class PERMISSIONApi
 * @extends {BaseAPI}
 */
export class PERMISSIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PERMISSIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Permission} permission Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runCreate(permission: Permission, options?: RawAxiosRequestConfig) {
    return PERMISSIONApiFp(this.configuration)
      .runCreate(permission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PERMISSIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PERMISSIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PERMISSIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Permission} permission Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runPatch(
    id: string,
    permission: Permission,
    options?: RawAxiosRequestConfig
  ) {
    return PERMISSIONApiFp(this.configuration)
      .runPatch(id, permission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PERMISSIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runSearch(body: string, options?: RawAxiosRequestConfig) {
    return PERMISSIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Permission} permission Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PERMISSIONApi
   */
  public runUpdate(
    id: string,
    permission: Permission,
    options?: RawAxiosRequestConfig
  ) {
    return PERMISSIONApiFp(this.configuration)
      .runUpdate(id, permission, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PHOTOApi - axios parameter creator
 * @export
 */
export const PHOTOApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMigrateKeyValuePairToCDN: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runMigrateKeyValuePairToCDN", "body", body);
      const localVarPath = `/photo/migrate-kvp-to-cdn`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PHOTOApi - functional programming interface
 * @export
 */
export const PHOTOApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PHOTOApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runMigrateKeyValuePairToCDN(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runMigrateKeyValuePairToCDN(
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PHOTOApi.runMigrateKeyValuePairToCDN"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PHOTOApi - factory interface
 * @export
 */
export const PHOTOApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PHOTOApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMigrateKeyValuePairToCDN(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runMigrateKeyValuePairToCDN(body, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PHOTOApi - object-oriented interface
 * @export
 * @class PHOTOApi
 * @extends {BaseAPI}
 */
export class PHOTOApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PHOTOApi
   */
  public runMigrateKeyValuePairToCDN(
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PHOTOApiFp(this.configuration)
      .runMigrateKeyValuePairToCDN(body, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PRODUCTApi - axios parameter creator
 * @export
 */
export const PRODUCTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/product/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      product: Product,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'product' is not null or undefined
      assertParamExists("runCreate", "product", product);
      const localVarPath = `/product`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        product,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/product`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/product/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<ImportProduct>} importProduct Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportProducts: async (
      importProduct: Array<ImportProduct>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'importProduct' is not null or undefined
      assertParamExists("runImportProducts", "importProduct", importProduct);
      const localVarPath = `/product-api/imports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        importProduct,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      product: Product,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'product' is not null or undefined
      assertParamExists("runPatch", "product", product);
      const localVarPath = `/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        product,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/product/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/product/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      product: Product,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'product' is not null or undefined
      assertParamExists("runUpdate", "product", product);
      const localVarPath = `/product/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        product,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PRODUCTApi - functional programming interface
 * @export
 */
export const PRODUCTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PRODUCTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProductAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      product: Product,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        product,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<ImportProduct>} importProduct Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runImportProducts(
      importProduct: Array<ImportProduct>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ImportErrorMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runImportProducts(
          importProduct,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runImportProducts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      product: Product,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        product,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      product: Product,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        product,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PRODUCTApi - factory interface
 * @export
 */
export const PRODUCTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PRODUCTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ProductAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      product: Product,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Product> {
      return localVarFp
        .runCreate(product, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Product> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Product> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Product>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<ImportProduct>} importProduct Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportProducts(
      importProduct: Array<ImportProduct>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ImportErrorMessage>> {
      return localVarFp
        .runImportProducts(importProduct, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      product: Product,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, product, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Product>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Product} product Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      product: Product,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, product, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PRODUCTApi - object-oriented interface
 * @export
 * @class PRODUCTApi
 * @extends {BaseAPI}
 */
export class PRODUCTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Product} product Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runCreate(product: Product, options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runCreate(product, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<ImportProduct>} importProduct Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runImportProducts(
    importProduct: Array<ImportProduct>,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTApiFp(this.configuration)
      .runImportProducts(importProduct, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Product} product Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runPatch(
    id: string,
    product: Product,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTApiFp(this.configuration)
      .runPatch(id, product, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PRODUCTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Product} product Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTApi
   */
  public runUpdate(
    id: string,
    product: Product,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTApiFp(this.configuration)
      .runUpdate(id, product, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PRODUCTPACKAGEApi - axios parameter creator
 * @export
 */
export const PRODUCTPACKAGEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/productpackage/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      productPackage: ProductPackage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productPackage' is not null or undefined
      assertParamExists("runCreate", "productPackage", productPackage);
      const localVarPath = `/productpackage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        productPackage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/productpackage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/productpackage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/productpackage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      productPackage: ProductPackage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'productPackage' is not null or undefined
      assertParamExists("runPatch", "productPackage", productPackage);
      const localVarPath = `/productpackage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        productPackage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/productpackage/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/productpackage/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      productPackage: ProductPackage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'productPackage' is not null or undefined
      assertParamExists("runUpdate", "productPackage", productPackage);
      const localVarPath = `/productpackage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        productPackage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PRODUCTPACKAGEApi - functional programming interface
 * @export
 */
export const PRODUCTPACKAGEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PRODUCTPACKAGEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProductPackageAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPackage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        productPackage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPackage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPackage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        productPackage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProductPackage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        productPackage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PRODUCTPACKAGEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PRODUCTPACKAGEApi - factory interface
 * @export
 */
export const PRODUCTPACKAGEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PRODUCTPACKAGEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ProductPackageAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ProductPackage> {
      return localVarFp
        .runCreate(productPackage, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ProductPackage> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ProductPackage> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, productPackage, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ProductPackage>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ProductPackage} productPackage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      productPackage: ProductPackage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, productPackage, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PRODUCTPACKAGEApi - object-oriented interface
 * @export
 * @class PRODUCTPACKAGEApi
 * @extends {BaseAPI}
 */
export class PRODUCTPACKAGEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {ProductPackage} productPackage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runCreate(
    productPackage: ProductPackage,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runCreate(productPackage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ProductPackage} productPackage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runPatch(
    id: string,
    productPackage: ProductPackage,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runPatch(id, productPackage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ProductPackage} productPackage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PRODUCTPACKAGEApi
   */
  public runUpdate(
    id: string,
    productPackage: ProductPackage,
    options?: RawAxiosRequestConfig
  ) {
    return PRODUCTPACKAGEApiFp(this.configuration)
      .runUpdate(id, productPackage, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PROFILEApi - axios parameter creator
 * @export
 */
export const PROFILEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * create new tenant
     * @summary
     * @param {RegTenant} regTenant create tenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant: async (
      regTenant: RegTenant,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regTenant' is not null or undefined
      assertParamExists("createTenant", "regTenant", regTenant);
      const localVarPath = `/profile/tenant`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        regTenant,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * accept or reject invitation to tenant
     * @summary
     * @param {string} id
     * @param {string} decision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decideInvitation: async (
      id: string,
      decision: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("decideInvitation", "id", id);
      // verify required parameter 'decision' is not null or undefined
      assertParamExists("decideInvitation", "decision", decision);
      const localVarPath = `/profile/invitation/{id}/{decision}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"decision"}}`, encodeURIComponent(String(decision)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all tenants
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTenants: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/profile/tenants`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get current user profile
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfile: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/profile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get current user session
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/profile/session`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * complete specific tour guide
     * @summary
     * @param {string} guidename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTourComplete: async (
      guidename: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'guidename' is not null or undefined
      assertParamExists("runTourComplete", "guidename", guidename);
      const localVarPath = `/profile/tour-complete/{guidename}`.replace(
        `{${"guidename"}}`,
        encodeURIComponent(String(guidename))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload avatar image with base64
     * @summary
     * @param {KeyValue} keyValue base64 photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPhoto: async (
      keyValue: KeyValue,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyValue' is not null or undefined
      assertParamExists("uploadPhoto", "keyValue", keyValue);
      const localVarPath = `/profile/photo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        keyValue,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PROFILEApi - functional programming interface
 * @export
 */
export const PROFILEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PROFILEApiAxiosParamCreator(configuration);
  return {
    /**
     * create new tenant
     * @summary
     * @param {RegTenant} regTenant create tenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTenant(
      regTenant: RegTenant,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(
        regTenant,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.createTenant"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * accept or reject invitation to tenant
     * @summary
     * @param {string} id
     * @param {string} decision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decideInvitation(
      id: string,
      decision: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decideInvitation(id, decision, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.decideInvitation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all tenants
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTenants(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllTenants(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.getAllTenants"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get current user profile
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProfile(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserContextInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProfile(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.getProfile"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get current user session
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSession(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSession(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.getSession"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * complete specific tour guide
     * @summary
     * @param {string} guidename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runTourComplete(
      guidename: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runTourComplete(
        guidename,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.runTourComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Upload avatar image with base64
     * @summary
     * @param {KeyValue} keyValue base64 photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadPhoto(
      keyValue: KeyValue,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPhoto(
        keyValue,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PROFILEApi.uploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PROFILEApi - factory interface
 * @export
 */
export const PROFILEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PROFILEApiFp(configuration);
  return {
    /**
     * create new tenant
     * @summary
     * @param {RegTenant} regTenant create tenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant(
      regTenant: RegTenant,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .createTenant(regTenant, options)
        .then(request => request(axios, basePath));
    },
    /**
     * accept or reject invitation to tenant
     * @summary
     * @param {string} id
     * @param {string} decision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decideInvitation(
      id: string,
      decision: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .decideInvitation(id, decision, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get all tenants
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTenants(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .getAllTenants(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get current user profile
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfile(options?: RawAxiosRequestConfig): AxiosPromise<UserContextInfo> {
      return localVarFp
        .getProfile(options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get current user session
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .getSession(options)
        .then(request => request(axios, basePath));
    },
    /**
     * complete specific tour guide
     * @summary
     * @param {string} guidename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runTourComplete(
      guidename: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .runTourComplete(guidename, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Upload avatar image with base64
     * @summary
     * @param {KeyValue} keyValue base64 photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPhoto(
      keyValue: KeyValue,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .uploadPhoto(keyValue, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PROFILEApi - object-oriented interface
 * @export
 * @class PROFILEApi
 * @extends {BaseAPI}
 */
export class PROFILEApi extends BaseAPI {
  /**
   * create new tenant
   * @summary
   * @param {RegTenant} regTenant create tenant name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public createTenant(regTenant: RegTenant, options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .createTenant(regTenant, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * accept or reject invitation to tenant
   * @summary
   * @param {string} id
   * @param {string} decision
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public decideInvitation(
    id: string,
    decision: string,
    options?: RawAxiosRequestConfig
  ) {
    return PROFILEApiFp(this.configuration)
      .decideInvitation(id, decision, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get all tenants
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public getAllTenants(options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .getAllTenants(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get current user profile
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public getProfile(options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .getProfile(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get current user session
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public getSession(options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .getSession(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * complete specific tour guide
   * @summary
   * @param {string} guidename
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public runTourComplete(guidename: string, options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .runTourComplete(guidename, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Upload avatar image with base64
   * @summary
   * @param {KeyValue} keyValue base64 photo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PROFILEApi
   */
  public uploadPhoto(keyValue: KeyValue, options?: RawAxiosRequestConfig) {
    return PROFILEApiFp(this.configuration)
      .uploadPhoto(keyValue, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PUNCHCARDApi - axios parameter creator
 * @export
 */
export const PUNCHCARDApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/punchcard/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      punchCard: PunchCard,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'punchCard' is not null or undefined
      assertParamExists("runCreate", "punchCard", punchCard);
      const localVarPath = `/punchcard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        punchCard,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/punchcard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/punchcard/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/punchcard/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      punchCard: PunchCard,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'punchCard' is not null or undefined
      assertParamExists("runPatch", "punchCard", punchCard);
      const localVarPath = `/punchcard/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        punchCard,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/punchcard/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/punchcard/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      punchCard: PunchCard,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'punchCard' is not null or undefined
      assertParamExists("runUpdate", "punchCard", punchCard);
      const localVarPath = `/punchcard/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        punchCard,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PUNCHCARDApi - functional programming interface
 * @export
 */
export const PUNCHCARDApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PUNCHCARDApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PunchCardAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PunchCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        punchCard,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PunchCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PunchCard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        punchCard,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PunchCard>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        punchCard,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PUNCHCARDApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PUNCHCARDApi - factory interface
 * @export
 */
export const PUNCHCARDApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PUNCHCARDApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PunchCardAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PunchCard> {
      return localVarFp
        .runCreate(punchCard, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PunchCard> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PunchCard> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, punchCard, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PunchCard>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {PunchCard} punchCard Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      punchCard: PunchCard,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, punchCard, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * PUNCHCARDApi - object-oriented interface
 * @export
 * @class PUNCHCARDApi
 * @extends {BaseAPI}
 */
export class PUNCHCARDApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return PUNCHCARDApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PunchCard} punchCard Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runCreate(punchCard: PunchCard, options?: RawAxiosRequestConfig) {
    return PUNCHCARDApiFp(this.configuration)
      .runCreate(punchCard, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return PUNCHCARDApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return PUNCHCARDApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return PUNCHCARDApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {PunchCard} punchCard Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runPatch(
    id: string,
    punchCard: PunchCard,
    options?: RawAxiosRequestConfig
  ) {
    return PUNCHCARDApiFp(this.configuration)
      .runPatch(id, punchCard, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return PUNCHCARDApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return PUNCHCARDApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {PunchCard} punchCard Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PUNCHCARDApi
   */
  public runUpdate(
    id: string,
    punchCard: PunchCard,
    options?: RawAxiosRequestConfig
  ) {
    return PUNCHCARDApiFp(this.configuration)
      .runUpdate(id, punchCard, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * QUEUEJOBApi - axios parameter creator
 * @export
 */
export const QUEUEJOBApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/queuejob/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      queueJob: QueueJob,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueJob' is not null or undefined
      assertParamExists("runCreate", "queueJob", queueJob);
      const localVarPath = `/queuejob`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queueJob,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/queuejob`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/queuejob/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/queuejob/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      queueJob: QueueJob,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'queueJob' is not null or undefined
      assertParamExists("runPatch", "queueJob", queueJob);
      const localVarPath = `/queuejob/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queueJob,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/queuejob/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/queuejob/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      queueJob: QueueJob,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'queueJob' is not null or undefined
      assertParamExists("runUpdate", "queueJob", queueJob);
      const localVarPath = `/queuejob/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queueJob,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QUEUEJOBApi - functional programming interface
 * @export
 */
export const QUEUEJOBApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QUEUEJOBApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<QueueJobAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        queueJob,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        queueJob,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<QueueJob>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        queueJob,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["QUEUEJOBApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * QUEUEJOBApi - factory interface
 * @export
 */
export const QUEUEJOBApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = QUEUEJOBApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<QueueJobAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJob> {
      return localVarFp
        .runCreate(queueJob, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJob> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJob> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, queueJob, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<QueueJob>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {QueueJob} queueJob Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      queueJob: QueueJob,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, queueJob, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * QUEUEJOBApi - object-oriented interface
 * @export
 * @class QUEUEJOBApi
 * @extends {BaseAPI}
 */
export class QUEUEJOBApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return QUEUEJOBApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {QueueJob} queueJob Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runCreate(queueJob: QueueJob, options?: RawAxiosRequestConfig) {
    return QUEUEJOBApiFp(this.configuration)
      .runCreate(queueJob, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return QUEUEJOBApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return QUEUEJOBApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return QUEUEJOBApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {QueueJob} queueJob Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runPatch(
    id: string,
    queueJob: QueueJob,
    options?: RawAxiosRequestConfig
  ) {
    return QUEUEJOBApiFp(this.configuration)
      .runPatch(id, queueJob, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return QUEUEJOBApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return QUEUEJOBApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {QueueJob} queueJob Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QUEUEJOBApi
   */
  public runUpdate(
    id: string,
    queueJob: QueueJob,
    options?: RawAxiosRequestConfig
  ) {
    return QUEUEJOBApiFp(this.configuration)
      .runUpdate(id, queueJob, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * RACEApi - axios parameter creator
 * @export
 */
export const RACEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/race/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/race-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      race: Race,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'race' is not null or undefined
      assertParamExists("runCreate", "race", race);
      const localVarPath = `/race`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        race,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/race`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/race/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/race/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      race: Race,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'race' is not null or undefined
      assertParamExists("runPatch", "race", race);
      const localVarPath = `/race/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        race,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/race/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/race/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      race: Race,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'race' is not null or undefined
      assertParamExists("runUpdate", "race", race);
      const localVarPath = `/race/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        race,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RACEApi - functional programming interface
 * @export
 */
export const RACEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RACEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RaceAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      race: Race,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Race>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        race,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runDefault"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Race>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Race>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runFindOne"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      race: Race,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        race,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Race>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      race: Race,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        race,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RACEApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RACEApi - factory interface
 * @export
 */
export const RACEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RACEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RaceAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(race: Race, options?: RawAxiosRequestConfig): AxiosPromise<Race> {
      return localVarFp
        .runCreate(race, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Race> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Race> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      race: Race,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, race, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Race>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Race} race Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      race: Race,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, race, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * RACEApi - object-oriented interface
 * @export
 * @class RACEApi
 * @extends {BaseAPI}
 */
export class RACEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return RACEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return RACEApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Race} race Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runCreate(race: Race, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runCreate(race, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Race} race Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runPatch(id: string, race: Race, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runPatch(id, race, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RACEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Race} race Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RACEApi
   */
  public runUpdate(id: string, race: Race, options?: RawAxiosRequestConfig) {
    return RACEApiFp(this.configuration)
      .runUpdate(id, race, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * REFUNDApi - axios parameter creator
 * @export
 */
export const REFUNDApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/refund/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusConfirm: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("refundControllerSetStatusConfirm", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("refundControllerSetStatusConfirm", "body", body);
      const localVarPath = `/refund/{id}/set-confirm`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusDraft: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("refundControllerSetStatusDraft", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("refundControllerSetStatusDraft", "body", body);
      const localVarPath = `/refund/{id}/set-draft`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusVoid: async (
      id: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("refundControllerSetStatusVoid", "id", id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("refundControllerSetStatusVoid", "body", body);
      const localVarPath = `/refund/{id}/set-void`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      refund: Refund,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refund' is not null or undefined
      assertParamExists("runCreate", "refund", refund);
      const localVarPath = `/refund`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refund,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/refund`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/refund/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/refund/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      refund: Refund,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'refund' is not null or undefined
      assertParamExists("runPatch", "refund", refund);
      const localVarPath = `/refund/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refund,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/refund/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint: async (
      id: string,
      formatId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPrint", "id", id);
      // verify required parameter 'formatId' is not null or undefined
      assertParamExists("runPrint", "formatId", formatId);
      const localVarPath = `/refund-api/{id}/print/{formatId}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"formatId"}}`, encodeURIComponent(String(formatId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/refund/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      refund: Refund,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'refund' is not null or undefined
      assertParamExists("runUpdate", "refund", refund);
      const localVarPath = `/refund/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refund,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * REFUNDApi - functional programming interface
 * @export
 */
export const REFUNDApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = REFUNDApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RefundAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refundControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.refundControllerSetStatusConfirm(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.refundControllerSetStatusConfirm"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refundControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.refundControllerSetStatusDraft(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.refundControllerSetStatusDraft"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refundControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.refundControllerSetStatusVoid(
          id,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.refundControllerSetStatusVoid"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        refund,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        refund,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPrint(
        id,
        formatId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runPrint"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Refund>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        refund,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * REFUNDApi - factory interface
 * @export
 */
export const REFUNDApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = REFUNDApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RefundAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusConfirm(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .refundControllerSetStatusConfirm(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusDraft(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .refundControllerSetStatusDraft(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {object} body Document data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundControllerSetStatusVoid(
      id: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .refundControllerSetStatusVoid(id, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Refund> {
      return localVarFp
        .runCreate(refund, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Refund> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Refund> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, refund, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {string} formatId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrint(
      id: string,
      formatId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runPrint(id, formatId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Refund>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Refund} refund Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      refund: Refund,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, refund, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * REFUNDApi - object-oriented interface
 * @export
 * @class REFUNDApi
 * @extends {BaseAPI}
 */
export class REFUNDApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public refundControllerSetStatusConfirm(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .refundControllerSetStatusConfirm(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public refundControllerSetStatusDraft(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .refundControllerSetStatusDraft(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {object} body Document data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public refundControllerSetStatusVoid(
    id: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .refundControllerSetStatusVoid(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Refund} refund Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runCreate(refund: Refund, options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runCreate(refund, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Refund} refund Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runPatch(id: string, refund: Refund, options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runPatch(id, refund, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {string} formatId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runPrint(
    id: string,
    formatId: string,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .runPrint(id, formatId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return REFUNDApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Refund} refund Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDApi
   */
  public runUpdate(
    id: string,
    refund: Refund,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDApiFp(this.configuration)
      .runUpdate(id, refund, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * REFUNDTYPEApi - axios parameter creator
 * @export
 */
export const REFUNDTYPEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/refundtype/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      refundType: RefundType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refundType' is not null or undefined
      assertParamExists("runCreate", "refundType", refundType);
      const localVarPath = `/refundtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refundType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/refundtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/refundtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/refundtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      refundType: RefundType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'refundType' is not null or undefined
      assertParamExists("runPatch", "refundType", refundType);
      const localVarPath = `/refundtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refundType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/refundtype/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/refundtype/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      refundType: RefundType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'refundType' is not null or undefined
      assertParamExists("runUpdate", "refundType", refundType);
      const localVarPath = `/refundtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refundType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * REFUNDTYPEApi - functional programming interface
 * @export
 */
export const REFUNDTYPEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    REFUNDTYPEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RefundTypeAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        refundType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        refundType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RefundType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        refundType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["REFUNDTYPEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * REFUNDTYPEApi - factory interface
 * @export
 */
export const REFUNDTYPEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = REFUNDTYPEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RefundTypeAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RefundType> {
      return localVarFp
        .runCreate(refundType, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RefundType> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RefundType> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, refundType, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RefundType>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RefundType} refundType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      refundType: RefundType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, refundType, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * REFUNDTYPEApi - object-oriented interface
 * @export
 * @class REFUNDTYPEApi
 * @extends {BaseAPI}
 */
export class REFUNDTYPEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDTYPEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RefundType} refundType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runCreate(refundType: RefundType, options?: RawAxiosRequestConfig) {
    return REFUNDTYPEApiFp(this.configuration)
      .runCreate(refundType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return REFUNDTYPEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return REFUNDTYPEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return REFUNDTYPEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {RefundType} refundType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runPatch(
    id: string,
    refundType: RefundType,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDTYPEApiFp(this.configuration)
      .runPatch(id, refundType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDTYPEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return REFUNDTYPEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {RefundType} refundType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof REFUNDTYPEApi
   */
  public runUpdate(
    id: string,
    refundType: RefundType,
    options?: RawAxiosRequestConfig
  ) {
    return REFUNDTYPEApiFp(this.configuration)
      .runUpdate(id, refundType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * RELIGIONApi - axios parameter creator
 * @export
 */
export const RELIGIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/religion/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/religion-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      religion: Religion,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'religion' is not null or undefined
      assertParamExists("runCreate", "religion", religion);
      const localVarPath = `/religion`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        religion,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/religion`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/religion/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/religion/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      religion: Religion,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'religion' is not null or undefined
      assertParamExists("runPatch", "religion", religion);
      const localVarPath = `/religion/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        religion,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/religion/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/religion/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      religion: Religion,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'religion' is not null or undefined
      assertParamExists("runUpdate", "religion", religion);
      const localVarPath = `/religion/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        religion,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RELIGIONApi - functional programming interface
 * @export
 */
export const RELIGIONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RELIGIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ReligionAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Religion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        religion,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Religion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Religion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        religion,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Religion>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        religion,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RELIGIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RELIGIONApi - factory interface
 * @export
 */
export const RELIGIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RELIGIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ReligionAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Religion> {
      return localVarFp
        .runCreate(religion, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Religion> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Religion> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, religion, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Religion>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Religion} religion Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      religion: Religion,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, religion, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * RELIGIONApi - object-oriented interface
 * @export
 * @class RELIGIONApi
 * @extends {BaseAPI}
 */
export class RELIGIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return RELIGIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return RELIGIONApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Religion} religion Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runCreate(religion: Religion, options?: RawAxiosRequestConfig) {
    return RELIGIONApiFp(this.configuration)
      .runCreate(religion, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return RELIGIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return RELIGIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return RELIGIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Religion} religion Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runPatch(
    id: string,
    religion: Religion,
    options?: RawAxiosRequestConfig
  ) {
    return RELIGIONApiFp(this.configuration)
      .runPatch(id, religion, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return RELIGIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return RELIGIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Religion} religion Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RELIGIONApi
   */
  public runUpdate(
    id: string,
    religion: Religion,
    options?: RawAxiosRequestConfig
  ) {
    return RELIGIONApiFp(this.configuration)
      .runUpdate(id, religion, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ROOMApi - axios parameter creator
 * @export
 */
export const ROOMApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/room/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      room: Room,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'room' is not null or undefined
      assertParamExists("runCreate", "room", room);
      const localVarPath = `/room`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        room,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/room`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/room/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/room/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      room: Room,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'room' is not null or undefined
      assertParamExists("runPatch", "room", room);
      const localVarPath = `/room/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        room,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/room/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/room/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      room: Room,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'room' is not null or undefined
      assertParamExists("runUpdate", "room", room);
      const localVarPath = `/room/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        room,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ROOMApi - functional programming interface
 * @export
 */
export const ROOMApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ROOMApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RoomAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      room: Room,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        room,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runDefault"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runFindOne"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      room: Room,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        room,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Room>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      room: Room,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        room,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ROOMApi - factory interface
 * @export
 */
export const ROOMApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ROOMApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RoomAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(room: Room, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
      return localVarFp
        .runCreate(room, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Room> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      room: Room,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, room, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Room>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Room} room Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      room: Room,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, room, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ROOMApi - object-oriented interface
 * @export
 * @class ROOMApi
 * @extends {BaseAPI}
 */
export class ROOMApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Room} room Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runCreate(room: Room, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runCreate(room, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Room} room Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runPatch(id: string, room: Room, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runPatch(id, room, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Room} room Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMApi
   */
  public runUpdate(id: string, room: Room, options?: RawAxiosRequestConfig) {
    return ROOMApiFp(this.configuration)
      .runUpdate(id, room, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ROOMTYPEApi - axios parameter creator
 * @export
 */
export const ROOMTYPEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/roomtype/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      roomType: RoomType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'roomType' is not null or undefined
      assertParamExists("runCreate", "roomType", roomType);
      const localVarPath = `/roomtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roomType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roomtype`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/roomtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/roomtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      roomType: RoomType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'roomType' is not null or undefined
      assertParamExists("runPatch", "roomType", roomType);
      const localVarPath = `/roomtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roomType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/roomtype/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/roomtype/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      roomType: RoomType,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'roomType' is not null or undefined
      assertParamExists("runUpdate", "roomType", roomType);
      const localVarPath = `/roomtype/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roomType,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ROOMTYPEApi - functional programming interface
 * @export
 */
export const ROOMTYPEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ROOMTYPEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RoomTypeAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        roomType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        roomType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<RoomType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        roomType,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ROOMTYPEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ROOMTYPEApi - factory interface
 * @export
 */
export const ROOMTYPEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ROOMTYPEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RoomTypeAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RoomType> {
      return localVarFp
        .runCreate(roomType, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RoomType> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<RoomType> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, roomType, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<RoomType>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {RoomType} roomType Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      roomType: RoomType,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, roomType, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ROOMTYPEApi - object-oriented interface
 * @export
 * @class ROOMTYPEApi
 * @extends {BaseAPI}
 */
export class ROOMTYPEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMTYPEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RoomType} roomType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runCreate(roomType: RoomType, options?: RawAxiosRequestConfig) {
    return ROOMTYPEApiFp(this.configuration)
      .runCreate(roomType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return ROOMTYPEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return ROOMTYPEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ROOMTYPEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {RoomType} roomType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runPatch(
    id: string,
    roomType: RoomType,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMTYPEApiFp(this.configuration)
      .runPatch(id, roomType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMTYPEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return ROOMTYPEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {RoomType} roomType Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ROOMTYPEApi
   */
  public runUpdate(
    id: string,
    roomType: RoomType,
    options?: RawAxiosRequestConfig
  ) {
    return ROOMTYPEApiFp(this.configuration)
      .runUpdate(id, roomType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SCHEDULEApi - axios parameter creator
 * @export
 */
export const SCHEDULEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/schedule/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runActivateSchedules: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runActivateSchedules", "requestBody", requestBody);
      const localVarPath = `/schedule-api/activate-schedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      schedule: Schedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schedule' is not null or undefined
      assertParamExists("runCreate", "schedule", schedule);
      const localVarPath = `/schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/schedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/schedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceByWeek: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/schedule-api/attendanceweek`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDailyAbsendStudents: async (
      date: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists("runGetDailyAbsendStudents", "date", date);
      const localVarPath = `/schedule-api/student-attendance/{date}`.replace(
        `{${"date"}}`,
        encodeURIComponent(String(date))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetScheduleByDay: async (
      date: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'date' is not null or undefined
      assertParamExists("runGetScheduleByDay", "date", date);
      const localVarPath = `/schedule-api/date/{date}`.replace(
        `{${"date"}}`,
        encodeURIComponent(String(date))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetScheduleInfo: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetScheduleInfo", "id", id);
      const localVarPath = `/schedule-api/{id}/info`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runInActiveSchedules: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runInActiveSchedules", "requestBody", requestBody);
      const localVarPath = `/schedule-api/inactive-schedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      schedule: Schedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'schedule' is not null or undefined
      assertParamExists("runPatch", "schedule", schedule);
      const localVarPath = `/schedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/schedule/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PrintAttendanceFilter} printAttendanceFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrintAttendance: async (
      printAttendanceFilter: PrintAttendanceFilter,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'printAttendanceFilter' is not null or undefined
      assertParamExists(
        "runPrintAttendance",
        "printAttendanceFilter",
        printAttendanceFilter
      );
      const localVarPath = `/schedule-api/attendance-check-list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        printAttendanceFilter,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/schedule/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} yearmonth
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchSchedulesByMonth: async (
      yearmonth: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'yearmonth' is not null or undefined
      assertParamExists("runSearchSchedulesByMonth", "yearmonth", yearmonth);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearchSchedulesByMonth", "body", body);
      const localVarPath = `/schedule-api/schedules-month/{yearmonth}`.replace(
        `{${"yearmonth"}}`,
        encodeURIComponent(String(yearmonth))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SearchScheduleWithRelations} searchScheduleWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchWithRelation: async (
      searchScheduleWithRelations: SearchScheduleWithRelations,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchScheduleWithRelations' is not null or undefined
      assertParamExists(
        "runSearchWithRelation",
        "searchScheduleWithRelations",
        searchScheduleWithRelations
      );
      const localVarPath = `/schedule-api/search-with-relation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchScheduleWithRelations,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      schedule: Schedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'schedule' is not null or undefined
      assertParamExists("runUpdate", "schedule", schedule);
      const localVarPath = `/schedule/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        schedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Attendance} attendance Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendance: async (
      id: string,
      attendance: Attendance,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdateAttendance", "id", id);
      // verify required parameter 'attendance' is not null or undefined
      assertParamExists("runUpdateAttendance", "attendance", attendance);
      const localVarPath = `/schedule-api/{id}/attendance`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        attendance,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SCHEDULEApi - functional programming interface
 * @export
 */
export const SCHEDULEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SCHEDULEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runActivateSchedules(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runActivateSchedules(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runActivateSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        schedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetAttendanceByWeek(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AttendanceReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetAttendanceByWeek(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runGetAttendanceByWeek"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetDailyAbsendStudents(
      date: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Attendance>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetDailyAbsendStudents(
          date,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runGetDailyAbsendStudents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetScheduleByDay(
      date: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleListItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetScheduleByDay(date, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runGetScheduleByDay"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetScheduleInfo(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attendance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetScheduleInfo(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runGetScheduleInfo"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runInActiveSchedules(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runInActiveSchedules(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runInActiveSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        schedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PrintAttendanceFilter} printAttendanceFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPrintAttendance(
      printAttendanceFilter: PrintAttendanceFilter,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runPrintAttendance(
          printAttendanceFilter,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runPrintAttendance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Schedule>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} yearmonth
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearchSchedulesByMonth(
      yearmonth: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleListItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSearchSchedulesByMonth(
          yearmonth,
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runSearchSchedulesByMonth"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SearchScheduleWithRelations} searchScheduleWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearchWithRelation(
      searchScheduleWithRelations: SearchScheduleWithRelations,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleWithRelation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSearchWithRelation(
          searchScheduleWithRelations,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runSearchWithRelation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        schedule,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Attendance} attendance Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateAttendance(
      id: string,
      attendance: Attendance,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateAttendance(
          id,
          attendance,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEApi.runUpdateAttendance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SCHEDULEApi - factory interface
 * @export
 */
export const SCHEDULEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SCHEDULEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runActivateSchedules(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runActivateSchedules(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Schedule> {
      return localVarFp
        .runCreate(schedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Schedule> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Schedule> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceByWeek(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AttendanceReport> {
      return localVarFp
        .runGetAttendanceByWeek(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetDailyAbsendStudents(
      date: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Attendance>> {
      return localVarFp
        .runGetDailyAbsendStudents(date, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetScheduleByDay(
      date: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleListItem>> {
      return localVarFp
        .runGetScheduleByDay(date, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetScheduleInfo(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Attendance> {
      return localVarFp
        .runGetScheduleInfo(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runInActiveSchedules(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runInActiveSchedules(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, schedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PrintAttendanceFilter} printAttendanceFilter Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPrintAttendance(
      printAttendanceFilter: PrintAttendanceFilter,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runPrintAttendance(printAttendanceFilter, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Schedule>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} yearmonth
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchSchedulesByMonth(
      yearmonth: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleListItem>> {
      return localVarFp
        .runSearchSchedulesByMonth(yearmonth, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SearchScheduleWithRelations} searchScheduleWithRelations Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchWithRelation(
      searchScheduleWithRelations: SearchScheduleWithRelations,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleWithRelation>> {
      return localVarFp
        .runSearchWithRelation(searchScheduleWithRelations, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Schedule} schedule Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      schedule: Schedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, schedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Attendance} attendance Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendance(
      id: string,
      attendance: Attendance,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpdateAttendance(id, attendance, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SCHEDULEApi - object-oriented interface
 * @export
 * @class SCHEDULEApi
 * @extends {BaseAPI}
 */
export class SCHEDULEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runActivateSchedules(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runActivateSchedules(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Schedule} schedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runCreate(schedule: Schedule, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runCreate(schedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runGetAttendanceByWeek(options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runGetAttendanceByWeek(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runGetDailyAbsendStudents(
    date: string,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runGetDailyAbsendStudents(date, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} date
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runGetScheduleByDay(date: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runGetScheduleByDay(date, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runGetScheduleInfo(id: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runGetScheduleInfo(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runInActiveSchedules(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runInActiveSchedules(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Schedule} schedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runPatch(
    id: string,
    schedule: Schedule,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runPatch(id, schedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PrintAttendanceFilter} printAttendanceFilter Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runPrintAttendance(
    printAttendanceFilter: PrintAttendanceFilter,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runPrintAttendance(printAttendanceFilter, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return SCHEDULEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} yearmonth
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runSearchSchedulesByMonth(
    yearmonth: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runSearchSchedulesByMonth(yearmonth, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SearchScheduleWithRelations} searchScheduleWithRelations Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runSearchWithRelation(
    searchScheduleWithRelations: SearchScheduleWithRelations,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runSearchWithRelation(searchScheduleWithRelations, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Schedule} schedule Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runUpdate(
    id: string,
    schedule: Schedule,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runUpdate(id, schedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Attendance} attendance Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEApi
   */
  public runUpdateAttendance(
    id: string,
    attendance: Attendance,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEApiFp(this.configuration)
      .runUpdateAttendance(id, attendance, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SCHEDULEATTENDANCEApi - axios parameter creator
 * @export
 */
export const SCHEDULEATTENDANCEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/scheduleattendance/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      scheduleAttendance: ScheduleAttendance,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'scheduleAttendance' is not null or undefined
      assertParamExists("runCreate", "scheduleAttendance", scheduleAttendance);
      const localVarPath = `/scheduleattendance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleAttendance,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scheduleattendance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/scheduleattendance/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/scheduleattendance/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'scheduleAttendance' is not null or undefined
      assertParamExists("runPatch", "scheduleAttendance", scheduleAttendance);
      const localVarPath = `/scheduleattendance/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleAttendance,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/scheduleattendance/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/scheduleattendance/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'scheduleAttendance' is not null or undefined
      assertParamExists("runUpdate", "scheduleAttendance", scheduleAttendance);
      const localVarPath = `/scheduleattendance/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleAttendance,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SCHEDULEATTENDANCEApi - functional programming interface
 * @export
 */
export const SCHEDULEATTENDANCEApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    SCHEDULEATTENDANCEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleAttendanceAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ScheduleAttendance>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        scheduleAttendance,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ScheduleAttendance>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ScheduleAttendance>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        scheduleAttendance,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleAttendance>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        scheduleAttendance,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHEDULEATTENDANCEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SCHEDULEATTENDANCEApi - factory interface
 * @export
 */
export const SCHEDULEATTENDANCEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SCHEDULEATTENDANCEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleAttendanceAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ScheduleAttendance> {
      return localVarFp
        .runCreate(scheduleAttendance, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ScheduleAttendance> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ScheduleAttendance> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, scheduleAttendance, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleAttendance>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {ScheduleAttendance} scheduleAttendance Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      scheduleAttendance: ScheduleAttendance,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, scheduleAttendance, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SCHEDULEATTENDANCEApi - object-oriented interface
 * @export
 * @class SCHEDULEATTENDANCEApi
 * @extends {BaseAPI}
 */
export class SCHEDULEATTENDANCEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {ScheduleAttendance} scheduleAttendance Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runCreate(
    scheduleAttendance: ScheduleAttendance,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runCreate(scheduleAttendance, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ScheduleAttendance} scheduleAttendance Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runPatch(
    id: string,
    scheduleAttendance: ScheduleAttendance,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runPatch(id, scheduleAttendance, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {ScheduleAttendance} scheduleAttendance Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHEDULEATTENDANCEApi
   */
  public runUpdate(
    id: string,
    scheduleAttendance: ScheduleAttendance,
    options?: RawAxiosRequestConfig
  ) {
    return SCHEDULEATTENDANCEApiFp(this.configuration)
      .runUpdate(id, scheduleAttendance, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SCHOOLApi - axios parameter creator
 * @export
 */
export const SCHOOLApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/school/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/school-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      school: School,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'school' is not null or undefined
      assertParamExists("runCreate", "school", school);
      const localVarPath = `/school`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        school,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/school`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/school/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/school/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      school: School,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'school' is not null or undefined
      assertParamExists("runPatch", "school", school);
      const localVarPath = `/school/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        school,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/school/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/school/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      school: School,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'school' is not null or undefined
      assertParamExists("runUpdate", "school", school);
      const localVarPath = `/school/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        school,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SCHOOLApi - functional programming interface
 * @export
 */
export const SCHOOLApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SCHOOLApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SchoolAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      school: School,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<School>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        school,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<School>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<School>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      school: School,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        school,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<School>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      school: School,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        school,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SCHOOLApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SCHOOLApi - factory interface
 * @export
 */
export const SCHOOLApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SCHOOLApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SchoolAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      school: School,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<School> {
      return localVarFp
        .runCreate(school, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<School> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<School> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      school: School,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, school, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<School>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {School} school Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      school: School,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, school, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SCHOOLApi - object-oriented interface
 * @export
 * @class SCHOOLApi
 * @extends {BaseAPI}
 */
export class SCHOOLApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return SCHOOLApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return SCHOOLApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {School} school Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runCreate(school: School, options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runCreate(school, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {School} school Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runPatch(id: string, school: School, options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runPatch(id, school, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SCHOOLApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return SCHOOLApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {School} school Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SCHOOLApi
   */
  public runUpdate(
    id: string,
    school: School,
    options?: RawAxiosRequestConfig
  ) {
    return SCHOOLApiFp(this.configuration)
      .runUpdate(id, school, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STOPENROLLMENTApi - axios parameter creator
 * @export
 */
export const STOPENROLLMENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/stopenrollment/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      stopEnrollment: StopEnrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stopEnrollment' is not null or undefined
      assertParamExists("runCreate", "stopEnrollment", stopEnrollment);
      const localVarPath = `/stopenrollment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopEnrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stopenrollment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/stopenrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/stopenrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      stopEnrollment: StopEnrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'stopEnrollment' is not null or undefined
      assertParamExists("runPatch", "stopEnrollment", stopEnrollment);
      const localVarPath = `/stopenrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopEnrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/stopenrollment/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/stopenrollment/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      stopEnrollment: StopEnrollment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'stopEnrollment' is not null or undefined
      assertParamExists("runUpdate", "stopEnrollment", stopEnrollment);
      const localVarPath = `/stopenrollment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopEnrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STOPENROLLMENTApi - functional programming interface
 * @export
 */
export const STOPENROLLMENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STOPENROLLMENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StopEnrollmentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopEnrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        stopEnrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopEnrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopEnrollment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        stopEnrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StopEnrollment>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        stopEnrollment,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPENROLLMENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STOPENROLLMENTApi - factory interface
 * @export
 */
export const STOPENROLLMENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STOPENROLLMENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StopEnrollmentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopEnrollment> {
      return localVarFp
        .runCreate(stopEnrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopEnrollment> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopEnrollment> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, stopEnrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StopEnrollment>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopEnrollment} stopEnrollment Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      stopEnrollment: StopEnrollment,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, stopEnrollment, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STOPENROLLMENTApi - object-oriented interface
 * @export
 * @class STOPENROLLMENTApi
 * @extends {BaseAPI}
 */
export class STOPENROLLMENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STOPENROLLMENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StopEnrollment} stopEnrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runCreate(
    stopEnrollment: StopEnrollment,
    options?: RawAxiosRequestConfig
  ) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runCreate(stopEnrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StopEnrollment} stopEnrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runPatch(
    id: string,
    stopEnrollment: StopEnrollment,
    options?: RawAxiosRequestConfig
  ) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runPatch(id, stopEnrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StopEnrollment} stopEnrollment Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPENROLLMENTApi
   */
  public runUpdate(
    id: string,
    stopEnrollment: StopEnrollment,
    options?: RawAxiosRequestConfig
  ) {
    return STOPENROLLMENTApiFp(this.configuration)
      .runUpdate(id, stopEnrollment, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STOPREASONApi - axios parameter creator
 * @export
 */
export const STOPREASONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/stopreason/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      stopReason: StopReason,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stopReason' is not null or undefined
      assertParamExists("runCreate", "stopReason", stopReason);
      const localVarPath = `/stopreason`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopReason,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stopreason`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/stopreason/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/stopreason/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      stopReason: StopReason,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'stopReason' is not null or undefined
      assertParamExists("runPatch", "stopReason", stopReason);
      const localVarPath = `/stopreason/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopReason,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/stopreason/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/stopreason/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      stopReason: StopReason,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'stopReason' is not null or undefined
      assertParamExists("runUpdate", "stopReason", stopReason);
      const localVarPath = `/stopreason/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        stopReason,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STOPREASONApi - functional programming interface
 * @export
 */
export const STOPREASONApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STOPREASONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StopReasonAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopReason>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        stopReason,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopReason>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StopReason>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        stopReason,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StopReason>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        stopReason,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STOPREASONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STOPREASONApi - factory interface
 * @export
 */
export const STOPREASONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STOPREASONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StopReasonAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopReason> {
      return localVarFp
        .runCreate(stopReason, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopReason> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StopReason> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, stopReason, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StopReason>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StopReason} stopReason Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      stopReason: StopReason,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, stopReason, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STOPREASONApi - object-oriented interface
 * @export
 * @class STOPREASONApi
 * @extends {BaseAPI}
 */
export class STOPREASONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STOPREASONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StopReason} stopReason Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runCreate(stopReason: StopReason, options?: RawAxiosRequestConfig) {
    return STOPREASONApiFp(this.configuration)
      .runCreate(stopReason, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STOPREASONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STOPREASONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STOPREASONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StopReason} stopReason Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runPatch(
    id: string,
    stopReason: StopReason,
    options?: RawAxiosRequestConfig
  ) {
    return STOPREASONApiFp(this.configuration)
      .runPatch(id, stopReason, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STOPREASONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STOPREASONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StopReason} stopReason Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STOPREASONApi
   */
  public runUpdate(
    id: string,
    stopReason: StopReason,
    options?: RawAxiosRequestConfig
  ) {
    return STOPREASONApiFp(this.configuration)
      .runUpdate(id, stopReason, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTApi - axios parameter creator
 * @export
 */
export const STUDENTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/student/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PackageChanged} packageChanged Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runChangePackage: async (
      packageChanged: PackageChanged,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'packageChanged' is not null or undefined
      assertParamExists("runChangePackage", "packageChanged", packageChanged);
      const localVarPath = `/student-api/change-package`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        packageChanged,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runChangePackageEnrollToIndividual: async (
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'packageEnrollToIndividual' is not null or undefined
      assertParamExists(
        "runChangePackageEnrollToIndividual",
        "packageEnrollToIndividual",
        packageEnrollToIndividual
      );
      const localVarPath = `/student-api/change-package-enroll-to-individual`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        packageEnrollToIndividual,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckForAvailablePackage: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runCheckForAvailablePackage", "id", id);
      const localVarPath = `/student-api/{id}/check-available-package`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      student: Student,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'student' is not null or undefined
      assertParamExists("runCreate", "student", student);
      const localVarPath = `/student`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        student,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<NewProductEnrollment>} newProductEnrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateEnrollments: async (
      id: string,
      newProductEnrollment: Array<NewProductEnrollment>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runCreateEnrollments", "id", id);
      // verify required parameter 'newProductEnrollment' is not null or undefined
      assertParamExists(
        "runCreateEnrollments",
        "newProductEnrollment",
        newProductEnrollment
      );
      const localVarPath = `/student-api/{id}/enrollments`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newProductEnrollment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/student`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/student/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/student/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/student/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveEnrollments: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetActiveEnrollments", "id", id);
      const localVarPath = `/student-api/{id}/active-enrollments`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveStudentQty: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/student-api/active-students`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollmentHistories: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetEnrollmentHistories", "id", id);
      const localVarPath = `/student-api/{id}/enrollment-histories`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollments: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetEnrollments", "id", id);
      const localVarPath = `/student-api/{id}/enrollments`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetOutstandingInvoice: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetOutstandingInvoice", "id", id);
      const localVarPath = `/student-api/{id}/outstanding`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPhoto", "id", id);
      const localVarPath = `/student-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentSummary: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetStudentSummary", "id", id);
      const localVarPath = `/student-api/{id}/summary`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTransactions: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetTransactions", "id", id);
      const localVarPath = `/student-api/{id}/billing-history`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<ImportStudent>} importStudent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportStudents: async (
      importStudent: Array<ImportStudent>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'importStudent' is not null or undefined
      assertParamExists("runImportStudents", "importStudent", importStudent);
      const localVarPath = `/student-api/imports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        importStudent,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {IndividualtoPackage} individualtoPackage Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runIndividualToPackage: async (
      individualtoPackage: IndividualtoPackage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'individualtoPackage' is not null or undefined
      assertParamExists(
        "runIndividualToPackage",
        "individualtoPackage",
        individualtoPackage
      );
      const localVarPath = `/student-api/individual-to-package`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        individualtoPackage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PackageModified} packageModified Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runModifyPackage: async (
      packageModified: PackageModified,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'packageModified' is not null or undefined
      assertParamExists("runModifyPackage", "packageModified", packageModified);
      const localVarPath = `/student-api/modify-package`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        packageModified,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      student: Student,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'student' is not null or undefined
      assertParamExists("runPatch", "student", student);
      const localVarPath = `/student/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        student,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/student/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/student/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchStudentListWithSummary: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearchStudentListWithSummary", "body", body);
      const localVarPath = `/student-api/studentlist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStopPackageEnroll: async (
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'packageEnrollToIndividual' is not null or undefined
      assertParamExists(
        "runStopPackageEnroll",
        "packageEnrollToIndividual",
        packageEnrollToIndividual
      );
      const localVarPath = `/student-api/stop-package-enroll`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        packageEnrollToIndividual,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      student: Student,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'student' is not null or undefined
      assertParamExists("runUpdate", "student", student);
      const localVarPath = `/student/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        student,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {UpgradeStudentLevelRequestBody} upgradeStudentLevelRequestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpgradeStudentLevel: async (
      upgradeStudentLevelRequestBody: UpgradeStudentLevelRequestBody,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'upgradeStudentLevelRequestBody' is not null or undefined
      assertParamExists(
        "runUpgradeStudentLevel",
        "upgradeStudentLevelRequestBody",
        upgradeStudentLevelRequestBody
      );
      const localVarPath = `/student-api/upgrade-student-level`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        upgradeStudentLevelRequestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto: async (
      id: string,
      uploadPhoto: UploadPhoto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadPhoto", "id", id);
      // verify required parameter 'uploadPhoto' is not null or undefined
      assertParamExists("runUploadPhoto", "uploadPhoto", uploadPhoto);
      const localVarPath = `/student-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadPhoto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTApi - functional programming interface
 * @export
 */
export const STUDENTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = STUDENTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PackageChanged} packageChanged Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runChangePackage(
      packageChanged: PackageChanged,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runChangePackage(
          packageChanged,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runChangePackage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runChangePackageEnrollToIndividual(
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runChangePackageEnrollToIndividual(
          packageEnrollToIndividual,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runChangePackageEnrollToIndividual"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckForAvailablePackage(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AvailablePackageResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckForAvailablePackage(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runCheckForAvailablePackage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      student: Student,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        student,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<NewProductEnrollment>} newProductEnrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreateEnrollments(
      id: string,
      newProductEnrollment: Array<NewProductEnrollment>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueueJobProducerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCreateEnrollments(
          id,
          newProductEnrollment,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runCreateEnrollments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetActiveEnrollments(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<EnrollmentItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetActiveEnrollments(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetActiveEnrollments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetActiveStudentQty(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetActiveStudentQty(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetActiveStudentQty"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetEnrollmentHistories(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<EnrollmentItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetEnrollmentHistories(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetEnrollmentHistories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetEnrollments(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<EnrollmentItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetEnrollments(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetEnrollments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetOutstandingInvoice(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OutstandingInvoice>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetOutstandingInvoice(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetOutstandingInvoice"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetPhoto(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetStudentSummary(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentWithSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetStudentSummary(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetStudentSummary"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTransactions(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<BillingHistoryItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTransactions(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runGetTransactions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<ImportStudent>} importStudent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runImportStudents(
      importStudent: Array<ImportStudent>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ImportErrorMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runImportStudents(
          importStudent,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runImportStudents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {IndividualtoPackage} individualtoPackage Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runIndividualToPackage(
      individualtoPackage: IndividualtoPackage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runIndividualToPackage(
          individualtoPackage,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runIndividualToPackage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PackageModified} packageModified Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runModifyPackage(
      packageModified: PackageModified,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runModifyPackage(
          packageModified,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runModifyPackage"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      student: Student,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        student,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearchStudentListWithSummary(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentListItemWithSummary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSearchStudentListWithSummary(
          body,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runSearchStudentListWithSummary"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runStopPackageEnroll(
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runStopPackageEnroll(
          packageEnrollToIndividual,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runStopPackageEnroll"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      student: Student,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        student,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {UpgradeStudentLevelRequestBody} upgradeStudentLevelRequestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpgradeStudentLevel(
      upgradeStudentLevelRequestBody: UpgradeStudentLevelRequestBody,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpgradeStudentLevel(
          upgradeStudentLevelRequestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runUpgradeStudentLevel"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUploadPhoto(
        id,
        uploadPhoto,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTApi.runUploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTApi - factory interface
 * @export
 */
export const STUDENTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PackageChanged} packageChanged Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runChangePackage(
      packageChanged: PackageChanged,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runChangePackage(packageChanged, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runChangePackageEnrollToIndividual(
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runChangePackageEnrollToIndividual(packageEnrollToIndividual, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckForAvailablePackage(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AvailablePackageResponse>> {
      return localVarFp
        .runCheckForAvailablePackage(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      student: Student,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Student> {
      return localVarFp
        .runCreate(student, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<NewProductEnrollment>} newProductEnrollment Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateEnrollments(
      id: string,
      newProductEnrollment: Array<NewProductEnrollment>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJobProducerResponse> {
      return localVarFp
        .runCreateEnrollments(id, newProductEnrollment, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Student> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Student> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Student>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveEnrollments(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<EnrollmentItem>> {
      return localVarFp
        .runGetActiveEnrollments(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveStudentQty(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<number> {
      return localVarFp
        .runGetActiveStudentQty(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollmentHistories(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<EnrollmentItem>> {
      return localVarFp
        .runGetEnrollmentHistories(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetEnrollments(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<EnrollmentItem>> {
      return localVarFp
        .runGetEnrollments(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetOutstandingInvoice(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OutstandingInvoice>> {
      return localVarFp
        .runGetOutstandingInvoice(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .runGetPhoto(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentSummary(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentWithSummary> {
      return localVarFp
        .runGetStudentSummary(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTransactions(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<BillingHistoryItem>> {
      return localVarFp
        .runGetTransactions(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<ImportStudent>} importStudent Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runImportStudents(
      importStudent: Array<ImportStudent>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ImportErrorMessage>> {
      return localVarFp
        .runImportStudents(importStudent, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {IndividualtoPackage} individualtoPackage Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runIndividualToPackage(
      individualtoPackage: IndividualtoPackage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runIndividualToPackage(individualtoPackage, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PackageModified} packageModified Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runModifyPackage(
      packageModified: PackageModified,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runModifyPackage(packageModified, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      student: Student,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, student, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Student>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearchStudentListWithSummary(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentListItemWithSummary>> {
      return localVarFp
        .runSearchStudentListWithSummary(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStopPackageEnroll(
      packageEnrollToIndividual: PackageEnrollToIndividual,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runStopPackageEnroll(packageEnrollToIndividual, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Student} student Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      student: Student,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, student, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {UpgradeStudentLevelRequestBody} upgradeStudentLevelRequestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpgradeStudentLevel(
      upgradeStudentLevelRequestBody: UpgradeStudentLevelRequestBody,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpgradeStudentLevel(upgradeStudentLevelRequestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadPhoto(id, uploadPhoto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTApi - object-oriented interface
 * @export
 * @class STUDENTApi
 * @extends {BaseAPI}
 */
export class STUDENTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PackageChanged} packageChanged Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runChangePackage(
    packageChanged: PackageChanged,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runChangePackage(packageChanged, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runChangePackageEnrollToIndividual(
    packageEnrollToIndividual: PackageEnrollToIndividual,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runChangePackageEnrollToIndividual(packageEnrollToIndividual, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runCheckForAvailablePackage(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runCheckForAvailablePackage(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Student} student Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runCreate(student: Student, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runCreate(student, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Array<NewProductEnrollment>} newProductEnrollment Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runCreateEnrollments(
    id: string,
    newProductEnrollment: Array<NewProductEnrollment>,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runCreateEnrollments(id, newProductEnrollment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetActiveEnrollments(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetActiveEnrollments(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetActiveStudentQty(options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetActiveStudentQty(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetEnrollmentHistories(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runGetEnrollmentHistories(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetEnrollments(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetEnrollments(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetOutstandingInvoice(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetOutstandingInvoice(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetPhoto(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetPhoto(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetStudentSummary(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetStudentSummary(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runGetTransactions(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runGetTransactions(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<ImportStudent>} importStudent Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runImportStudents(
    importStudent: Array<ImportStudent>,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runImportStudents(importStudent, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {IndividualtoPackage} individualtoPackage Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runIndividualToPackage(
    individualtoPackage: IndividualtoPackage,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runIndividualToPackage(individualtoPackage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PackageModified} packageModified Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runModifyPackage(
    packageModified: PackageModified,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runModifyPackage(packageModified, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Student} student Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runPatch(
    id: string,
    student: Student,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runPatch(id, student, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runSearchStudentListWithSummary(
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runSearchStudentListWithSummary(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PackageEnrollToIndividual} packageEnrollToIndividual Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runStopPackageEnroll(
    packageEnrollToIndividual: PackageEnrollToIndividual,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runStopPackageEnroll(packageEnrollToIndividual, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Student} student Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runUpdate(
    id: string,
    student: Student,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runUpdate(id, student, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {UpgradeStudentLevelRequestBody} upgradeStudentLevelRequestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runUpgradeStudentLevel(
    upgradeStudentLevelRequestBody: UpgradeStudentLevelRequestBody,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runUpgradeStudentLevel(upgradeStudentLevelRequestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UploadPhoto} uploadPhoto Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTApi
   */
  public runUploadPhoto(
    id: string,
    uploadPhoto: UploadPhoto,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTApiFp(this.configuration)
      .runUploadPhoto(id, uploadPhoto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTAPIApi - axios parameter creator
 * @export
 */
export const STUDENTAPIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * obtain student schedules
     * @summary
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneStudentSchedules: async (
      studentId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentId' is not null or undefined
      assertParamExists("getOneStudentSchedules", "studentId", studentId);
      const localVarPath =
        `/studentapi/{studentId}/student-one-schedules`.replace(
          `{${"studentId"}}`,
          encodeURIComponent(String(studentId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * obtain student schedules
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneStudentSchedules_1: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getOneStudentSchedules_1", "id", id);
      const localVarPath = `/studentapi/{id}/student-one-schedules`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * design for parent, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParentBranches: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentapi/parent-branches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * obtain resource version
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceVersion: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentapi/resourceversion`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * obtain student schedules
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentSchedules: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentapi/student-schedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTAPIApi - functional programming interface
 * @export
 */
export const STUDENTAPIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STUDENTAPIApiAxiosParamCreator(configuration);
  return {
    /**
     * obtain student schedules
     * @summary
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOneStudentSchedules(
      studentId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentApiSchedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOneStudentSchedules(
          studentId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTAPIApi.getOneStudentSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * obtain student schedules
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOneStudentSchedules_1(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentApiSchedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOneStudentSchedules_1(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTAPIApi.getOneStudentSchedules_1"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * design for parent, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParentBranches(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParentBranch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getParentBranches(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTAPIApi.getParentBranches"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * obtain resource version
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceVersion(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getResourceVersion(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTAPIApi.getResourceVersion"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * obtain student schedules
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStudentSchedules(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentApiSchedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStudentSchedules(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTAPIApi.getStudentSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTAPIApi - factory interface
 * @export
 */
export const STUDENTAPIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTAPIApiFp(configuration);
  return {
    /**
     * obtain student schedules
     * @summary
     * @param {string} studentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneStudentSchedules(
      studentId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentApiSchedule>> {
      return localVarFp
        .getOneStudentSchedules(studentId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * obtain student schedules
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOneStudentSchedules_1(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentApiSchedule>> {
      return localVarFp
        .getOneStudentSchedules_1(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     * design for parent, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParentBranches(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ParentBranch> {
      return localVarFp
        .getParentBranches(options)
        .then(request => request(axios, basePath));
    },
    /**
     * obtain resource version
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceVersion(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getResourceVersion(options)
        .then(request => request(axios, basePath));
    },
    /**
     * obtain student schedules
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStudentSchedules(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentApiSchedule>> {
      return localVarFp
        .getStudentSchedules(options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTAPIApi - object-oriented interface
 * @export
 * @class STUDENTAPIApi
 * @extends {BaseAPI}
 */
export class STUDENTAPIApi extends BaseAPI {
  /**
   * obtain student schedules
   * @summary
   * @param {string} studentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTAPIApi
   */
  public getOneStudentSchedules(
    studentId: string,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTAPIApiFp(this.configuration)
      .getOneStudentSchedules(studentId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * obtain student schedules
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTAPIApi
   */
  public getOneStudentSchedules_1(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTAPIApiFp(this.configuration)
      .getOneStudentSchedules_1(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * design for parent, list branch by parent email
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTAPIApi
   */
  public getParentBranches(options?: RawAxiosRequestConfig) {
    return STUDENTAPIApiFp(this.configuration)
      .getParentBranches(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * obtain resource version
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTAPIApi
   */
  public getResourceVersion(options?: RawAxiosRequestConfig) {
    return STUDENTAPIApiFp(this.configuration)
      .getResourceVersion(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * obtain student schedules
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTAPIApi
   */
  public getStudentSchedules(options?: RawAxiosRequestConfig) {
    return STUDENTAPIApiFp(this.configuration)
      .getStudentSchedules(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTDESCRIPTIONApi - axios parameter creator
 * @export
 */
export const STUDENTDESCRIPTIONApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/studentdescription/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      studentDescription: StudentDescription,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentDescription' is not null or undefined
      assertParamExists("runCreate", "studentDescription", studentDescription);
      const localVarPath = `/studentdescription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentDescription,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentdescription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/studentdescription/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/studentdescription/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      studentDescription: StudentDescription,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'studentDescription' is not null or undefined
      assertParamExists("runPatch", "studentDescription", studentDescription);
      const localVarPath = `/studentdescription/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentDescription,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/studentdescription/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/studentdescription/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      studentDescription: StudentDescription,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'studentDescription' is not null or undefined
      assertParamExists("runUpdate", "studentDescription", studentDescription);
      const localVarPath = `/studentdescription/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentDescription,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTDESCRIPTIONApi - functional programming interface
 * @export
 */
export const STUDENTDESCRIPTIONApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    STUDENTDESCRIPTIONApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentDescriptionAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentDescription>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        studentDescription,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentDescription>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StudentDescription>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        studentDescription,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentDescription>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        studentDescription,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTDESCRIPTIONApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTDESCRIPTIONApi - factory interface
 * @export
 */
export const STUDENTDESCRIPTIONApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTDESCRIPTIONApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentDescriptionAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentDescription> {
      return localVarFp
        .runCreate(studentDescription, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentDescription> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentDescription> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, studentDescription, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentDescription>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentDescription} studentDescription Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      studentDescription: StudentDescription,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, studentDescription, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTDESCRIPTIONApi - object-oriented interface
 * @export
 * @class STUDENTDESCRIPTIONApi
 * @extends {BaseAPI}
 */
export class STUDENTDESCRIPTIONApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StudentDescription} studentDescription Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runCreate(
    studentDescription: StudentDescription,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runCreate(studentDescription, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentDescription} studentDescription Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runPatch(
    id: string,
    studentDescription: StudentDescription,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runPatch(id, studentDescription, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentDescription} studentDescription Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTDESCRIPTIONApi
   */
  public runUpdate(
    id: string,
    studentDescription: StudentDescription,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTDESCRIPTIONApiFp(this.configuration)
      .runUpdate(id, studentDescription, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTGROUPApi - axios parameter creator
 * @export
 */
export const STUDENTGROUPApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/studentgroup/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist: async (
      requestBody: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("runCheckUniqueKeyExist", "requestBody", requestBody);
      const localVarPath = `/studentgroup-api/union-exist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      studentGroup: StudentGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentGroup' is not null or undefined
      assertParamExists("runCreate", "studentGroup", studentGroup);
      const localVarPath = `/studentgroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentgroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/studentgroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/studentgroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      studentGroup: StudentGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'studentGroup' is not null or undefined
      assertParamExists("runPatch", "studentGroup", studentGroup);
      const localVarPath = `/studentgroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/studentgroup/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/studentgroup/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      studentGroup: StudentGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'studentGroup' is not null or undefined
      assertParamExists("runUpdate", "studentGroup", studentGroup);
      const localVarPath = `/studentgroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTGROUPApi - functional programming interface
 * @export
 */
export const STUDENTGROUPApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STUDENTGROUPApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentGroupAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCheckUniqueKeyExist(
          requestBody,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runCheckUniqueKeyExist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        studentGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        studentGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentGroup>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        studentGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTGROUPApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTGROUPApi - factory interface
 * @export
 */
export const STUDENTGROUPApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTGROUPApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentGroupAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<string>} requestBody Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCheckUniqueKeyExist(
      requestBody: Array<string>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .runCheckUniqueKeyExist(requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentGroup> {
      return localVarFp
        .runCreate(studentGroup, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentGroup> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentGroup> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, studentGroup, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentGroup>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentGroup} studentGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      studentGroup: StudentGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, studentGroup, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTGROUPApi - object-oriented interface
 * @export
 * @class STUDENTGROUPApi
 * @extends {BaseAPI}
 */
export class STUDENTGROUPApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<string>} requestBody Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runCheckUniqueKeyExist(
    requestBody: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .runCheckUniqueKeyExist(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StudentGroup} studentGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runCreate(
    studentGroup: StudentGroup,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .runCreate(studentGroup, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STUDENTGROUPApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTGROUPApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTGROUPApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentGroup} studentGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runPatch(
    id: string,
    studentGroup: StudentGroup,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .runPatch(id, studentGroup, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTGROUPApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentGroup} studentGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTGROUPApi
   */
  public runUpdate(
    id: string,
    studentGroup: StudentGroup,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTGROUPApiFp(this.configuration)
      .runUpdate(id, studentGroup, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTSOURCEApi - axios parameter creator
 * @export
 */
export const STUDENTSOURCEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/studentsource/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      studentSource: StudentSource,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentSource' is not null or undefined
      assertParamExists("runCreate", "studentSource", studentSource);
      const localVarPath = `/studentsource`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSource,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentsource`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/studentsource/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/studentsource/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      studentSource: StudentSource,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'studentSource' is not null or undefined
      assertParamExists("runPatch", "studentSource", studentSource);
      const localVarPath = `/studentsource/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSource,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/studentsource/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/studentsource/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      studentSource: StudentSource,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'studentSource' is not null or undefined
      assertParamExists("runUpdate", "studentSource", studentSource);
      const localVarPath = `/studentsource/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSource,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTSOURCEApi - functional programming interface
 * @export
 */
export const STUDENTSOURCEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STUDENTSOURCEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentSourceAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        studentSource,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        studentSource,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentSource>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        studentSource,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSOURCEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTSOURCEApi - factory interface
 * @export
 */
export const STUDENTSOURCEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTSOURCEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentSourceAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSource> {
      return localVarFp
        .runCreate(studentSource, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSource> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSource> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, studentSource, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentSource>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSource} studentSource Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      studentSource: StudentSource,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, studentSource, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTSOURCEApi - object-oriented interface
 * @export
 * @class STUDENTSOURCEApi
 * @extends {BaseAPI}
 */
export class STUDENTSOURCEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSOURCEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StudentSource} studentSource Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runCreate(
    studentSource: StudentSource,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runCreate(studentSource, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentSource} studentSource Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runPatch(
    id: string,
    studentSource: StudentSource,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runPatch(id, studentSource, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentSource} studentSource Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSOURCEApi
   */
  public runUpdate(
    id: string,
    studentSource: StudentSource,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSOURCEApiFp(this.configuration)
      .runUpdate(id, studentSource, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * STUDENTSUMMARYApi - axios parameter creator
 * @export
 */
export const STUDENTSUMMARYApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/studentsummary/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      studentSummary: StudentSummary,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'studentSummary' is not null or undefined
      assertParamExists("runCreate", "studentSummary", studentSummary);
      const localVarPath = `/studentsummary`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSummary,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/studentsummary`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/studentsummary/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/studentsummary/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      studentSummary: StudentSummary,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'studentSummary' is not null or undefined
      assertParamExists("runPatch", "studentSummary", studentSummary);
      const localVarPath = `/studentsummary/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSummary,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/studentsummary/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/studentsummary/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      studentSummary: StudentSummary,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'studentSummary' is not null or undefined
      assertParamExists("runUpdate", "studentSummary", studentSummary);
      const localVarPath = `/studentsummary/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        studentSummary,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * STUDENTSUMMARYApi - functional programming interface
 * @export
 */
export const STUDENTSUMMARYApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    STUDENTSUMMARYApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentSummaryAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        studentSummary,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentSummary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        studentSummary,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StudentSummary>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        studentSummary,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["STUDENTSUMMARYApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * STUDENTSUMMARYApi - factory interface
 * @export
 */
export const STUDENTSUMMARYApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = STUDENTSUMMARYApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentSummaryAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSummary> {
      return localVarFp
        .runCreate(studentSummary, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSummary> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<StudentSummary> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, studentSummary, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<StudentSummary>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {StudentSummary} studentSummary Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      studentSummary: StudentSummary,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, studentSummary, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * STUDENTSUMMARYApi - object-oriented interface
 * @export
 * @class STUDENTSUMMARYApi
 * @extends {BaseAPI}
 */
export class STUDENTSUMMARYApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StudentSummary} studentSummary Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runCreate(
    studentSummary: StudentSummary,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runCreate(studentSummary, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentSummary} studentSummary Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runPatch(
    id: string,
    studentSummary: StudentSummary,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runPatch(id, studentSummary, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {StudentSummary} studentSummary Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof STUDENTSUMMARYApi
   */
  public runUpdate(
    id: string,
    studentSummary: StudentSummary,
    options?: RawAxiosRequestConfig
  ) {
    return STUDENTSUMMARYApiFp(this.configuration)
      .runUpdate(id, studentSummary, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SYSTEMMESSAGEApi - axios parameter creator
 * @export
 */
export const SYSTEMMESSAGEApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/systemmessage/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      systemMessage: SystemMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemMessage' is not null or undefined
      assertParamExists("runCreate", "systemMessage", systemMessage);
      const localVarPath = `/systemmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        systemMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/systemmessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/systemmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/systemmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMsglist: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/systemmessage-api/msglist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      systemMessage: SystemMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'systemMessage' is not null or undefined
      assertParamExists("runPatch", "systemMessage", systemMessage);
      const localVarPath = `/systemmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        systemMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/systemmessage/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadmsg: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runReadmsg", "id", id);
      const localVarPath = `/systemmessage-api/{id}/read`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/systemmessage/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      systemMessage: SystemMessage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'systemMessage' is not null or undefined
      assertParamExists("runUpdate", "systemMessage", systemMessage);
      const localVarPath = `/systemmessage/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        systemMessage,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SYSTEMMESSAGEApi - functional programming interface
 * @export
 */
export const SYSTEMMESSAGEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SYSTEMMESSAGEApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SystemMessageAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        systemMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runMsglist(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SystemMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runMsglist(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runMsglist"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        systemMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runReadmsg(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemMessage>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runReadmsg(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runReadmsg"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SystemMessage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        systemMessage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SYSTEMMESSAGEApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SYSTEMMESSAGEApi - factory interface
 * @export
 */
export const SYSTEMMESSAGEApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SYSTEMMESSAGEApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SystemMessageAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemMessage> {
      return localVarFp
        .runCreate(systemMessage, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemMessage> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemMessage> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runMsglist(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SystemMessage>> {
      return localVarFp
        .runMsglist(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, systemMessage, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runReadmsg(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SystemMessage> {
      return localVarFp
        .runReadmsg(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<SystemMessage>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {SystemMessage} systemMessage Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      systemMessage: SystemMessage,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, systemMessage, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SYSTEMMESSAGEApi - object-oriented interface
 * @export
 * @class SYSTEMMESSAGEApi
 * @extends {BaseAPI}
 */
export class SYSTEMMESSAGEApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SystemMessage} systemMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runCreate(
    systemMessage: SystemMessage,
    options?: RawAxiosRequestConfig
  ) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runCreate(systemMessage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runMsglist(options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runMsglist(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {SystemMessage} systemMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runPatch(
    id: string,
    systemMessage: SystemMessage,
    options?: RawAxiosRequestConfig
  ) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runPatch(id, systemMessage, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runReadmsg(id: string, options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runReadmsg(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {SystemMessage} systemMessage Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SYSTEMMESSAGEApi
   */
  public runUpdate(
    id: string,
    systemMessage: SystemMessage,
    options?: RawAxiosRequestConfig
  ) {
    return SYSTEMMESSAGEApiFp(this.configuration)
      .runUpdate(id, systemMessage, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TEACHERApi - axios parameter creator
 * @export
 */
export const TEACHERApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/teacher/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      teacher: Teacher,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teacher' is not null or undefined
      assertParamExists("runCreate", "teacher", teacher);
      const localVarPath = `/teacher`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacher,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherCommissionSettingRequest} teacherCommissionSettingRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateTeacherCommission: async (
      id: string,
      teacherCommissionSettingRequest: TeacherCommissionSettingRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runCreateTeacherCommission", "id", id);
      // verify required parameter 'teacherCommissionSettingRequest' is not null or undefined
      assertParamExists(
        "runCreateTeacherCommission",
        "teacherCommissionSettingRequest",
        teacherCommissionSettingRequest
      );
      const localVarPath =
        `/teacher-api/{id}/teacher-commission-settings`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacherCommissionSettingRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/teacher`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/teacher/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/teacher/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/teacher/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceByTeacher: async (
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runGetAttendanceByTeacher", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runGetAttendanceByTeacher", "dateTo", dateTo);
      const localVarPath =
        `/teacher-api/{dateFrom}/{dateTo}/attendance-by-teacher`
          .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
          .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceSummaryByTable: async (
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runGetAttendanceSummaryByTable", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runGetAttendanceSummaryByTable", "dateTo", dateTo);
      const localVarPath =
        `/teacher-api/{dateFrom}/{dateTo}/attendancesummary-by-table`
          .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
          .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPhoto", "id", id);
      const localVarPath = `/teacher-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherByLvl: async (
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runGetTeacherByLvl", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runGetTeacherByLvl", "dateTo", dateTo);
      const localVarPath = `/teacher-api/{dateFrom}/{dateTo}/teacher-by-lvl`
        .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
        .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherCommissionResult: async (
      period: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'period' is not null or undefined
      assertParamExists("runGetTeacherCommissionResult", "period", period);
      const localVarPath = `/teacher-api/teacherCommission/{period}`.replace(
        `{${"period"}}`,
        encodeURIComponent(String(period))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherCommissionSetting: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetTeacherCommissionSetting", "id", id);
      const localVarPath =
        `/teacher-api/{id}/teacher-commission-settings`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherGroupAnalyse: async (
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runGetTeacherGroupAnalyse", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runGetTeacherGroupAnalyse", "dateTo", dateTo);
      const localVarPath =
        `/teacher-api/{dateFrom}/{dateTo}/teacher-group-analyse`
          .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
          .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherPerformance: async (
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists("runGetTeacherPerformance", "dateFrom", dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists("runGetTeacherPerformance", "dateTo", dateTo);
      const localVarPath =
        `/teacher-api/{dateFrom}/{dateTo}/teacher-performance`
          .replace(`{${"dateFrom"}}`, encodeURIComponent(String(dateFrom)))
          .replace(`{${"dateTo"}}`, encodeURIComponent(String(dateTo)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      teacher: Teacher,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'teacher' is not null or undefined
      assertParamExists("runPatch", "teacher", teacher);
      const localVarPath = `/teacher/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacher,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/teacher/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/teacher/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      teacher: Teacher,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'teacher' is not null or undefined
      assertParamExists("runUpdate", "teacher", teacher);
      const localVarPath = `/teacher/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacher,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto: async (
      id: string,
      uploadPhoto: UploadPhoto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadPhoto", "id", id);
      // verify required parameter 'uploadPhoto' is not null or undefined
      assertParamExists("runUploadPhoto", "uploadPhoto", uploadPhoto);
      const localVarPath = `/teacher-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadPhoto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TEACHERApi - functional programming interface
 * @export
 */
export const TEACHERApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TEACHERApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TeacherAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        teacher,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherCommissionSettingRequest} teacherCommissionSettingRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreateTeacherCommission(
      id: string,
      teacherCommissionSettingRequest: TeacherCommissionSettingRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCreateTeacherCommission(
          id,
          teacherCommissionSettingRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runCreateTeacherCommission"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetAttendanceByTeacher(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AttendanceSummaryByTeacher>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetAttendanceByTeacher(
          dateFrom,
          dateTo,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetAttendanceByTeacher"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetAttendanceSummaryByTable(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AttendanceSummaryByTable>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetAttendanceSummaryByTable(
          dateFrom,
          dateTo,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetAttendanceSummaryByTable"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetPhoto(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTeacherByLvl(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TeacherByLvl>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTeacherByLvl(
          dateFrom,
          dateTo,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetTeacherByLvl"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTeacherCommissionResult(
      period: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CommissionResponseData>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTeacherCommissionResult(
          period,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetTeacherCommissionResult"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTeacherCommissionSetting(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeacherCommissionSettingRequest>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTeacherCommissionSetting(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetTeacherCommissionSetting"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTeacherGroupAnalyse(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TeacherGroupAnalyse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTeacherGroupAnalyse(
          dateFrom,
          dateTo,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetTeacherGroupAnalyse"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTeacherPerformance(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TeacherPerformance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTeacherPerformance(
          dateFrom,
          dateTo,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runGetTeacherPerformance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        teacher,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        teacher,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUploadPhoto(
        id,
        uploadPhoto,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERApi.runUploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TEACHERApi - factory interface
 * @export
 */
export const TEACHERApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TEACHERApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TeacherAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Teacher> {
      return localVarFp
        .runCreate(teacher, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherCommissionSettingRequest} teacherCommissionSettingRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreateTeacherCommission(
      id: string,
      teacherCommissionSettingRequest: TeacherCommissionSettingRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runCreateTeacherCommission(
          id,
          teacherCommissionSettingRequest,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Teacher> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Teacher> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Teacher>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceByTeacher(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AttendanceSummaryByTeacher>> {
      return localVarFp
        .runGetAttendanceByTeacher(dateFrom, dateTo, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetAttendanceSummaryByTable(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<AttendanceSummaryByTable>> {
      return localVarFp
        .runGetAttendanceSummaryByTable(dateFrom, dateTo, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .runGetPhoto(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherByLvl(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TeacherByLvl>> {
      return localVarFp
        .runGetTeacherByLvl(dateFrom, dateTo, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherCommissionResult(
      period: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<CommissionResponseData>> {
      return localVarFp
        .runGetTeacherCommissionResult(period, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherCommissionSetting(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TeacherCommissionSettingRequest> {
      return localVarFp
        .runGetTeacherCommissionSetting(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherGroupAnalyse(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TeacherGroupAnalyse>> {
      return localVarFp
        .runGetTeacherGroupAnalyse(dateFrom, dateTo, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} dateFrom
     * @param {string} dateTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTeacherPerformance(
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TeacherPerformance> {
      return localVarFp
        .runGetTeacherPerformance(dateFrom, dateTo, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, teacher, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Teacher>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Teacher} teacher Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      teacher: Teacher,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, teacher, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadPhoto(id, uploadPhoto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TEACHERApi - object-oriented interface
 * @export
 * @class TEACHERApi
 * @extends {BaseAPI}
 */
export class TEACHERApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Teacher} teacher Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runCreate(teacher: Teacher, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runCreate(teacher, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TeacherCommissionSettingRequest} teacherCommissionSettingRequest Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runCreateTeacherCommission(
    id: string,
    teacherCommissionSettingRequest: TeacherCommissionSettingRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runCreateTeacherCommission(id, teacherCommissionSettingRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetAttendanceByTeacher(
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetAttendanceByTeacher(dateFrom, dateTo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetAttendanceSummaryByTable(
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetAttendanceSummaryByTable(dateFrom, dateTo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetPhoto(id: string, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runGetPhoto(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetTeacherByLvl(
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetTeacherByLvl(dateFrom, dateTo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} period
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetTeacherCommissionResult(
    period: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetTeacherCommissionResult(period, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetTeacherCommissionSetting(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetTeacherCommissionSetting(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetTeacherGroupAnalyse(
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetTeacherGroupAnalyse(dateFrom, dateTo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} dateFrom
   * @param {string} dateTo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runGetTeacherPerformance(
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runGetTeacherPerformance(dateFrom, dateTo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Teacher} teacher Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runPatch(
    id: string,
    teacher: Teacher,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runPatch(id, teacher, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return TEACHERApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Teacher} teacher Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runUpdate(
    id: string,
    teacher: Teacher,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runUpdate(id, teacher, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UploadPhoto} uploadPhoto Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERApi
   */
  public runUploadPhoto(
    id: string,
    uploadPhoto: UploadPhoto,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERApiFp(this.configuration)
      .runUploadPhoto(id, uploadPhoto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TEACHERGROUPApi - axios parameter creator
 * @export
 */
export const TEACHERGROUPApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/teachergroup/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      teacherGroup: TeacherGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teacherGroup' is not null or undefined
      assertParamExists("runCreate", "teacherGroup", teacherGroup);
      const localVarPath = `/teachergroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacherGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/teachergroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/teachergroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/teachergroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      teacherGroup: TeacherGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'teacherGroup' is not null or undefined
      assertParamExists("runPatch", "teacherGroup", teacherGroup);
      const localVarPath = `/teachergroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacherGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/teachergroup/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/teachergroup/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      teacherGroup: TeacherGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'teacherGroup' is not null or undefined
      assertParamExists("runUpdate", "teacherGroup", teacherGroup);
      const localVarPath = `/teachergroup/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teacherGroup,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TEACHERGROUPApi - functional programming interface
 * @export
 */
export const TEACHERGROUPApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TEACHERGROUPApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TeacherGroupAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        teacherGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeacherGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        teacherGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TeacherGroup>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        teacherGroup,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TEACHERGROUPApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TEACHERGROUPApi - factory interface
 * @export
 */
export const TEACHERGROUPApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TEACHERGROUPApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TeacherGroupAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TeacherGroup> {
      return localVarFp
        .runCreate(teacherGroup, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TeacherGroup> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TeacherGroup> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, teacherGroup, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TeacherGroup>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TeacherGroup} teacherGroup Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      teacherGroup: TeacherGroup,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, teacherGroup, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TEACHERGROUPApi - object-oriented interface
 * @export
 * @class TEACHERGROUPApi
 * @extends {BaseAPI}
 */
export class TEACHERGROUPApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERGROUPApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TeacherGroup} teacherGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runCreate(
    teacherGroup: TeacherGroup,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERGROUPApiFp(this.configuration)
      .runCreate(teacherGroup, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return TEACHERGROUPApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return TEACHERGROUPApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return TEACHERGROUPApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TeacherGroup} teacherGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runPatch(
    id: string,
    teacherGroup: TeacherGroup,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERGROUPApiFp(this.configuration)
      .runPatch(id, teacherGroup, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERGROUPApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return TEACHERGROUPApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TeacherGroup} teacherGroup Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TEACHERGROUPApi
   */
  public runUpdate(
    id: string,
    teacherGroup: TeacherGroup,
    options?: RawAxiosRequestConfig
  ) {
    return TEACHERGROUPApiFp(this.configuration)
      .runUpdate(id, teacherGroup, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TENANTApi - axios parameter creator
 * @export
 */
export const TENANTApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/tenant/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      tenant: Tenant,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tenant' is not null or undefined
      assertParamExists("runCreate", "tenant", tenant);
      const localVarPath = `/tenant`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenant,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tenant`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/tenant/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/tenant/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetOutstandingSetting: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetOutstandingSetting", "id", id);
      const localVarPath = `/tenant-api/{id}/getOutstandingSetting`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      tenant: Tenant,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'tenant' is not null or undefined
      assertParamExists("runPatch", "tenant", tenant);
      const localVarPath = `/tenant/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenant,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/tenant/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {OutstandingSettingResponse} outstandingSettingResponse Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSaveOutstandingSetting: async (
      id: string,
      outstandingSettingResponse: OutstandingSettingResponse,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runSaveOutstandingSetting", "id", id);
      // verify required parameter 'outstandingSettingResponse' is not null or undefined
      assertParamExists(
        "runSaveOutstandingSetting",
        "outstandingSettingResponse",
        outstandingSettingResponse
      );
      const localVarPath = `/tenant-api/{id}/saveOutstandingSetting`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        outstandingSettingResponse,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/tenant/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      tenant: Tenant,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'tenant' is not null or undefined
      assertParamExists("runUpdate", "tenant", tenant);
      const localVarPath = `/tenant/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenant,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TENANTApi - functional programming interface
 * @export
 */
export const TENANTApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TENANTApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TenantAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        tenant,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetOutstandingSetting(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<OutstandingSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetOutstandingSetting(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runGetOutstandingSetting"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        tenant,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {OutstandingSettingResponse} outstandingSettingResponse Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSaveOutstandingSetting(
      id: string,
      outstandingSettingResponse: OutstandingSettingResponse,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSaveOutstandingSetting(
          id,
          outstandingSettingResponse,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runSaveOutstandingSetting"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tenant>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        tenant,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TENANTApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TENANTApi - factory interface
 * @export
 */
export const TENANTApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TENANTApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TenantAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tenant> {
      return localVarFp
        .runCreate(tenant, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tenant> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tenant> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetOutstandingSetting(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<OutstandingSetting> {
      return localVarFp
        .runGetOutstandingSetting(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, tenant, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {OutstandingSettingResponse} outstandingSettingResponse Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSaveOutstandingSetting(
      id: string,
      outstandingSettingResponse: OutstandingSettingResponse,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runSaveOutstandingSetting(id, outstandingSettingResponse, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Tenant>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Tenant} tenant Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      tenant: Tenant,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, tenant, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TENANTApi - object-oriented interface
 * @export
 * @class TENANTApi
 * @extends {BaseAPI}
 */
export class TENANTApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return TENANTApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Tenant} tenant Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runCreate(tenant: Tenant, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runCreate(tenant, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runGetOutstandingSetting(id: string, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runGetOutstandingSetting(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Tenant} tenant Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runPatch(id: string, tenant: Tenant, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runPatch(id, tenant, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TENANTApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {OutstandingSettingResponse} outstandingSettingResponse Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runSaveOutstandingSetting(
    id: string,
    outstandingSettingResponse: OutstandingSettingResponse,
    options?: RawAxiosRequestConfig
  ) {
    return TENANTApiFp(this.configuration)
      .runSaveOutstandingSetting(id, outstandingSettingResponse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return TENANTApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Tenant} tenant Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TENANTApi
   */
  public runUpdate(
    id: string,
    tenant: Tenant,
    options?: RawAxiosRequestConfig
  ) {
    return TENANTApiFp(this.configuration)
      .runUpdate(id, tenant, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TUITIONCLASSApi - axios parameter creator
 * @export
 */
export const TUITIONCLASSApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/tuitionclass/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CloseTuitionClassesRegistration} closeTuitionClassesRegistration Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCloseRegistrations: async (
      closeTuitionClassesRegistration: CloseTuitionClassesRegistration,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'closeTuitionClassesRegistration' is not null or undefined
      assertParamExists(
        "runCloseRegistrations",
        "closeTuitionClassesRegistration",
        closeTuitionClassesRegistration
      );
      const localVarPath = `/tuitionclass-api/close-registrations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        closeTuitionClassesRegistration,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      tuitionClass: TuitionClass,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tuitionClass' is not null or undefined
      assertParamExists("runCreate", "tuitionClass", tuitionClass);
      const localVarPath = `/tuitionclass`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tuitionClass,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tuitionclass`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/tuitionclass/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/tuitionclass/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runFullTextSearch", "body", body);
      const localVarPath = `/tuitionclass/fulltextsearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveClassQtyByMonth: async (
      month: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'month' is not null or undefined
      assertParamExists("runGetActiveClassQtyByMonth", "month", month);
      const localVarPath = `/tuitionclass-api/active-classes/{month}`.replace(
        `{${"month"}}`,
        encodeURIComponent(String(month))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassWithSchedules: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetTuitionClassWithSchedules", "id", id);
      const localVarPath = `/tuitionclass-api/{id}/get-schedules`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithLastScheduleParam} tuitionClassWithLastScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassesWithLastSchedules: async (
      tuitionClassWithLastScheduleParam: TuitionClassWithLastScheduleParam,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tuitionClassWithLastScheduleParam' is not null or undefined
      assertParamExists(
        "runGetTuitionClassesWithLastSchedules",
        "tuitionClassWithLastScheduleParam",
        tuitionClassWithLastScheduleParam
      );
      const localVarPath = `/tuitionclass-api/last-schedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tuitionClassWithLastScheduleParam,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithNearbyScheduleParam} tuitionClassWithNearbyScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassesWithNearbySchedules: async (
      tuitionClassWithNearbyScheduleParam: TuitionClassWithNearbyScheduleParam,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'tuitionClassWithNearbyScheduleParam' is not null or undefined
      assertParamExists(
        "runGetTuitionClassesWithNearbySchedules",
        "tuitionClassWithNearbyScheduleParam",
        tuitionClassWithNearbyScheduleParam
      );
      const localVarPath = `/tuitionclass-api/nearby-schedules`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tuitionClassWithNearbyScheduleParam,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      tuitionClass: TuitionClass,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'tuitionClass' is not null or undefined
      assertParamExists("runPatch", "tuitionClass", tuitionClass);
      const localVarPath = `/tuitionclass/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tuitionClass,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/tuitionclass/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPreviewRegenerateSchedule: async (
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regenerateTuitionClassSchedule' is not null or undefined
      assertParamExists(
        "runPreviewRegenerateSchedule",
        "regenerateTuitionClassSchedule",
        regenerateTuitionClassSchedule
      );
      const localVarPath = `/tuitionclass-api/regenerate-schedule/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        regenerateTuitionClassSchedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/tuitionclass/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSendRecheduleQueue: async (
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'regenerateTuitionClassSchedule' is not null or undefined
      assertParamExists(
        "runSendRecheduleQueue",
        "regenerateTuitionClassSchedule",
        regenerateTuitionClassSchedule
      );
      const localVarPath = `/tuitionclass-api/regenerate-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        regenerateTuitionClassSchedule,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      tuitionClass: TuitionClass,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'tuitionClass' is not null or undefined
      assertParamExists("runUpdate", "tuitionClass", tuitionClass);
      const localVarPath = `/tuitionclass/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tuitionClass,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TUITIONCLASSApi - functional programming interface
 * @export
 */
export const TUITIONCLASSApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TUITIONCLASSApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClassAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {CloseTuitionClassesRegistration} closeTuitionClassesRegistration Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCloseRegistrations(
      closeTuitionClassesRegistration: CloseTuitionClassesRegistration,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClass>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runCloseRegistrations(
          closeTuitionClassesRegistration,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runCloseRegistrations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuitionClass>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        tuitionClass,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuitionClass>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TuitionClass>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClass>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runFullTextSearch(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runFullTextSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetActiveClassQtyByMonth(
      month: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetActiveClassQtyByMonth(
          month,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runGetActiveClassQtyByMonth"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTuitionClassWithSchedules(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TuitionClassWithSchedules>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTuitionClassWithSchedules(
          id,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runGetTuitionClassWithSchedules"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithLastScheduleParam} tuitionClassWithLastScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTuitionClassesWithLastSchedules(
      tuitionClassWithLastScheduleParam: TuitionClassWithLastScheduleParam,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClassWithLastSchedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTuitionClassesWithLastSchedules(
          tuitionClassWithLastScheduleParam,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "TUITIONCLASSApi.runGetTuitionClassesWithLastSchedules"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithNearbyScheduleParam} tuitionClassWithNearbyScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetTuitionClassesWithNearbySchedules(
      tuitionClassWithNearbyScheduleParam: TuitionClassWithNearbyScheduleParam,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClassWithNearbySchedule>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetTuitionClassesWithNearbySchedules(
          tuitionClassWithNearbyScheduleParam,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "TUITIONCLASSApi.runGetTuitionClassesWithNearbySchedules"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        tuitionClass,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPreviewRegenerateSchedule(
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ScheduleChanges>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runPreviewRegenerateSchedule(
          regenerateTuitionClassSchedule,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runPreviewRegenerateSchedule"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TuitionClass>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSendRecheduleQueue(
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueueJobProducerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runSendRecheduleQueue(
          regenerateTuitionClassSchedule,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runSendRecheduleQueue"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        tuitionClass,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUITIONCLASSApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TUITIONCLASSApi - factory interface
 * @export
 */
export const TUITIONCLASSApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TUITIONCLASSApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClassAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CloseTuitionClassesRegistration} closeTuitionClassesRegistration Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCloseRegistrations(
      closeTuitionClassesRegistration: CloseTuitionClassesRegistration,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClass>> {
      return localVarFp
        .runCloseRegistrations(closeTuitionClassesRegistration, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TuitionClass> {
      return localVarFp
        .runCreate(tuitionClass, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TuitionClass> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TuitionClass> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFullTextSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClass>> {
      return localVarFp
        .runFullTextSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetActiveClassQtyByMonth(
      month: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<number> {
      return localVarFp
        .runGetActiveClassQtyByMonth(month, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassWithSchedules(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TuitionClassWithSchedules> {
      return localVarFp
        .runGetTuitionClassWithSchedules(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithLastScheduleParam} tuitionClassWithLastScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassesWithLastSchedules(
      tuitionClassWithLastScheduleParam: TuitionClassWithLastScheduleParam,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClassWithLastSchedule>> {
      return localVarFp
        .runGetTuitionClassesWithLastSchedules(
          tuitionClassWithLastScheduleParam,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {TuitionClassWithNearbyScheduleParam} tuitionClassWithNearbyScheduleParam Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetTuitionClassesWithNearbySchedules(
      tuitionClassWithNearbyScheduleParam: TuitionClassWithNearbyScheduleParam,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClassWithNearbySchedule>> {
      return localVarFp
        .runGetTuitionClassesWithNearbySchedules(
          tuitionClassWithNearbyScheduleParam,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, tuitionClass, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPreviewRegenerateSchedule(
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<ScheduleChanges>> {
      return localVarFp
        .runPreviewRegenerateSchedule(regenerateTuitionClassSchedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TuitionClass>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSendRecheduleQueue(
      regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<QueueJobProducerResponse> {
      return localVarFp
        .runSendRecheduleQueue(regenerateTuitionClassSchedule, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TuitionClass} tuitionClass Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      tuitionClass: TuitionClass,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, tuitionClass, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TUITIONCLASSApi - object-oriented interface
 * @export
 * @class TUITIONCLASSApi
 * @extends {BaseAPI}
 */
export class TUITIONCLASSApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CloseTuitionClassesRegistration} closeTuitionClassesRegistration Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runCloseRegistrations(
    closeTuitionClassesRegistration: CloseTuitionClassesRegistration,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runCloseRegistrations(closeTuitionClassesRegistration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TuitionClass} tuitionClass Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runCreate(
    tuitionClass: TuitionClass,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runCreate(tuitionClass, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return TUITIONCLASSApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return TUITIONCLASSApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return TUITIONCLASSApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runFullTextSearch(body: object, options?: RawAxiosRequestConfig) {
    return TUITIONCLASSApiFp(this.configuration)
      .runFullTextSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} month
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runGetActiveClassQtyByMonth(
    month: string,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runGetActiveClassQtyByMonth(month, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runGetTuitionClassWithSchedules(
    id: string,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runGetTuitionClassWithSchedules(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TuitionClassWithLastScheduleParam} tuitionClassWithLastScheduleParam Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runGetTuitionClassesWithLastSchedules(
    tuitionClassWithLastScheduleParam: TuitionClassWithLastScheduleParam,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runGetTuitionClassesWithLastSchedules(
        tuitionClassWithLastScheduleParam,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {TuitionClassWithNearbyScheduleParam} tuitionClassWithNearbyScheduleParam Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runGetTuitionClassesWithNearbySchedules(
    tuitionClassWithNearbyScheduleParam: TuitionClassWithNearbyScheduleParam,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runGetTuitionClassesWithNearbySchedules(
        tuitionClassWithNearbyScheduleParam,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TuitionClass} tuitionClass Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runPatch(
    id: string,
    tuitionClass: TuitionClass,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runPatch(id, tuitionClass, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runPreviewRegenerateSchedule(
    regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runPreviewRegenerateSchedule(regenerateTuitionClassSchedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return TUITIONCLASSApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RegenerateTuitionClassSchedule} regenerateTuitionClassSchedule Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runSendRecheduleQueue(
    regenerateTuitionClassSchedule: RegenerateTuitionClassSchedule,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runSendRecheduleQueue(regenerateTuitionClassSchedule, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TuitionClass} tuitionClass Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUITIONCLASSApi
   */
  public runUpdate(
    id: string,
    tuitionClass: TuitionClass,
    options?: RawAxiosRequestConfig
  ) {
    return TUITIONCLASSApiFp(this.configuration)
      .runUpdate(id, tuitionClass, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TUTORAPIApi - axios parameter creator
 * @export
 */
export const TUTORAPIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * get attendance detail by scheduleId
     * @summary
     * @param {string} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTutorAttendance: async (
      scheduleId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'scheduleId' is not null or undefined
      assertParamExists("getTutorAttendance", "scheduleId", scheduleId);
      const localVarPath = `/tutorapi/attendance/{scheduleId}`.replace(
        `{${"scheduleId"}}`,
        encodeURIComponent(String(scheduleId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * design for tutor, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTutorBranches: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tutorapi/tutor-branches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentEnrollBySearch: async (
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'runGetStudentEnrollBySearchRequest' is not null or undefined
      assertParamExists(
        "runGetStudentEnrollBySearch",
        "runGetStudentEnrollBySearchRequest",
        runGetStudentEnrollBySearchRequest
      );
      const localVarPath = `/tutorapi/getStudentEnrollBySearch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        runGetStudentEnrollBySearchRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<TutorAttendanceUpdate>} tutorAttendanceUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendance: async (
      id: string,
      tutorAttendanceUpdate: Array<TutorAttendanceUpdate>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdateAttendance", "id", id);
      // verify required parameter 'tutorAttendanceUpdate' is not null or undefined
      assertParamExists(
        "runUpdateAttendance",
        "tutorAttendanceUpdate",
        tutorAttendanceUpdate
      );
      const localVarPath = `/tutorapi/attendance/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tutorAttendanceUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorAttendanceRemarkUpdate} tutorAttendanceRemarkUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendanceRemark: async (
      id: string,
      tutorAttendanceRemarkUpdate: TutorAttendanceRemarkUpdate,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdateAttendanceRemark", "id", id);
      // verify required parameter 'tutorAttendanceRemarkUpdate' is not null or undefined
      assertParamExists(
        "runUpdateAttendanceRemark",
        "tutorAttendanceRemarkUpdate",
        tutorAttendanceRemarkUpdate
      );
      const localVarPath = `/tutorapi/attendanceRemark/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tutorAttendanceRemarkUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorScheduleLessonPlanUpdate} tutorScheduleLessonPlanUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateScheduleLessonPlan: async (
      id: string,
      tutorScheduleLessonPlanUpdate: TutorScheduleLessonPlanUpdate,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdateScheduleLessonPlan", "id", id);
      // verify required parameter 'tutorScheduleLessonPlanUpdate' is not null or undefined
      assertParamExists(
        "runUpdateScheduleLessonPlan",
        "tutorScheduleLessonPlanUpdate",
        tutorScheduleLessonPlanUpdate
      );
      const localVarPath = `/tutorapi/scheduleLessonPlan/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tutorScheduleLessonPlanUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStudent: async (
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'runGetStudentEnrollBySearchRequest' is not null or undefined
      assertParamExists(
        "searchStudent",
        "runGetStudentEnrollBySearchRequest",
        runGetStudentEnrollBySearchRequest
      );
      const localVarPath = `/tutorapi/searchStudent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        runGetStudentEnrollBySearchRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TUTORAPIApi - functional programming interface
 * @export
 */
export const TUTORAPIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TUTORAPIApiAxiosParamCreator(configuration);
  return {
    /**
     * get attendance detail by scheduleId
     * @summary
     * @param {string} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTutorAttendance(
      scheduleId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TutorScheduleAttendance>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTutorAttendance(scheduleId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.getTutorAttendance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * design for tutor, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTutorBranches(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserBranch>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTutorBranches(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.getTutorBranches"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetStudentEnrollBySearch(
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TutorAttendanceSearch>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetStudentEnrollBySearch(
          runGetStudentEnrollBySearchRequest,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.runGetStudentEnrollBySearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<TutorAttendanceUpdate>} tutorAttendanceUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateAttendance(
      id: string,
      tutorAttendanceUpdate: Array<TutorAttendanceUpdate>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateAttendance(
          id,
          tutorAttendanceUpdate,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.runUpdateAttendance"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorAttendanceRemarkUpdate} tutorAttendanceRemarkUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateAttendanceRemark(
      id: string,
      tutorAttendanceRemarkUpdate: TutorAttendanceRemarkUpdate,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateAttendanceRemark(
          id,
          tutorAttendanceRemarkUpdate,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.runUpdateAttendanceRemark"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorScheduleLessonPlanUpdate} tutorScheduleLessonPlanUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdateScheduleLessonPlan(
      id: string,
      tutorScheduleLessonPlanUpdate: TutorScheduleLessonPlanUpdate,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdateScheduleLessonPlan(
          id,
          tutorScheduleLessonPlanUpdate,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.runUpdateScheduleLessonPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchStudent(
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchStudent>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchStudent(
        runGetStudentEnrollBySearchRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["TUTORAPIApi.searchStudent"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TUTORAPIApi - factory interface
 * @export
 */
export const TUTORAPIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TUTORAPIApiFp(configuration);
  return {
    /**
     * get attendance detail by scheduleId
     * @summary
     * @param {string} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTutorAttendance(
      scheduleId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TutorScheduleAttendance>> {
      return localVarFp
        .getTutorAttendance(scheduleId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * design for tutor, list branch by parent email
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTutorBranches(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<UserBranch>> {
      return localVarFp
        .getTutorBranches(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetStudentEnrollBySearch(
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TutorAttendanceSearch>> {
      return localVarFp
        .runGetStudentEnrollBySearch(
          runGetStudentEnrollBySearchRequest,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<TutorAttendanceUpdate>} tutorAttendanceUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendance(
      id: string,
      tutorAttendanceUpdate: Array<TutorAttendanceUpdate>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpdateAttendance(id, tutorAttendanceUpdate, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorAttendanceRemarkUpdate} tutorAttendanceRemarkUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateAttendanceRemark(
      id: string,
      tutorAttendanceRemarkUpdate: TutorAttendanceRemarkUpdate,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpdateAttendanceRemark(id, tutorAttendanceRemarkUpdate, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {TutorScheduleLessonPlanUpdate} tutorScheduleLessonPlanUpdate Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdateScheduleLessonPlan(
      id: string,
      tutorScheduleLessonPlanUpdate: TutorScheduleLessonPlanUpdate,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpdateScheduleLessonPlan(id, tutorScheduleLessonPlanUpdate, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStudent(
      runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SearchStudent> {
      return localVarFp
        .searchStudent(runGetStudentEnrollBySearchRequest, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TUTORAPIApi - object-oriented interface
 * @export
 * @class TUTORAPIApi
 * @extends {BaseAPI}
 */
export class TUTORAPIApi extends BaseAPI {
  /**
   * get attendance detail by scheduleId
   * @summary
   * @param {string} scheduleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public getTutorAttendance(
    scheduleId: string,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .getTutorAttendance(scheduleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * design for tutor, list branch by parent email
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public getTutorBranches(options?: RawAxiosRequestConfig) {
    return TUTORAPIApiFp(this.configuration)
      .getTutorBranches(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public runGetStudentEnrollBySearch(
    runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .runGetStudentEnrollBySearch(runGetStudentEnrollBySearchRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Array<TutorAttendanceUpdate>} tutorAttendanceUpdate Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public runUpdateAttendance(
    id: string,
    tutorAttendanceUpdate: Array<TutorAttendanceUpdate>,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .runUpdateAttendance(id, tutorAttendanceUpdate, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TutorAttendanceRemarkUpdate} tutorAttendanceRemarkUpdate Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public runUpdateAttendanceRemark(
    id: string,
    tutorAttendanceRemarkUpdate: TutorAttendanceRemarkUpdate,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .runUpdateAttendanceRemark(id, tutorAttendanceRemarkUpdate, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {TutorScheduleLessonPlanUpdate} tutorScheduleLessonPlanUpdate Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public runUpdateScheduleLessonPlan(
    id: string,
    tutorScheduleLessonPlanUpdate: TutorScheduleLessonPlanUpdate,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .runUpdateScheduleLessonPlan(id, tutorScheduleLessonPlanUpdate, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RunGetStudentEnrollBySearchRequest} runGetStudentEnrollBySearchRequest Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TUTORAPIApi
   */
  public searchStudent(
    runGetStudentEnrollBySearchRequest: RunGetStudentEnrollBySearchRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TUTORAPIApiFp(this.configuration)
      .searchStudent(runGetStudentEnrollBySearchRequest, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * USERApi - axios parameter creator
 * @export
 */
export const USERApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/user/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      user: User,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists("runCreate", "user", user);
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPermission: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPermission", "id", id);
      const localVarPath = `/user-api/{id}/permission`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetPhoto", "id", id);
      const localVarPath = `/user-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      user: User,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("runPatch", "user", user);
      const localVarPath = `/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/user/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/user/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      user: User,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("runUpdate", "user", user);
      const localVarPath = `/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<UserPermission>} userPermission Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdatePermission: async (
      id: string,
      userPermission: Array<UserPermission>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdatePermission", "id", id);
      // verify required parameter 'userPermission' is not null or undefined
      assertParamExists(
        "runUpdatePermission",
        "userPermission",
        userPermission
      );
      const localVarPath = `/user-api/{id}/permission`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userPermission,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto: async (
      id: string,
      uploadPhoto: UploadPhoto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUploadPhoto", "id", id);
      // verify required parameter 'uploadPhoto' is not null or undefined
      assertParamExists("runUploadPhoto", "uploadPhoto", uploadPhoto);
      const localVarPath = `/user-api/{id}/photo`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadPhoto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * USERApi - functional programming interface
 * @export
 */
export const USERApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = USERApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      user: User,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        user,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runCreate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runDefault"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runDelete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runFindOne"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPermission(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserPermission>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runGetPermission(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runGetPermission"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetPhoto(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runGetPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      user: User,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        user,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runPatch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runSearch"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      user: User,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        user,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runUpdate"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<UserPermission>} userPermission Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdatePermission(
      id: string,
      userPermission: Array<UserPermission>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runUpdatePermission(
          id,
          userPermission,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runUpdatePermission"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUploadPhoto(
        id,
        uploadPhoto,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["USERApi.runUploadPhoto"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * USERApi - factory interface
 * @export
 */
export const USERApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = USERApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<UserAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp
        .runCreate(user, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPermission(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<UserPermission>> {
      return localVarFp
        .runGetPermission(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetPhoto(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .runGetPhoto(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      user: User,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, user, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {User} user Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      user: User,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, user, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Array<UserPermission>} userPermission Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdatePermission(
      id: string,
      userPermission: Array<UserPermission>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUpdatePermission(id, userPermission, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UploadPhoto} uploadPhoto Request Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUploadPhoto(
      id: string,
      uploadPhoto: UploadPhoto,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .runUploadPhoto(id, uploadPhoto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * USERApi - object-oriented interface
 * @export
 * @class USERApi
 * @extends {BaseAPI}
 */
export class USERApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return USERApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {User} user Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runCreate(user: User, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runCreate(user, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runGetPermission(id: string, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runGetPermission(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runGetPhoto(id: string, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runGetPhoto(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {User} user Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runPatch(id: string, user: User, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runPatch(id, user, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return USERApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {User} user Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runUpdate(id: string, user: User, options?: RawAxiosRequestConfig) {
    return USERApiFp(this.configuration)
      .runUpdate(id, user, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Array<UserPermission>} userPermission Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runUpdatePermission(
    id: string,
    userPermission: Array<UserPermission>,
    options?: RawAxiosRequestConfig
  ) {
    return USERApiFp(this.configuration)
      .runUpdatePermission(id, userPermission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UploadPhoto} uploadPhoto Request Body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USERApi
   */
  public runUploadPhoto(
    id: string,
    uploadPhoto: UploadPhoto,
    options?: RawAxiosRequestConfig
  ) {
    return USERApiFp(this.configuration)
      .runUploadPhoto(id, uploadPhoto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * WEBHOOKApi - axios parameter creator
 * @export
 */
export const WEBHOOKApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete: async (
      keyword: string,
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'keyword' is not null or undefined
      assertParamExists("autoComplete", "keyword", keyword);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("autoComplete", "body", body);
      const localVarPath = `/webhook/autocomplete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate: async (
      webhook: Webhook,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhook' is not null or undefined
      assertParamExists("runCreate", "webhook", webhook);
      const localVarPath = `/webhook`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webhook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhook`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runDelete", "id", id);
      const localVarPath = `/webhook/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runFindOne", "id", id);
      const localVarPath = `/webhook/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHistories: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runGetHistories", "id", id);
      const localVarPath = `/webhook-api/{id}/histories`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch: async (
      id: string,
      webhook: Webhook,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runPatch", "id", id);
      // verify required parameter 'webhook' is not null or undefined
      assertParamExists("runPatch", "webhook", webhook);
      const localVarPath = `/webhook/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webhook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany: async (
      patchManyRequest: PatchManyRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'patchManyRequest' is not null or undefined
      assertParamExists("runPatchMany", "patchManyRequest", patchManyRequest);
      const localVarPath = `/webhook/bulk-patch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchManyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch: async (
      body: object,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("runSearch", "body", body);
      const localVarPath = `/webhook/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate: async (
      id: string,
      webhook: Webhook,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("runUpdate", "id", id);
      // verify required parameter 'webhook' is not null or undefined
      assertParamExists("runUpdate", "webhook", webhook);
      const localVarPath = `/webhook/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-apisecret required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apisecret",
        configuration
      );

      // authentication x-guest-accesstoken required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-guest-accesstoken",
        configuration
      );

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "oauth2",
        [],
        configuration
      );

      // authentication x-apikey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "x-apikey",
        configuration
      );

      // authentication x-org required
      await setApiKeyToObject(localVarHeaderParameter, "x-org", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webhook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WEBHOOKApi - functional programming interface
 * @export
 */
export const WEBHOOKApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WEBHOOKApiAxiosParamCreator(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<WebhookAutoComplete>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
        keyword,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.autoComplete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runCreate(
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runCreate(
        webhook,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runCreate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDefault(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.runDefault(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runDefault"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runDelete(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runDelete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runFindOne(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runFindOne"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runGetHistories(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<WebhookLog>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runGetHistories(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runGetHistories"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatch(
      id: string,
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatch(
        id,
        webhook,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runPatch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UpdateManyResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPatchMany(
        patchManyRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runPatchMany"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webhook>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runSearch(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runSearch"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runUpdate(
      id: string,
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runUpdate(
        id,
        webhook,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["WEBHOOKApi.runUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * WEBHOOKApi - factory interface
 * @export
 */
export const WEBHOOKApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WEBHOOKApiFp(configuration);
  return {
    /**
     * retrieve array of {_id, code, name}
     * @summary
     * @param {string} keyword
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoComplete(
      keyword: string,
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<WebhookAutoComplete>> {
      return localVarFp
        .autoComplete(keyword, body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runCreate(
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Webhook> {
      return localVarFp
        .runCreate(webhook, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Run default behavior like say hello
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDefault(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .runDefault(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Webhook> {
      return localVarFp
        .runDelete(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Webhook> {
      return localVarFp
        .runFindOne(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runGetHistories(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<WebhookLog>> {
      return localVarFp
        .runGetHistories(id, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatch(
      id: string,
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runPatch(id, webhook, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {PatchManyRequest} patchManyRequest Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPatchMany(
      patchManyRequest: PatchManyRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UpdateManyResponse> {
      return localVarFp
        .runPatchMany(patchManyRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {object} body Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSearch(
      body: object,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Webhook>> {
      return localVarFp
        .runSearch(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {Webhook} webhook Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runUpdate(
      id: string,
      webhook: Webhook,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .runUpdate(id, webhook, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * WEBHOOKApi - object-oriented interface
 * @export
 * @class WEBHOOKApi
 * @extends {BaseAPI}
 */
export class WEBHOOKApi extends BaseAPI {
  /**
   * retrieve array of {_id, code, name}
   * @summary
   * @param {string} keyword
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public autoComplete(
    keyword: string,
    body: object,
    options?: RawAxiosRequestConfig
  ) {
    return WEBHOOKApiFp(this.configuration)
      .autoComplete(keyword, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Webhook} webhook Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runCreate(webhook: Webhook, options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runCreate(webhook, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Run default behavior like say hello
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runDefault(options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runDefault(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runDelete(id: string, options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runFindOne(id: string, options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runFindOne(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runGetHistories(id: string, options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runGetHistories(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Webhook} webhook Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runPatch(
    id: string,
    webhook: Webhook,
    options?: RawAxiosRequestConfig
  ) {
    return WEBHOOKApiFp(this.configuration)
      .runPatch(id, webhook, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {PatchManyRequest} patchManyRequest Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runPatchMany(
    patchManyRequest: PatchManyRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WEBHOOKApiFp(this.configuration)
      .runPatchMany(patchManyRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {object} body Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runSearch(body: object, options?: RawAxiosRequestConfig) {
    return WEBHOOKApiFp(this.configuration)
      .runSearch(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {Webhook} webhook Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WEBHOOKApi
   */
  public runUpdate(
    id: string,
    webhook: Webhook,
    options?: RawAxiosRequestConfig
  ) {
    return WEBHOOKApiFp(this.configuration)
      .runUpdate(id, webhook, options)
      .then(request => request(this.axios, this.basePath));
  }
}
